const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":211,\"nextId\":211,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"2\",\"3\":\"3\",\"4\":\"4\",\"5\":\"5\",\"6\":\"5#some-solutions-to-questions-about-qt\",\"7\":\"5#the-qt-5-isn-t-in-qt-maintenance-tools\",\"8\":\"6\",\"9\":\"7\",\"10\":\"7@0\",\"11\":\"7@1\",\"12\":\"8\",\"13\":\"8#环境\",\"14\":\"8#项目结构\",\"15\":\"8#配置http服务\",\"16\":\"8#配置nginx\",\"17\":\"8#配置docker\",\"18\":\"8#启动项目\",\"19\":\"8#升级为https\",\"20\":\"8#申请证书\",\"21\":\"8#安装证书\",\"22\":\"8#修改配置\",\"23\":\"8#重启container\",\"24\":\"8#配置nginx反向代理-使flask支持-https\",\"25\":\"8#参考资料\",\"26\":\"8@0\",\"27\":\"8@1\",\"28\":\"9\",\"29\":\"9#docker-wsl2-踩坑记录-唯独你没懂-居然把路径藏在这里\",\"30\":\"9#docker-wsl2-踩坑记录\",\"31\":\"9#docker-desktop-是什么\",\"32\":\"9#wsl-里的-docker-到底在哪里\",\"33\":\"10\",\"34\":\"11\",\"35\":\"12\",\"36\":\"12#背景介绍\",\"37\":\"12#过去的做法\",\"38\":\"12#第一种-直接取模\",\"39\":\"12#第二种-函数取模\",\"40\":\"12#泛型编程\",\"41\":\"12@0\",\"42\":\"12@1\",\"43\":\"13\",\"44\":\"14\",\"45\":\"15\",\"46\":\"16\",\"47\":\"16#自然数的定义\",\"48\":\"16#自然数的加法运算\",\"49\":\"16#加法的定义\",\"50\":\"16#加法结果的存在性\",\"51\":\"16#加法结果的唯一性\",\"52\":\"16#加法的性质\",\"53\":\"16#加法交换律\",\"54\":\"16#加法结合律\",\"55\":\"16#加法消去律\",\"56\":\"16#自然数的序\",\"57\":\"16#序的定义\",\"58\":\"16#正自然数\",\"59\":\"16#正自然数的性质\",\"60\":\"16#序的反对称性\",\"61\":\"16#序的传递性\",\"62\":\"16#序的完全性\",\"63\":\"16#加法保序性\",\"64\":\"16#自然数的乘法运算\",\"65\":\"16#乘法的定义\",\"66\":\"16#乘法结果的存在性\",\"67\":\"16#乘法结果的唯一性\",\"68\":\"16#乘法的性质\",\"69\":\"16#乘法交换律\",\"70\":\"16#乘法分配律\",\"71\":\"16#乘法结合律\",\"72\":\"16#乘法消去律\",\"73\":\"16#peano-公理的合理性\",\"74\":\"16#乘法保序性\",\"75\":\"16#乘法消去保序性\",\"76\":\"16#用图论阐述-peano-系统\",\"77\":\"16#peano-公理-i\",\"78\":\"16#peano-公理-ii\",\"79\":\"16#peano-公理-iii\",\"80\":\"16#peano-公理-iv\",\"81\":\"16#peano-公理-v\",\"82\":\"16@0\",\"83\":\"16@1\",\"84\":\"17\",\"85\":\"17#安装\",\"86\":\"17#tips\",\"87\":\"17#bug-记录\",\"88\":\"17@1\",\"89\":\"18\",\"90\":\"18#线程安全\",\"91\":\"18#协程\",\"92\":\"18#协程安全\",\"93\":\"18#协程是否需要加锁\",\"94\":\"19\",\"95\":\"20\",\"96\":\"20#缺点\",\"97\":\"20#缺点-1\",\"98\":\"21\",\"99\":\"21@0\",\"100\":\"21@1\",\"101\":\"22\",\"102\":\"23\",\"103\":\"24\",\"104\":\"24#为什么要学编译原理\",\"105\":\"24#理论很复杂-实现也很复杂\",\"106\":\"24#项目的初衷\",\"107\":\"24#做好心理准备\",\"108\":\"24#参考资料\",\"109\":\"25\",\"110\":\"25#编译器的构建流程\",\"111\":\"25#编译器框架\",\"112\":\"26\",\"113\":\"26#title-手把手教你构建-c-语言编译器-0-前言\",\"114\":\"26#计算机的内部工作原理\",\"115\":\"26#内存\",\"116\":\"26#寄存器\",\"117\":\"26#指令集\",\"118\":\"26#mov\",\"119\":\"26#push\",\"120\":\"26#jmp\",\"121\":\"26#jz-jnz\",\"122\":\"26#子函数调用\",\"123\":\"26#ent\",\"124\":\"26#adj\",\"125\":\"26#lev\",\"126\":\"26#lea\",\"127\":\"26#运算符指令\",\"128\":\"26#内置函数\",\"129\":\"26#测试\",\"130\":\"26#小结\",\"131\":\"27\",\"132\":\"27#什么是词法分析器\",\"133\":\"27#词法分析器与编译器\",\"134\":\"27#词法分析器的实现\",\"135\":\"27#支持的标记\",\"136\":\"27#词法分析器的框架\",\"137\":\"27#换行符\",\"138\":\"27#宏定义\",\"139\":\"27#标识符与符号表\",\"140\":\"27#数字\",\"141\":\"27#字符串\",\"142\":\"27#注释\",\"143\":\"27#其它\",\"144\":\"27#关键字与内置函数\",\"145\":\"27#代码\",\"146\":\"27#小结\",\"147\":\"28\",\"148\":\"28#什么是递归下降\",\"149\":\"28#终结符与非终结符\",\"150\":\"28#四则运算的递归下降\",\"151\":\"28#为什么选择递归下降\",\"152\":\"28#左递归\",\"153\":\"28#四则运算的实现\",\"154\":\"28#小结\",\"155\":\"29\",\"156\":\"29#ebnf-表示\",\"157\":\"29#解析变量的定义\",\"158\":\"29#program\",\"159\":\"29#global-declaration\",\"160\":\"29#enum-declaration\",\"161\":\"29#其它\",\"162\":\"29#代码\",\"163\":\"29#小结\",\"164\":\"30\",\"165\":\"30#ebnf-表示\",\"166\":\"30#解析函数的定义\",\"167\":\"30#函数参数与汇编代码\",\"168\":\"30#函数定义的解析\",\"169\":\"30#解析参数\",\"170\":\"30#函数体的解析\",\"171\":\"30#代码\",\"172\":\"30#小结\",\"173\":\"31\",\"174\":\"31#语句\",\"175\":\"31#if-语句\",\"176\":\"31#while-语句\",\"177\":\"31#return-语句\",\"178\":\"31#其它语句\",\"179\":\"31#代码\",\"180\":\"31#小结\",\"181\":\"32\",\"182\":\"32#运算符的优先级\",\"183\":\"32#一元运算符\",\"184\":\"32#常量\",\"185\":\"32#sizeof\",\"186\":\"32#变量与函数调用\",\"187\":\"32#强制转换\",\"188\":\"32#指针取值\",\"189\":\"32#取址操作\",\"190\":\"32#逻辑取反\",\"191\":\"32#按位取反\",\"192\":\"32#正负号\",\"193\":\"32#自增自减\",\"194\":\"32#二元运算符\",\"195\":\"32#赋值操作\",\"196\":\"32#三目运算符\",\"197\":\"32#逻辑运算符\",\"198\":\"32#数学运算符\",\"199\":\"32#自增自减-1\",\"200\":\"32#数组取值操作\",\"201\":\"32#代码\",\"202\":\"32#小结\",\"203\":\"33\",\"204\":\"33#虚拟机与目标代码\",\"205\":\"33#词法分析\",\"206\":\"33#语法分析\",\"207\":\"33#关于编代码\",\"208\":\"33#结语\",\"209\":\"34\",\"210\":\"35\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,5],\"2\":[1,3],\"3\":[1,2],\"4\":[1,4],\"5\":[1],\"6\":[6],\"7\":[9,21],\"8\":[2,49],\"9\":[2,12],\"10\":[null,null,2],\"11\":[null,null,2],\"12\":[9,20],\"13\":[1,7],\"14\":[1,24],\"15\":[1,5],\"16\":[1,95],\"17\":[1,37],\"18\":[1,12],\"19\":[1],\"20\":[1,15],\"21\":[1,29],\"22\":[1,49],\"23\":[1,6],\"24\":[3,5],\"25\":[1,19],\"26\":[null,null,1],\"27\":[null,null,1],\"28\":[3,7],\"29\":[6,20],\"30\":[3],\"31\":[3,48],\"32\":[4,40],\"33\":[2,4],\"34\":[1,5],\"35\":[4,6],\"36\":[1,14],\"37\":[1,5],\"38\":[2,21],\"39\":[2,32],\"40\":[1,51],\"41\":[null,null,1],\"42\":[null,null,1],\"43\":[2,15],\"44\":[1,32],\"45\":[2,27],\"46\":[4,9],\"47\":[1,23],\"48\":[1,2],\"49\":[1,12],\"50\":[1,35],\"51\":[1,38],\"52\":[1,5],\"53\":[1,27],\"54\":[1,17],\"55\":[1,19],\"56\":[1,2],\"57\":[1,10],\"58\":[1,5],\"59\":[1,18],\"60\":[1,9],\"61\":[1,10],\"62\":[1,17],\"63\":[1,7],\"64\":[1,2],\"65\":[1,12],\"66\":[1,37],\"67\":[1,38],\"68\":[1,5],\"69\":[1,29],\"70\":[1,17],\"71\":[1,17],\"72\":[1,42],\"73\":[2,18],\"74\":[1,7],\"75\":[1,15],\"76\":[3,13],\"77\":[3,4],\"78\":[3,4],\"79\":[3,5],\"80\":[3,5],\"81\":[3,4],\"82\":[null,null,1],\"83\":[null,null,1],\"84\":[1,4],\"85\":[1,2],\"86\":[1,34],\"87\":[2,8],\"88\":[null,null,1],\"89\":[9,21],\"90\":[1,100],\"91\":[1,71],\"92\":[1,179],\"93\":[1,41],\"94\":[1,3],\"95\":[1,1],\"96\":[1,8],\"97\":[1,29],\"98\":[1,10],\"99\":[null,null,1],\"100\":[null,null,1],\"101\":[1,2],\"102\":[1,45],\"103\":[5,46],\"104\":[1,28],\"105\":[3,56],\"106\":[1,40],\"107\":[1,14],\"108\":[1,45],\"109\":[5,55],\"110\":[1,27],\"111\":[1,130],\"112\":[1],\"113\":[7,64],\"114\":[1,9],\"115\":[1,125],\"116\":[1,58],\"117\":[1,58],\"118\":[1,119],\"119\":[1,24],\"120\":[1,27],\"121\":[2,24],\"122\":[1,127],\"123\":[1,35],\"124\":[1,25],\"125\":[1,36],\"126\":[1,62],\"127\":[1,51],\"128\":[1,68],\"129\":[1,63],\"130\":[1,35],\"131\":[5,54],\"132\":[1,35],\"133\":[1,26],\"134\":[1,18],\"135\":[1,86],\"136\":[1,42],\"137\":[1,12],\"138\":[1,28],\"139\":[1,135],\"140\":[1,61],\"141\":[1,63],\"142\":[1,61],\"143\":[1,56],\"144\":[1,81],\"145\":[1,24],\"146\":[1,18],\"147\":[5,48],\"148\":[1,11],\"149\":[1,33],\"150\":[1,37],\"151\":[1,37],\"152\":[1,23],\"153\":[1,70],\"154\":[1,16],\"155\":[5,55],\"156\":[2,44],\"157\":[1,7],\"158\":[2,20],\"159\":[3,130],\"160\":[3,51],\"161\":[1,25],\"162\":[1,22],\"163\":[1,13],\"164\":[5,51],\"165\":[2,21],\"166\":[1,37],\"167\":[1,56],\"168\":[1,67],\"169\":[1,77],\"170\":[1,93],\"171\":[1,24],\"172\":[1,18],\"173\":[5,49],\"174\":[1,28],\"175\":[2,62],\"176\":[2,32],\"177\":[2,22],\"178\":[1,21],\"179\":[1,21],\"180\":[1,16],\"181\":[5,76],\"182\":[1,95],\"183\":[1,15],\"184\":[1,60],\"185\":[1,45],\"186\":[1,151],\"187\":[1,36],\"188\":[1,42],\"189\":[1,47],\"190\":[1,28],\"191\":[1,31],\"192\":[1,33],\"193\":[1,62],\"194\":[1,76],\"195\":[1,57],\"196\":[1,39],\"197\":[1,33],\"198\":[1,101],\"199\":[1,39],\"200\":[1,50],\"201\":[1,60],\"202\":[1,17],\"203\":[5,46],\"204\":[1,18],\"205\":[1,13],\"206\":[1,32],\"207\":[1,24],\"208\":[1,3],\"209\":[1,3],\"210\":[3]},\"averageFieldLength\":[1.6673708621997603,33.38285092893238,0.4415548656394519],\"storedFields\":{\"0\":{\"h\":\"home\"},\"1\":{\"h\":\"介绍页\",\"t\":[\"一位热衷于探索全栈开发领域的技术爱好者，擅长将前端与后端技术无缝结合，致力于打造高效、优雅的解决方案。\"]},\"2\":{\"h\":\"随笔\",\"t\":[\"这里是所有个人感想、生活记录等非技术类文章。\"]},\"3\":{\"h\":\"项目\",\"t\":[\"这里是你参与或开发的项目介绍和进展。\"]},\"4\":{\"h\":\"资源\",\"t\":[\"这里是推荐的书籍、网站、工具等资源。\"]},\"5\":{\"h\":\"Qt\"},\"6\":{\"h\":\"Some Solutions to Questions about Qt\"},\"7\":{\"h\":\"The qt-5 isn't in Qt Maintenance tools\",\"t\":[\"Open the Qt Maintenance Tools.\",\"click the Archive in the Select-Component section.\",\"click the filter button and you can see the qt-5 in the list.\"]},\"8\":{\"h\":\"android studio换源\",\"t\":[\"国内镜像\",\"Android Studio下载gradle太慢可换源\",\"android.plugin version 下载错误查看\",\"修改 settings.gradle.kts\",\"pluginManagement { repositories { maven { url=uri (\\\"https://jitpack.io\\\") } maven { url=uri (\\\"https://maven.aliyun.com/repository/releases\\\") } // maven { url 'https://maven.aliyun.com/repository/jcenter' } maven { url=uri (\\\"https://maven.aliyun.com/repository/google\\\") } maven { url=uri (\\\"https://maven.aliyun.com/repository/central\\\") } maven { url=uri (\\\"https://maven.aliyun.com/repository/gradle-plugin\\\") } maven { url=uri (\\\"https://maven.aliyun.com/repository/public\\\") } google() mavenCentral() gradlePluginPortal() } } dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { maven { url=uri (\\\"https://jitpack.io\\\") } maven { url=uri (\\\"https://maven.aliyun.com/repository/releases\\\") } // maven { url 'https://maven.aliyun.com/repository/jcenter' } maven { url=uri (\\\"https://maven.aliyun.com/repository/google\\\") } maven { url=uri (\\\"https://maven.aliyun.com/repository/central\\\") } maven { url=uri (\\\"https://maven.aliyun.com/repository/gradle-plugin\\\") } maven { url=uri (\\\"https://maven.aliyun.com/repository/public\\\") } google() mavenCentral() } } \",\"gradle-wrapper.properties 换成对应的版本\",\"distributionUrl=https\\\\://mirrors.cloud.tencent.com/gradle/gradle-8.7-all.zip \"]},\"9\":{\"h\":\"CI/CD\",\"t\":[\"本地调试工具 act\",\"需要创建配置文件\",\"也可另外指定\",\"act --var-file \\\"./.act/.vars\\\" --secret-file \\\"./.act/.secrets\\\" --env-file \\\"./.act/.env\\\" {{other}} \"]},\"10\":{\"c\":[\"CI/CD\"]},\"11\":{\"c\":[\"CI/CD\"]},\"12\":{\"h\":\"docker + nginx + acme.sh 部署 vue/flask 项目\",\"t\":[\"本文将介绍如何使用 Docker、Nginx 和 acme.sh 部署一个 Vue 和 Flask 项目。我们将详细讲解环境配置、项目结构、Nginx 配置、Docker 配置以及如何升级到 HTTPS。\",\"提示\",\"需要先申请一个域名，本文是 bupt.online\"]},\"13\":{\"h\":\"环境\",\"t\":[\"Ubuntu\",\"Docker\",\"Docker-Compose\",\"acme.sh\",\"(python)\",\"nginx\"]},\"14\":{\"h\":\"项目结构\",\"t\":[\"./nginx ├── acme # 存放SSL证书 ├── conf.d │ ├── Automaton.conf │ ├── blog.conf ├── docker-compose.yml ├── DockerFile ├── logs # 存放日志 │ ├── access.log │ ├── Automaton │ ├── blog │ └── error.log ├── nginx.conf ./project # 要部署的（前端）项目 ├── Automaton └── blog \"]},\"15\":{\"h\":\"配置http服务\",\"t\":[\"在准备好前端项目及安装相应环境后，进行如下操作(部分路径以实际为准，进行修改)\"]},\"16\":{\"h\":\"配置nginx\",\"t\":[\"nginx.conf\",\"user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 4096; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \\\"$request\\\" ' '$status $body_bytes_sent \\\"$http_referer\\\" ' '\\\"$http_user_agent\\\" \\\"$http_x_forwarded_for\\\"'; # access_log /var/log/nginx/access.log main; access_log off; error_log /var/log/nginx/error.log warn; sendfile on; #tcp_nopush on; keepalive_timeout 65; # 定义DNS解析器 resolver 8.8.8.8 114.114.114.114 valid=300s; resolver_timeout 10s; # 增加请求头和Cookie的大小限制 client_header_buffer_size 16k; large_client_header_buffers 4 32k; include /etc/nginx/conf.d/*.conf; } \",\"Automaton.conf\",\"server { listen 80; server_name Automaton.bupt.online; location / { root /usr/share/nginx/html/Automaton; try_files $uri $uri/ =404; } access_log /var/log/nginx/Automaton/access.log; error_log /var/log/nginx/Automaton/error.log warn; } \",\"blog.conf\",\"server { listen 80; server_name bupt.online www.bupt.online; location / { root /usr/share/nginx/html/blog; try_files $uri $uri/ =404; # access_log /var/log/nginx/blog/access.log; error_log /var/log/nginx/blog/error.log warn; } location /Automaton { # 使用 proxy_pass 或 rewrite 重定向到Automaton.bupt.online 失败 alias /usr/share/nginx/html/Automaton/; try_files $uri $uri/ =404; # access_log /var/log/nginx/Automaton/access.log; error_log /var/log/nginx/Automaton/error.log warn; } } \"]},\"17\":{\"h\":\"配置docker\",\"t\":[\"DockerFile\",\"FROM nginx:latest COPY nginx.conf /etc/nginx/nginx.conf COPY conf.d /etc/nginx/conf.d \",\"docker-compose.yml\",\"services: nginx: build: context: . dockerfile: DockerFile ports: - \\\"80:80\\\" - \\\"443:443\\\" volumes: - ../project/blog:/usr/share/nginx/html/blog - ../project/Automaton:/usr/share/nginx/html/Automaton - ./logs:/var/log/nginx - ./conf.d:/etc/nginx/conf.d - ./acme:/etc/letsencrypt/live networks: - webnet environment: - TZ=Asia/Shanghai networks: webnet: \"]},\"18\":{\"h\":\"启动项目\",\"t\":[\"docker-compose up -d --build \",\"然后就能正常访问 http://bupt.online 及 http://automaton.bupt.online ， http://bupt.online/Automaton\"]},\"19\":{\"h\":\"升级为https\"},\"20\":{\"h\":\"申请证书\",\"t\":[\"进入acme.sh的安装目录(/root/.acme.sh)\",\"sudo su root acme.sh --issue -d bupt.online --nginx # Nginx acme.sh --issue -d Automaton.bupt.online --nginx # Nginx \"]},\"21\":{\"h\":\"安装证书\",\"t\":[\"这里将目录修改为目标目录\",\"# sudo su root # cd .acme.sh # use like below acme.sh --install-cert -d bupt.online \\\\ --cert-file /home/ubuntu/nginx/acme/bupt.online/cert.cer \\\\ --key-file /home/ubuntu/nginx/acme/bupt.online/privkey.key \\\\ --fullchain-file /home/ubuntu/nginx/acme/bupt.online/fullchain.cer \\\\ --reloadcmd \\\"cd /home/ubuntu/nginx && docker-compose up -d --build\\\" \"]},\"22\":{\"h\":\"修改配置\",\"t\":[\"blog.conf\",\"server { listen 80; server_name bupt.online www.bupt.online; return 301 https://$host$request_uri; } server { listen 443 ssl; server_name bupt.online; ssl_certificate /etc/letsencrypt/live/bupt.online/fullchain.cer; ssl_certificate_key /etc/letsencrypt/live/bupt.online/privkey.key; location / { root /usr/share/nginx/html/blog; try_files $uri $uri/ =404; # access_log /var/log/nginx/blog/access.log; error_log /var/log/nginx/blog/error.log warn; } location /Automaton { # 使用 proxy_pass 或 rewrite 重定向到Automaton.bupt.online 失败 alias /usr/share/nginx/html/Automaton/; try_files $uri $uri/ =404; # access_log /var/log/nginx/Automaton/access.log; error_log /var/log/nginx/Automaton/error.log warn; } } server { listen 443 ssl; server_name www.bupt.online; ssl_certificate /etc/letsencrypt/live/www.bupt.online/fullchain.cer; ssl_certificate_key /etc/letsencrypt/live/www.bupt.online/privkey.key; location / { root /usr/share/nginx/html/blog; try_files $uri $uri/ =404; # access_log /var/log/nginx/blog/access.log; error_log /var/log/nginx/blog/error.log warn; } location /Automaton { # 使用 proxy_pass 或 rewrite 重定向到Automaton.bupt.online 失败 alias /usr/share/nginx/html/Automaton/; try_files $uri $uri/ =404; # access_log /var/log/nginx/Automaton/access.log; error_log /var/log/nginx/Automaton/error.log warn; } } \",\"Automaton.conf\",\"server { listen 80; server_name Automaton.bupt.online; location / { return 301 https://$host$request_uri; } } server { listen 443 ssl; server_name Automaton.bupt.online; ssl_certificate /etc/letsencrypt/live/Automaton.bupt.online/fullchain.cer; ssl_certificate_key /etc/letsencrypt/live/Automaton.bupt.online/privkey.key; location / { root /usr/share/nginx/html/Automaton; try_files $uri $uri/ =404; } access_log /var/log/nginx/Automaton/access.log; error_log /var/log/nginx/Automaton/error.log warn; } \"]},\"23\":{\"h\":\"重启container\",\"t\":[\"docker-compose up -d --build \"]},\"24\":{\"h\":\"配置nginx反向代理，使flask支持 https\",\"t\":[\"#TODO - 添加flask+nginx配置\",\"[ ] 将卷的挂载目录改为由命令输入，而不是硬编码\"]},\"25\":{\"h\":\"参考资料\",\"t\":[\"Nginx Documentation\",\"Flask Documentation\",\"Reverse Proxy Guide\",\"SSL Certificates\",\"用acme.sh帮你免费且自动更新的HTTPS证书，省时又省力\",\"docker部署certbot与nginx来获取ssl证书添加https及自动更新\",\"使用docker acme申请、续订泛域名证书，并自动重载docker nginx\",\"Flask: 如何给Python Flask Web服务器添加HTTPS功能\"]},\"26\":{\"c\":[\"nginx\"]},\"27\":{\"c\":[\"部署\"]},\"28\":{\"h\":\"docker in wsl\",\"t\":[\"转载自：docker wsl2 踩坑记录 | 唯独你没懂，居然把路径藏在这里\"]},\"29\":{\"h\":\"docker wsl2 踩坑记录 | 唯独你没懂，居然把路径藏在这里\",\"t\":[\"最新推荐文章于 2024-06-30 17:39:23 发布\",\"TieWay59 最新推荐文章于 2024-06-30 17:39:23 发布\",\"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。\"]},\"30\":{\"h\":\"docker wsl2 踩坑记录\"},\"31\":{\"h\":\"docker-desktop 是什么\",\"t\":[\"Docker Desktop WSL 2 backend\",\"What is the docker-desktop-data distro\",\"简单地说，使用 docker-desktop-wsl 方式使用 docker，会给你创建两个 wsl distro。一个包含 docker/docker-desktop 服务本体，一个用于存储附属的数据（比如 images 等）。\",\"这中间就会导致 docker 文件的实际位置很奇怪，我还没有研究透。\",\"官方推荐的 win10 下的实践是：你的用 docker-desktop 设置把你主机 docker 集成到某个 distro(wsl 可以使用的 linux 发行版，我的是 Ubuntu)。然后在 win10 的开发环境去 remote 连接你的 Ubuntu。\",\"这样你就能用 win10 的图形界面，在 linux 的环境下，进行包含 docker 的开发过程了。\"]},\"32\":{\"h\":\"wsl 里的 docker 到底在哪里\",\"t\":[\"Docker volumes on Windows WSL2\",\"Locating data volumes in Docker Desktop (Windows)\",\"More generally /var/lib/docker/ maps to \\\\\\\\wsl$\\\\docker-desktop-data\\\\version-pack-data\\\\community\\\\docker\\\\.\",\"简单地说，打开 win10 文件管理器，输入：\",\"\\\\\\\\wsl$\\\\docker-desktop-data\\\\version-pack-data\\\\community\\\\docker\\\\ \",\"去 inspect 得到的/var/lib/docker/...都是在这个路径下的。\",\"https://www.cnblogs.com/kingsonfu/p/11578073.html\",\"文件目录：\\\\\\\\wsl$\\\\docker-desktop-data\\\\data\\\\docker\\\\containers\"]},\"33\":{\"h\":\"github 工作流程\",\"t\":[\"十分钟学会正确的github工作流，和开源作者们使用同一套流程\",\"相关信息\",\"TODO\"]},\"34\":{\"h\":\"技术\",\"t\":[\"这里是所有与技术相关的文章，包括编程、工具使用、技术分享等内容。\"]},\"35\":{\"h\":\"「泛型与 OI」modint\",\"t\":[\"在 OI 中，有大量的题目要求对一些数字取模，这便是本文写作的背景。\"]},\"36\":{\"h\":\"背景介绍\",\"t\":[\"这些题目要么是因为答案太大，不方便输出结果，例如许多计数 dp；要么是因为答案是浮点数，出题人不愿意写一个确定精度的 Special Judge，例如很多期望概率题；要么是因为这道题目直接考察了模的性质和运用，比如大量的 998244353 类的多项式题目。\"]},\"37\":{\"h\":\"过去的做法\",\"t\":[\"在这种要求之下，取模运算就成为了编程中不可缺少的一部分。下面以式子 为例介绍几种写法。\"]},\"38\":{\"h\":\"第一种 直接取模\",\"t\":[\"这种方法是直接取模，简单直接，清晰明了。\",\"constexpr int p=998244353; int ans=1ll*(((x+y)%p+z)%p)*u%p; \",\"但是这种方法有着严重的缺陷，一是容易忘记大括号，二是容易中间运算时搞错运算顺序、忘记取模，三是式子太长、括号太多、不易检验。\",\"因此，不推荐运用这种方法。\"]},\"39\":{\"h\":\"第二种 函数取模\",\"t\":[\"这种方法有效地解决了直接取模的忘记取模的漏洞。\",\"constexpr int p=998244353; int add(int a,int b){ return a+b>=p?a+b-p:a+b; } int sub(int a,int b){ return a<b?a-b+p:a-b; } int mul(int a,int b){ return 1ll*a*b%p; } int ans=mul(add(add(x,y),z),u); \",\"但是，这种写法的式子依旧太长，不易检验，并且如果编译器没有任何优化（现在不存在这种情况了）的话，大量的函数调用将会耗费不少的时间。并且如果要对多个模数取模，则需要写多个函数，显得代码冗长。\"]},\"40\":{\"h\":\"泛型编程\",\"t\":[\"考虑到函数取模的优点，我们不妨通过类的运算符重载来进一步优化 add 等函数。\",\"同时为了解决多个模数的问题，我们考虑泛型编程，将模数直接包含在类型中。\",\"template<typename T,const T p> class modint{ private: T v; public: modint(){} modint(const T& x){assert(0<=x&&x<p);v=x;} modint operator+(const modint& a)const{ return v+a.v>=p?v+a.v-p:v+a.v; } modint operator-(const modint& a)const{ return v<a.v?v-a.v+p:v-a.v; } modint operator*(const modint& a)const{ return 1ll*v*a.v%p; } T operator()(void)const{ return v; } }; modint<int,998244353> x(),y(),z(),u(); modint<int,998244353> ans=(x+y+z)*u; \",\"这样使用的时候，一方面减少了心智负担，不用操心运算时忘记取模；另一方面采取了常数更小的加减法操作，运算更快。\",\"唯一的缺点就是类型名难写，但是模数个数少的时候可以缩写，即写成：\",\"typedef modint<int,998244353> modInt1; \",\"这样就解决了类型名长的缺点。\"]},\"41\":{\"c\":[\"OI\"]},\"42\":{\"c\":[\"MODInt\"]},\"43\":{\"h\":\"Game Plugin\",\"t\":[\"This is the content of the game plugin post.\",\"BepInEx\",\"AssetStudioAssetStudio\",\"dnSpy\",\"Harmony\",\"UnityExplorer\",\"相关信息\",\"TODO\"]},\"44\":{\"h\":\"风格统一\",\"t\":[\"如何实现风格统一？ 可以使用*.editorconfig*文件来实现风格统一。\",\"安装EditorConfig插件 (部分IDE默认直接支持)\",\"在项目根目录下创建.editorconfig文件，并添加以下内容：\",\"root = true [*] indent_style = space tab_width = 2 end_of_line = lf charset = utf-8 trim_trailing_whitespace = true insert_final_newline = true \"]},\"45\":{\"h\":\"vscode plugin\",\"t\":[\"// TODO https://code.visualstudio.com/api/get-started/your-first-extension\",\"若activate function执行时间过长，会导致Activating extension 'undefined_publisher.kcodetime' failed: AggregateError., 从而启动失败\",\"若deactivate function执行时间超过5s, 会被强行终止，导致插件无法正常退出。\",\"关闭vscode 不会触发onDidCloseTextDocument事件\"]},\"46\":{\"h\":\"「算术公理系统 1」自然数\",\"t\":[\"假设存在一个算数系统的模型满足 Peano 公理，即假定 Peano 公理相容，在此承认次假设的基础之上，我们即可建立如今最常用的算术公理系统。自然数的定义则是构建此算术公理系统的第一步。\"]},\"47\":{\"h\":\"自然数的定义\",\"t\":[\"先介绍 Peano 公理，共有五条：\",\" 是自然数；\",\"任何自然数的后继存在且唯一，下文用 表示 的后继；\",\" 不是任何自然数的后继；\",\"不同的自然数后继不同；\",\" 是关于自然数 的一个命题，且满足两个条件：\",\" 是真命题；\",\"由 为真命题可以推理出 为真命题。\",\"则有，对于任意自然数 ， 为真命题。\",\"这样就定义了自然数，自然数这个新的数学对象因我们的假设而确立。\"]},\"48\":{\"h\":\"自然数的加法运算\",\"t\":[\"自然数中最重要的运算当然是加法。\"]},\"49\":{\"h\":\"加法的定义\",\"t\":[\"定义加法的运算规则：\",\"若 是自然数，则 的运算结果为 ，即 ；\",\"若 都是自然数，则 。\",\"下面我们需要证明对于任意两个自然数，都可以进行加法运算，也就是说，我们需要证明加法结果的存在性和唯一性。\"]},\"50\":{\"h\":\"加法结果的存在性\",\"t\":[\" 是任意自然数，记 表示 是否是自然数，即 是否存在。\",\" 是自然数，由加法运算规则 Ⅰ 有 ，进而有 是自然数； 即 得证。\",\" 和 是自然数，由 Peano 公理 Ⅱ 有 和 是自然数； 根据加法运算规则 Ⅱ 有 ，进有 是自然数； 综上所述，若 是自然数，则 也是自然数； 即由 为真命题可以推出 为真命题。\",\"由 的性质和 Peano 公理 Ⅴ 有，对于任意自然数 ， 成立，即 是自然数，再根据 的任意性，得出对于任意自然数 ， 都是自然数。\"]},\"51\":{\"h\":\"加法结果的唯一性\",\"t\":[\" 是任意自然数，记 表示 是否唯一，即 的结果是否唯一。\",\" 是自然数，由加法运算规则 Ⅰ 有 ，进而 是唯一的，就是 ； 即 得证。\",\" 是自然数， 是唯一的，由 Peano 公理 Ⅱ 有 是自然数且 唯一； 根据加法运算规则 Ⅱ 有 ，进有 唯一； 综上所述，若 唯一，则 也唯一； 即由 为真命题可以推出 为真命题。\",\"由 的性质和 Peano 公理 Ⅴ 有，对于任意自然数 ， 成立，即 唯一，再根据 的任意性，得出对于任意自然数 ， 都是唯一的。\"]},\"52\":{\"h\":\"加法的性质\",\"t\":[\"在明确证明了自然数加法运算的良好性质，即任意两个自然数都可以进行加法运算，且加法运算的结果存在且唯一之后，我们终于可以对自然数加法的性质进行进一步的探索。\"]},\"53\":{\"h\":\"加法交换律\",\"t\":[\"下面证明加法交换律，即对于任意自然数 ，有 。\",\"直接证明比较困难，考虑从加法运算的定义下手，即先证明加法的两条运算规则符合交换律。\",\"试证 ，首先有\",\"进而当 是自然数且 时有\",\"根据 Peano 公理 Ⅴ，得知 对任意自然数 成立。\",\"试证 ，首先有\",\"进而当 是自然数且 时有\",\"根据 Peano 公理 Ⅴ，得知 对任意自然数 成立，将其称为新的加法运算规则 Ⅱ。\",\"证明了加法运算规则的交换律之后，试证加法交换律 ，首先由加法运算规则 Ⅰ 有 ，进而当 是自然数且 时，有\",\"根据 Peano 公理 Ⅴ，得知 对任意自然数 成立，即加法交换律成立。\"]},\"54\":{\"h\":\"加法结合律\",\"t\":[\"下面证明加法结合律，即对于任意自然数 ，有 。\",\"首先当 时，有\",\"进而当 为自然数且 时有\",\"根据 Peano 公理 Ⅴ，得知 对任意自然数 成立，即加法结合律成立。\"]},\"55\":{\"h\":\"加法消去律\",\"t\":[\"下面证明加法消去律，即对于任意自然数 ，有 。\",\"试证 。\",\"首先当 时有\",\"进而当 为自然数且 时有\",\"即 ，根据 Peano 公理 Ⅴ，得知 对任意自然数 成立。\",\"试证 。\",\"首先当 时有\",\"进而当 为自然数且 时有\",\"即 ，根据 Peano 公理 Ⅴ，得知 对任意自然数 成立。\",\"综上所述，加法消去律 ，对任意自然数 成立。\"]},\"56\":{\"h\":\"自然数的序\",\"t\":[\"自然数的序为两个自然数的关系。\"]},\"57\":{\"h\":\"序的定义\",\"t\":[\"定义自然数的序即定义 当且仅当存在自然数 满足 。定义 当且仅当 且 。\",\"自然数的序是全序关系，它应该具有反对称性、传递性和完全性。\"]},\"58\":{\"h\":\"正自然数\",\"t\":[\"在考察序的性质之前，我们预先准备以方便证明。\",\"定义正自然数为非 自然数。\"]},\"59\":{\"h\":\"正自然数的性质\",\"t\":[\"正自然数与自然数相加为正自然数，即对于正自然数 ，其与自然数 的和 为正自然数。\",\"首先，当 时， 为正自然数。\",\"进而当 为自然数且 为正自然数时有 ，根据 Peano 公理 Ⅲ， 为正自然数，进而 为正自然数。\",\"根据 Peano 公理 Ⅴ，正自然数与自然数相加为正自然数。\"]},\"60\":{\"h\":\"序的反对称性\",\"t\":[\"若 且 ，则 。\",\"由 有 ，由 有 。\",\"因此 ，由加法消去律得到 ，根据正自然数的性质得出 ，因此 。\"]},\"61\":{\"h\":\"序的传递性\",\"t\":[\"若 且 ，则 。\",\"由 有 ，由 有 。\",\"根据加法结果的存在性得到 是自然数，根据加法结合律得出 ，进而 。\"]},\"62\":{\"h\":\"序的完全性\",\"t\":[\"任意两个自然数 都有序关系。\",\"对于 两个自然数，当 时有 所以 。\",\"当 为自然数时。若 ，则 ，因此 ；若 ，则 ，因此 ；若 ，则 。\",\"由 Peano 公理 Ⅴ 有任意两个自然数 都有序关系。\"]},\"63\":{\"h\":\"加法保序性\",\"t\":[\"若 ，则 。\",\"由 有 ，进而 因此 。\"]},\"64\":{\"h\":\"自然数的乘法运算\",\"t\":[\"自然数的乘法也十分重要。\"]},\"65\":{\"h\":\"乘法的定义\",\"t\":[\"定义乘法的运算规则：\",\"若 是自然数，则 的运算结果为 ，即 ；\",\"若 都是自然数，则 。\",\"下面我们需要证明对于任意两个自然数，都可以进行乘法运算，也就是说，我们需要证明乘法结果的存在性和唯一性。\"]},\"66\":{\"h\":\"乘法结果的存在性\",\"t\":[\" 是任意自然数，记 表示 是否是自然数，即 是否存在。\",\" 是自然数，由乘法运算规则 Ⅰ 有 ，进而有 是自然数； 即 得证。\",\" 和 是自然数，由加法结果的存在性有 存在； 根据乘法运算规则 Ⅱ 有 ，进有 是自然数； 综上所述，若 是自然数，则 也是自然数； 即由 为真命题可以推出 为真命题。\",\"由 的性质和 Peano 公理 Ⅴ 有，对于任意自然数 ， 成立，即 是自然数，再根据 的任意性，得出对于任意自然数 ， 都是自然数。\"]},\"67\":{\"h\":\"乘法结果的唯一性\",\"t\":[\" 是任意自然数，记 表示 是否唯一，即 的结果是否唯一。\",\" 是自然数，由乘法运算规则 Ⅰ 有 ，进而 是唯一的，就是 ； 即 得证。\",\" 是自然数， 是唯一的，由加法结果的唯一性有 唯一； 根据乘法运算规则 Ⅱ 有 ，进有 唯一； 综上所述，若 唯一，则 也唯一； 即由 为真命题可以推出 为真命题。\",\"由 的性质和 Peano 公理 Ⅴ 有，对于任意自然数 ， 成立，即 唯一，再根据 的任意性，得出对于任意自然数 ， 都是唯一的。\"]},\"68\":{\"h\":\"乘法的性质\",\"t\":[\"在明确证明了自然数乘法运算的良好性质，即任意两个自然数都可以进行乘法运算，且乘法运算的结果存在且唯一之后，我们终于可以对自然数乘法的性质进行进一步的探索。\"]},\"69\":{\"h\":\"乘法交换律\",\"t\":[\"下面证明乘法交换律，即对于任意自然数 ，有 。\",\"直接证明比较困难，考虑从乘法运算的定义下手，即先证明乘法的两条运算规则符合交换律。\",\"试证 。\",\"首先有 。\",\"进而当 是自然数且 时有\",\"根据 Peano 公理 Ⅴ，得知 对任意自然数 成立。\",\"试证 。\",\"首先 时有\",\"进而当 是自然数且 时有\",\"根据 Peano 公理 Ⅴ，得知 对任意自然数 成立，将其称为新的乘法运算规则 Ⅱ。\",\"证明了乘法运算规则的交换律之后，试证乘法交换律 ，首先当 时由乘法运算规则 Ⅰ 有 。\",\"进而当 是自然数且 时，有\",\"根据 Peano 公理 Ⅴ，得知 对任意自然数 成立，即乘法交换律成立。\"]},\"70\":{\"h\":\"乘法分配律\",\"t\":[\"下面证明乘法分配律，即对于任意自然数 ，有 。\",\"首先当 时，，进而当 为自然数且 时有\",\"根据 Peano 公理 Ⅴ，得知 对任意自然数 成立，即乘法分配律成立。\"]},\"71\":{\"h\":\"乘法结合律\",\"t\":[\"下面证明乘法结合律，即对于任意自然数 ，有 。\",\"首先当 时，有 。\",\"进而当 为自然数且 时有\",\"根据 Peano 公理 Ⅴ，得知 对任意自然数 成立，即乘法结合律成立。\"]},\"72\":{\"h\":\"乘法消去律\",\"t\":[\"下面证明乘法消去律，即对于任意自然数 和 ，有 。\",\"试证 。\",\"首先当 时有\",\"进而当 为自然数且 时有\",\"即 ，根据 Peano 公理 Ⅴ，得知 对任意自然数 成立。\",\"试证 ，采用反证法，假设 ，则由加法运算规则 Ⅱ 可知 或 ，其中 ，不妨设 。\",\"由 Peano 公理 Ⅲ 有 。\",\"由 Peano 公理 Ⅲ、Ⅳ 有，任意非零自然数 都有唯一的数 满足 ，不妨记作 。\",\"若有 ，则有\",\"上述等式表明 是 的后继，这违背了 Peano 公理 Ⅲ，由此知道假设不成立，即 。\",\"综上所述，乘法消去律 ，对任意自然数 成立。\"]},\"73\":{\"h\":\"Peano 公理的合理性\",\"t\":[\"通过上述步骤，我们成功地由 Peano 公理构建出了一个自然数代数系统。但 Peano 公理自身任有待研究。从上述步骤中我们看出 Peano 公理每一条公理都被使用过，少了任何一条都不足以构建出上述的自然数系统，这究竟是为什么呢？\",\"下面我将阐述为什么每条公理都是必须的，通过举反例的方式。研究 Peano 公理自然不能从 Peano 公理系统内出发，我们将借助另一个公理系统——图论。\"]},\"74\":{\"h\":\"乘法保序性\",\"t\":[\"若 ，则 。\",\"由 有 ，进而 因此 。\"]},\"75\":{\"h\":\"乘法消去保序性\",\"t\":[\"若 ，则 。\",\"采用反证法，假设 ，则存在正自然数 满足 ，有\",\"由此有 ，根据序的反对称性有 ，根据乘法消去律有 ，这与 的假设矛盾，因此假设不成立，即证明了乘法消去的保序性。\"]},\"76\":{\"h\":\"用图论阐述 Peano 系统\",\"t\":[\"自然数与有向图 同构，这个图满足如下性质：\",\"存在点 ，即 ；\",\"所有点的出度为 ，即 ；\",\"点 入度为 ，即 ；\",\"任意点的入度小于等于 ，即 ；\",\"存在从 到任意点的路径，即 。\",\"下面我们试着通过删除公理的方法来寻找反例。\"]},\"77\":{\"h\":\"Peano 公理 Ⅰ\",\"t\":[\"若去除，则允许不存在 ，可以构造出空集自然数系统。\"]},\"78\":{\"h\":\"Peano 公理 Ⅱ\",\"t\":[\"若去除，则对点的出度无规定，可以构造出菊花图自然数系统。\"]},\"79\":{\"h\":\"Peano 公理 Ⅲ\",\"t\":[\"若去除，则对 的入度无规定，可以构造出环状自然数系统。\"]},\"80\":{\"h\":\"Peano 公理 Ⅳ\",\"t\":[\"若去除，则对一个数可以是多个数的后继，可以构造出 状自然数系统。\"]},\"81\":{\"h\":\"Peano 公理 Ⅴ\",\"t\":[\"若去除，则对连通性无要求，可以构造出分段状自然数系统。\"]},\"82\":{\"c\":[\"数学\"]},\"83\":{\"c\":[\"公理系统\"]},\"84\":{\"h\":\"使用capacitor和ionic将vue项目迁移到mobile端\",\"t\":[\"当我们写完了vue项目后，想做一个一样的移动app，此时我们可以使用ionic无缝将其迁移到移动端。\"]},\"85\":{\"h\":\"安装\",\"t\":[\"Capacitor\",\"ionic\"]},\"86\":{\"h\":\"tips\",\"t\":[\"deploy\",\"每次执行更新你的 Web 目录的构建（例如 ionic build）时（默认：build)，你需要将这些更改复制到你的原生项目中：\",\"ionic cap copy\",\"注意：更新代码的原生部分（例如添加新插件）后，使用 sync 命令：\",\"ionic cap sync \",\"相关信息\",\"vscode中可以使用\\\"ionic\\\"插件\",\"默认不支持HTTP\",\"const config: CapacitorConfig = { plugins:{ CapacitorHttp:{ enabled:true, } }, android:{ allowMixedContent: true, } }; \"]},\"87\":{\"h\":\"bug 记录\",\"t\":[\"使用 vscode ionic打包后的相对路径不正确， 手动修改后可正常运行\",\"重要\",\"用Android Studio时不能打开360手机助手，会和ADB冲突\"]},\"88\":{\"c\":[\"mobile\"]},\"89\":{\"h\":\"并发异步编程之争：协程(asyncio)到底需不需要加锁？(线程/协程安全/挂起/主动切换)Python3\",\"t\":[\"原文转载自「刘悦的技术博客」https://v3u.cn/a_id_208\",\"协程与线程向来焦孟不离，但事实上是，线程更被我们所熟知，在Python编程领域，单核同时间内只能有一个线程运行，这并不是什么缺陷，这实际上是符合客观逻辑的，单核处理器本来就没法同时处理两件事情，要同时进行多件事情本来就需要正在运行的让出处理器，然后才能去处理另一件事情，左手画方右手画圆在现实中本来就不成立，只不过这个让出的过程是线程调度器主动抢占的。\"]},\"90\":{\"h\":\"线程安全\",\"t\":[\"系统的线程调度器是假设不同的线程是毫无关系的，所以它平均地分配时间片让处理器一视同仁，雨露均沾。但是Python受限于GIL全局解释器锁，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局解释器锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使多个线程跑在8核处理上，也只能用到1个核。\",\"但其实，这并不是事情的全貌，就算只能用单核处理任务，多个线程之前也并不是完全独立的，它们会操作同一个资源。于是，大家又发明了同步锁，使得一段时间内只有一个线程可以操作这个资源，其他线程只能等待：\",\"import threading balance = 0 def change_it_without_lock(n): global balance # 不加锁的话 最后的值不是0 # 线程共享数据危险在于 多个线程同时改同一个变量 # 如果每个线程按顺序执行，那么值会是0， 但是线程时系统调度，又不确定性，交替进行 # 没锁的话，同时修改变量 # 所以加锁是为了同时只有一个线程再修改，别的线程表一定不能改 for i in range(1000000): balance = balance + n balance = balance - n def change_it_with_lock(n): global balance if lock.acquire(): try: for i in range(1000000): balance = balance + n balance = balance - n # 这里的finally 防止中途出错了，也能释放锁 finally: lock.release() threads = [ threading.Thread(target=change_it_with_lock, args=(8, )), threading.Thread(target=change_it_with_lock, args=(10, )) ] lock = threading.Lock() [t.start() for t in threads] [t.join() for t in threads] print(balance) \",\"这种异步编程方式被广大开发者所认可，线程并不安全，线程操作共享资源需要加锁。然而人们很快发现，这种处理方式是在画蛇添足，处理器本来同一时间就只能有一个线程在运行。是线程调度器抢占划分时间片给其他线程跑，而现在，多了把锁，其他线程又说我拿不到锁，我得拿到锁才能操作。\",\"就像以前的公共电话亭，本来就只能一个人打电话，现在电话亭上加了把锁，还是只能一个人打电话，而有没有锁，有什么区别呢？所以，问题到底出在哪儿？\",\"事实上，在所有线程相互独立且不会操作同一资源的模式下，抢占式的线程调度器是非常不错的选择，因为它可以保证所有的线程都可以被分到时间片不被垃圾代码所拖累。而如果操作同一资源，抢占式的线程就不那么让人愉快了。\"]},\"91\":{\"h\":\"协程\",\"t\":[\"过了一段时间，人们发现经常需要异步操作共享资源的情况下，主动让出时间片的协程模式比线程抢占式分配的效率要好，也更简单。\",\"从实际开发角度看，与线程相比，这种主动让出型的调度方式更为高效。一方面，它让调用者自己来决定什么时候让出，比操作系统的抢占式调度所需要的时间代价要小很多。后者为了能恢复现场会在切换线程时保存相当多的状态，并且会非常频繁地进行切换。另一方面，协程本身可以做成用户态，每个协程的体积比线程要小得多，因此一个进程可以容纳数量相当可观的协程任务。\",\"import asyncio balance = 0 async def change_it_without_lock(n): global balance balance = balance + n balance = balance - n loop = asyncio.get_event_loop() res = loop.run_until_complete( asyncio.gather(change_it_without_lock(10), change_it_without_lock(8), change_it_without_lock(2), change_it_without_lock(7))) print(balance) \",\"从代码结构上看，协程保证了编写过程中的思维连贯性，使得函数（闭包）体本身就无缝保持了程序状态。逻辑紧凑，可读性高，不易写出错的代码，可调试性强。\",\"但归根结底，单核处理器还是同时间只能做一件事，所以同一时间点还是只能有一个协程任务运行，它和线程的最主要差别就是，协程是主动让出使用权，而线程是抢占使用权，即所谓的，协程是用户态，线程是系统态。\",\"img\",\"同时，如图所示，协程本身就是单线程的，即不会触发系统的全局解释器锁(GIL)，同时也不需要系统的线程调度器参与抢占式的调度，避免了多线程的上下文切换，所以它的性能要比多线程好。\"]},\"92\":{\"h\":\"协程安全\",\"t\":[\"回到并发竞争带来的安全问题上，既然同一时间只能有一个协程任务运行，并且协程切换并不是系统态抢占式，那么协程一定是安全的：\",\"import asyncio balance = 0 async def change_it_without_lock(n): global balance balance = balance + n balance = balance - n print(balance) loop = asyncio.get_event_loop() res = loop.run_until_complete( asyncio.gather(change_it_without_lock(10), change_it_without_lock(8), change_it_without_lock(2), change_it_without_lock(7))) print(balance) \",\"运行结果：\",\"0 0 0 0 0 liuyue:as-master liuyue$ \",\"看起来是这样的，无论是执行过程中，还是最后执行结果，都保证了其状态的一致性。\",\"于是，协程操作共享变量不需要加锁的结论开始在坊间流传。\",\"毫无疑问，谁主张，谁举证，上面的代码也充分说明了这个结论的正确性，然而我们都忽略了一个客观事实，那就是代码中没有“主动让出使用权”的操作，所谓主动让出使用权，即用户主动触发协程切换，那到底怎么主动让出使用权？使用 await 关键字。\",\"await 是 Python 3.5版本开始引入了新的关键字，即Python3.4版本的yield from，它能做什么？它可以在协程内部用await调用另一个协程实现异步操作，或者说的更简单一点，它可以挂起当前协程任务，去手动异步执行另一个协程，这就是主动让出“使用权”：\",\"async def hello(): print(\\\"Hello world!\\\") r = await asyncio.sleep(1) print(\\\"Hello again!\\\") \",\"当我们执行第一句代码print(\\\"Hello world!\\\")之后，使用await关键字让出使用权，也可以理解为把程序“暂时”挂起，此时使用权让出以后，别的协程就可以进行执行，随后当我们让出使用权1秒之后，当别的协程任务执行完毕，又或者别的协程任务也“主动”让出了使用权，协程又可以切回来，继续执行我们当前的任务，也就是第二行代码print(\\\"Hello again!\\\")。\",\"了解了协程如何主动切换，让我们继续之前的逻辑：\",\"import asyncio balance = 0 async def change_it_without_lock(n): global balance balance = balance + n await asyncio.sleep(1) balance = balance - n print(balance) loop = asyncio.get_event_loop() res = loop.run_until_complete( asyncio.gather(change_it_without_lock(10), change_it_without_lock(8), change_it_without_lock(2), change_it_without_lock(7))) print(balance) \",\"逻辑有了些许修改，当我对全局变量balance进行加法运算后，主动释放使用权，让别的协程运行，随后立刻切换回来，再进行减法运算，如此往复，同时开启四个协程任务，让我们来看一下代码运行结果：\",\"17 9 7 0 0 liuyue:mytornado liuyue$ \",\"可以看到，协程运行过程中，并没有保证“状态一致”，也就是一旦通过await关键字切换协程，变量的状态并不会进行同步，从而导致执行过程中变量状态的“混乱状态”，但是所有协程执行完毕后，变量balance的最终结果是0，意味着协程操作变量的最终一致性是可以保证的。\",\"为了对比，我们再用多线程试一下同样的逻辑：\",\"import threading import time balance = 0 def change_it_without_lock(n): global balance for i in range(1000000): balance = balance + n balance = balance - n print(balance) threads = [ threading.Thread(target=change_it_without_lock, args=(8, )), threading.Thread(target=change_it_without_lock, args=(10, )), threading.Thread(target=change_it_without_lock, args=(10, )), threading.Thread(target=change_it_without_lock, args=(8, )) ] [t.start() for t in threads] [t.join() for t in threads] print(balance) \",\"多线程逻辑执行结果：\",\"liuyue:mytornado liuyue$ python3 \\\"/Users/liuyue/wodfan/work/mytornado/test.py\\\" 28 18 10 0 8 \",\"可以看到，多线程在未加锁的情况下，连最终一致性也无法保证，因为线程是系统态切换，虽然同时只能有一个线程执行，但切换过程是争抢的，也就会导致写操作被原子性覆盖，而协程虽然在手动切换过程中也无法保证状态一致，但是可以保证最终一致性呢？因为协程是用户态，切换过程是协作的，所以写操作不会被争抢覆盖，会被顺序执行，所以肯定可以保证最终一致性。\",\"协程在工作状态中，主动切换了使用权，而我们又想在执行过程中保证共享数据的强一致性，该怎么办？毫无疑问，还是只能加锁：\",\"import asyncio balance = 0 async def change_it_with_lock(n): async with lock: global balance balance = balance + n await asyncio.sleep(1) balance = balance - n print(balance) lock = asyncio.Lock() loop = asyncio.get_event_loop() res = loop.run_until_complete( asyncio.gather(change_it_with_lock(10), change_it_with_lock(8), change_it_with_lock(2), change_it_with_lock(7))) print(balance) \",\"协程加锁执行后结果：\",\"liuyue:mytornado liuyue$ python3 \\\"/Users/liuyue/wodfan/work/mytornado/test.py\\\" 0 0 0 0 0 \",\"是的，无论是结果，还是过程中，都保持了其一致性，但是我们也付出了相应的代价，那就是任务又回到了线性同步执行，再也没有异步的加持了。话说回来，世界上的事情本来就是这样，本来就没有两全其美的解决方案，又要共享状态，又想多协程，还想变量安全，这可能吗？\"]},\"93\":{\"h\":\"协程是否需要加锁\",\"t\":[\"结论当然就是看使用场景，如果协程在操作共享变量的过程中，没有主动放弃执行权(await)，也就是没有切换挂起状态，那就不需要加锁，执行过程本身就是安全的；可是如果在执行事务逻辑块中主动放弃执行权了，会分两种情况，如果在逻辑执行过程中我们需要判断变量状态，或者执行过程中要根据变量状态进行一些下游操作，则必须加锁，如果我们不关注执行过程中的状态，只关注最终结果一致性，则不需要加锁。是的，抛开剂量谈毒性，是不客观的，给一个健康的人注射吗啡是犯罪，但是给一个垂死的人注射吗啡，那就是最大的道德，所以说，道德不是空泛的，脱离对象孤立存在的，同理，抛开场景谈逻辑，也是不客观的，协程也不是虚空的，脱离具体场景孤立存在的，我们应该养成具体问题具体分析的辩证唯物思想，只有掌握了辩证的矛盾思维才能更全面更灵活的看待问题，才能透过现象，把握本质。\",\"原文转载自「刘悦的技术博客」 https://v3u.cn/a_id_208\"]},\"94\":{\"h\":\"协程\",\"t\":[\"文档\",\"重要\",\"TODO\"]},\"95\":{\"h\":\"Slidev\",\"t\":[\"复杂演示推荐\"]},\"96\":{\"h\":\"缺点\",\"t\":[\"不支持导出pptx\",\"https://cn.sli.dev/guide\",\"简单PPT,且需要导出为pptx推荐\"]},\"97\":{\"h\":\"缺点\",\"t\":[\"不支持动画\",\"https://sspai.com/post/55718\",\"https://segmentfault.com/a/1190000040806239\",\"⚠️注意事项\\n如果你的 VS Code 安装了 Markdown 渲染插件 Markdown Preview Enhanced，需要先将这个插件「禁用」或是「卸载」，转而使用 VS Code 后来集成的 Markdown 预览功能，才能正常看到渲染后的 PPT 页面。\"]},\"98\":{\"h\":\"闭包实现类\",\"t\":[\"你是否曾经想过，不用类也能封装数据和方法？这篇文章将带你走进闭包的奇妙世界，展示如何用闭包来实现这一点。通过一个有趣的代码示例，你将看到闭包是如何捕获变量并提供类似类的功能的。准备好了吗？让我们开始这段有趣的旅程吧！\",\"alt text\"]},\"99\":{\"c\":[\"OI\"]},\"100\":{\"c\":[\"MODInt\"]},\"101\":{\"h\":\"教程\",\"t\":[\"这里是所有详细的教程和指南。\"]},\"102\":{\"h\":\"Typora激活教程\",\"t\":[\"Typora 是一款简洁高效的 Markdown 编辑器，支持实时预览和多种导出格式，适用于编写笔记、文档和博客等。\",\"Typora 官网\",\"Typora 中文官网\",\"工具下载：百度网盘，密码：dcqe\",\"一路点击“下一步”进行安装。将下载的工具解压后得到的两个 exe 文件（license-gen.exe 和 node_inject.exe）复制到 Typora 安装目录下（默认为 C:\\\\Program Files\\\\Typora\\\\）。\",\"以管理员身份在 Typora 安装路径打开 PowerShell。\",\"输入 node_inject.exe 并回车，等待提示 \\\"done!\\\"。\",\"输入 license-gen.exe 并回车，等待显示序列号。\",\"启动 Typora，输入任意邮箱和刚才生成的序列号到激活窗口，并点击激活。\",\"通过上述步骤，您可以免费安装并使用 Typora，但如有条件还请支持正版。\"]},\"103\":{\"h\":\"手把手教你构建 C 语言编译器（0）- 前言\",\"t\":[\"本文转载自 手把手教你构建 C 语言编译器（0）- 前言，原作者 三点水，原文链接：原文链接，如有侵权，请联系删除。\",\"转载工具:devtool、helloworld\",\"“手把手教你构建 C 语言编译器” 这一系列教程将带你从头编写一个 C 语言的编译器。希望通过这个系列，我们能对编译器的构建有一定的了解，同时，我们也将构建出一个能用的 C 语言编译器，尽管有许多语法并不支持。\",\"手把手教你构建 C 语言编译器系列共有10个部分：\",\"手把手教你构建 C 语言编译器（0）——前言\",\"手把手教你构建 C 语言编译器（1）——设计\",\"手把手教你构建 C 语言编译器（2）——虚拟机\",\"手把手教你构建 C 语言编译器（3）——词法分析器\",\"手把手教你构建 C 语言编译器（4）——递归下降\",\"手把手教你构建 C 语言编译器（5）——变量定义\",\"手把手教你构建 C 语言编译器（6）——函数定义\",\"手把手教你构建 C 语言编译器（7）——语句\",\"手把手教你构建 C 语言编译器（8）——表达式\",\"手把手教你构建 C 语言编译器（9）——总结\",\"在开始进入正题之前，本篇是一些闲聊，谈谈这个系列的初衷。如果你急切地想进入正篇，请跳过本章。\"]},\"104\":{\"h\":\"为什么要学编译原理\",\"t\":[\"如果要我说计算机专业最重要的三门课，我会说是《数据结构》、《算法》和《编译原理》。在我看来，能不能理解“递归”像是程序员的第一道门槛，而会不会写编译器则是第二道。\",\"（当然，并不是说是没写过编译器就不是好程序员，只能说它是一个相当大的挑战吧）\",\"以前人们会说，学习了编译原理，你就能写出更加高效的代码，但随着计算机性能的提升，代码是否高效显得就不那么重要了。那么为什么要学习编译原理呢？\",\"原因只有一个：装B。\",\"好吧，也许现在还想学习编译原理的人只可能是因为兴趣了。一方面想了解它的工作原理；另一方面希望挑战一下自己，看看自己能走多远。\"]},\"105\":{\"h\":\"理论很复杂，实现也很复杂？\",\"t\":[\"我对编译器一直心存敬佩。所以当学校开《编译原理》的课程后，我是抱着满腔热情去上课的，但是两节课后我就放弃了。原因是太复杂了，听不懂。\",\"一般编译原理的课程会说一些：\",\"如何表示语法（BNF什么的）\",\"词法分析，用什么有穷自动机和无穷自动机\",\"语法分析，递归下降法，什么 LL(k)，LALR 分析。\",\"中间代码的表示\",\"代码的生成\",\"代码优化\",\"我相信绝大多数（98％）的学生顶多学到语法分析就结束了。并且最重要的是，学了这么多也没用！依旧帮助不了我们学习编译器！这其中最主要的原因是《编译原理》试图教会我们的是如何构造“编译器生成器”，即构造一个工具，根据文法来生成编译器（如 lex/yacc）等等。\",\"这些理论试图教会我们如何用通用的方法来自动解决问题，它们有很强的实际意义，只是对于一般的学生或程序员来说，它们过于强大，内容过于复杂。如果你尝试阅读 lex/yacc （或 flex/bison）的代码，就会发现太可怕了。\",\"然而如果你能跟我一样，真正来实现一个简单的编译器，那么你会发现，比起可怕的《编译原理》，这点复杂度还是不算什么的（因为好多理论根本用不上）。\"]},\"106\":{\"h\":\"项目的初衷\",\"t\":[\"有一次在 Github 上看到了一个项目（当时很火的），名叫 c4，号称用 4 个函数来实现了一个小的 C 语言编译器。它最让我震惊的是能够自举，即能自己编译自己。并且它用很少的代码就完成了一个功能相当完善的 C 语言编译器。\",\"一般的编译器相关的教程要么就十分简单（如实现四则运算），要么就是借助了自动生成的工具（如 flex/bison）。而 c4 的代码完全是手工实现的，不用外部工具。可惜的是它的代码初衷是代码最小化，所以写得很乱，很难懂。所以本项目的主要目的：\",\"实现一个功能完善的 C 语言编译器\",\"通过教程来说明这个过程。\",\"c4 大致500+行。重写的代码历时一周，总共代码加注释1400行。项目地址: Write a C Interpreter。\",\"声明：本项目中的代码逻辑绝大多数取自 c4 ，但确为自己重写。\"]},\"107\":{\"h\":\"做好心理准备\",\"t\":[\"在写编译器的时候会遇到两个主要问题：\",\"繁琐，会有许多相似的代码，写起来很无聊。\",\"难以调试，一方面没有很好的测试用例，另一方面需要对照生成的代码来调试（遇到的时候就知道了）。\",\"所以我希望你有足够的耐心和时间来学习，相信当你真正完成的时候会像我一样，十分有成就感。\",\"PS. 第一篇完全没有正题相关的内容也是希望你能有所心理准备再开始学习。\"]},\"108\":{\"h\":\"参考资料\",\"t\":[\"最后想介绍几个资料：\",\"Let’s Build a Compiler 很好的初学者教程，英文的。\",\"Lemon Parser Generator，一个语法分析器生成器，对照《编译原理》观看效果更佳。\",\"由于本人水平一般，文章、代码难免会有错误，敬请批评指正！\",\"最后祝你学得愉快。\",\"这篇博客并没有使用诸如 flex、bison 等工具来编写 token 和文法的定义，因而灵活性较差。相反，它通过定义自己的指令集并支持该指令集的虚拟机来模拟编译的部分过程，具有一定的参考价值。不过，我仍然认为通过定义 token 和文法并编写解析算法（如 regex、LL(k) 等）可能会更具普适性。\",\"相关信息\",\"不过据说c、cpp、java这些成熟的语言都是手动实现的？还没仔细了解过。\\nTODO\"]},\"109\":{\"h\":\"手把手教你构建 C 语言编译器（1）- 设计\",\"t\":[\"本文转自 https://lotabout.me/2015/write-a-C-interpreter-1/，如有侵权，请联系删除。\",\"Table of Contents\",\"1. 编译器的构建流程\",\"2. 编译器框架\",\"这是“手把手教你构建 C 语言编译器”系列的第二篇，我们要从整体上讲解如何设计我们的 C 语言编译器。\",\"手把手教你构建 C 语言编译器系列共有10个部分：\",\"手把手教你构建 C 语言编译器（0）——前言\",\"手把手教你构建 C 语言编译器（1）——设计\",\"手把手教你构建 C 语言编译器（2）——虚拟机\",\"手把手教你构建 C 语言编译器（3）——词法分析器\",\"手把手教你构建 C 语言编译器（4）——递归下降\",\"手把手教你构建 C 语言编译器（5）——变量定义\",\"手把手教你构建 C 语言编译器（6）——函数定义\",\"手把手教你构建 C 语言编译器（7）——语句\",\"手把手教你构建 C 语言编译器（8）——表达式\",\"手把手教你构建 C 语言编译器（9）——总结\",\"首先要说明的是，虽然标题是编译器，但实际上我们构建的是 C 语言的解释器，这意味着我们可以像运行脚本一样去运行 C 语言的源代码文件。这么做的理由有两点：\",\"解释器与编译器仅在代码生成阶段有区别，而其它方面如词法分析、语法分析是一样的。\",\"解释器需要我们实现自己的虚拟机与指令集，而这部分能帮助我们了解计算机的工作原理。\"]},\"110\":{\"h\":\"编译器的构建流程\",\"t\":[\"一般而言，编译器的编写分为 3 个步骤：\",\"词法分析器，用于将字符串转化成内部的表示结构。\",\"语法分析器，将词法分析得到的标记流（token）生成一棵语法树。\",\"目标代码的生成，将语法树转化成目标代码。\",\"已经有许多工具能帮助我们处理阶段1和2，如 flex 用于词法分析，bison 用于语法分析。只是它们的功能都过于强大，屏蔽了许多实现上的细节，对于学习构建编译器帮助不大。所以我们要完全手写这些功能。\",\"所以我们会依照以下步骤来构建我们的编译器：\",\"构建我们自己的虚拟机以及指令集。这后生成的目标代码便是我们的指令集。\",\"构建我们的词法分析器\",\"构建语法分析器\"]},\"111\":{\"h\":\"编译器框架\",\"t\":[\"我们的编译器主要包括 4 个函数：\",\"next() 用于词法分析，获取下一个标记，它将自动忽略空白字符。\",\"program() 语法分析的入口，分析整个 C 语言程序。\",\"expression(level) 用于解析一个表达式。\",\"eval() 虚拟机的入口，用于解释目标代码。\",\"这里有一个单独用于解析“表达式”的函数 expression 是因为表达式在语法分析中相对独立并且比较复杂，所以我们将它单独作为一个模块（函数）。下面是相应的源代码：\",\"#include <stdio.h>#include <stdlib.h>#include <memory.h>#include <string.h>int token; // current tokenchar *src, *old_src; // pointer to source code string;int poolsize; // default size of text/data/stackint line; // line numbervoid next() { token = *src++; return;}void expression(int level) { // do nothing}void program() { next(); // get next token while (token > 0) { printf(\\\"token is: %c\\\\n\\\", token); next(); }}int eval() { // do nothing yet return 0;}int main(int argc, char **argv){ int i, fd; argc--; argv++; poolsize = 256 * 1024; // arbitrary size line = 1; if ((fd = open(*argv, 0)) < 0) { printf(\\\"could not open(%s)\\\\n\\\", *argv); return -1; } if (!(src = old_src = malloc(poolsize))) { printf(\\\"could not malloc(%d) for source area\\\\n\\\", poolsize); return -1; } // read the source file if ((i = read(fd, src, poolsize-1)) <= 0) { printf(\\\"read() returned %d\\\\n\\\", i); return -1; } src[i] = 0; // add EOF character close(fd); program(); return eval();}\",\"上面的代码看上去挺复杂，但其实内容不多。它的流程为：读取一个文件（内容为 C 语言代码），逐个读取文件中的字符，并输出。这里需要的是注意每个函数的作用，后面的文章中，我们将逐个填充每个函数的功能，最终构建起我们的编译器。\",\"本节的代码可以在 Github 上下载，也可以直接 clone\",\"git clone -b step-0 https://github.com/lotabout/write-a-C-interpreter\",\"这样我们就有了一个最简单的编译器：什么都不干的编译器，下一章中，我们将实现其中的eval函数，即我们自己的虚拟机。\"]},\"112\":{\"h\":\"转载声明\"},\"113\":{\"h\":\"title: \\\"手把手教你构建 C 语言编译器（0）- 前言\\\"\",\"t\":[\"本文转自 https://lotabout.me/2015/write-a-C-interpreter-2/，如有侵权，请联系删除。\",\"Table of Contents\",\"1. 计算机的内部工作原理\",\"1.1. 内存\",\"1.2. 寄存器\",\"2. 指令集\",\"2.1. MOV\",\"2.2. PUSH\",\"2.3. JMP\",\"2.4. JZ/JNZ\",\"2.5. 子函数调用\",\"2.6. ENT\",\"2.7. ADJ\",\"2.8. LEV\",\"2.9. LEA\",\"2.10. 运算符指令\",\"2.11. 内置函数\",\"3. 测试\",\"4. 小结\",\"这是“手把手教你构建 C 语言编译器”系列的第三篇，本章我们要构建一台虚拟的电脑，设计我们自己的指令集，运行我们的指令集，说得通俗一点就是自己实现一套汇编语言。它们将作为我们的编译器最终输出的目标代码。\",\"手把手教你构建 C 语言编译器系列共有10个部分：\",\"手把手教你构建 C 语言编译器（0）——前言\",\"手把手教你构建 C 语言编译器（1）——设计\",\"手把手教你构建 C 语言编译器（2）——虚拟机\",\"手把手教你构建 C 语言编译器（3）——词法分析器\",\"手把手教你构建 C 语言编译器（4）——递归下降\",\"手把手教你构建 C 语言编译器（5）——变量定义\",\"手把手教你构建 C 语言编译器（6）——函数定义\",\"手把手教你构建 C 语言编译器（7）——语句\",\"手把手教你构建 C 语言编译器（8）——表达式\",\"手把手教你构建 C 语言编译器（9）——总结\"]},\"114\":{\"h\":\"计算机的内部工作原理\",\"t\":[\"计算机中有三个基本部件需要我们关注：CPU、寄存器及内存。代码（汇编指令）以二进制的形式保存在内存中；CPU 从中一条条地加载指令执行；程序运行的状态保存在寄存器中。\"]},\"115\":{\"h\":\"内存\",\"t\":[\"内存用于存储数据，这里的数据可以是代码，也可以是其它的数据。现代操作系统在操作内存时，并不是直接处理”物理内存“，而是操作”虚拟内存“。虚拟内存可以理解为一种映射，它的作用是屏蔽了物理的细节。例如 32 位的机器中，我们可以使用的内存地址为 2^32 = 4G，而电脑上的实际内存可能只有 256 M。操作系统将我们使用的虚拟地址映射到了到实际的内存上。\",\"当然，我们这里并不需要了解太多，但需要了解的是：进程的内存会被分成几个段：\",\"代码段（text）用于存放代码（指令）。\",\"数据段（data）用于存放初始化了的数据，如int i = 10;，就需要存放到数据段中。\",\"未初始化数据段（bss）用于存放未初始化的数据，如 int i[1000];，因为不关心其中的真正数值，所以单独存放可以节省空间，减少程序的体积。\",\"栈（stack）用于处理函数调用相关的数据，如调用帧（calling frame）或是函数的局部变量等。\",\"堆（heap）用于为程序动态分配内存。\",\"它们在内存中的位置类似于下图：\",\"+------------------+| stack | | high address| ... v || || || || || ... ^ || heap | |+------------------+| bss segment |+------------------+| data segment |+------------------+| text segment | low address+------------------+\",\"我们的虚拟机并不打算模拟完整的计算机，因此简单起见，我们只关心三个内容：代码段、数据段以及栈。其中的数据段我们只用来存放字符串，因为我们的编译器并不支持初始化变量，因此我们也不需要未初始化数据段。\",\"当用户的程序需要分配内存时，理论上我们的虚拟机需要维护一个堆用于内存分配，但实际实现上较为复杂且与编译无关，故我们引入一个指令MSET，使我们能直接使用编译器（解释器）中的内存。\",\"综上，我们需要首先在全局添加如下代码：\",\"int *text, // text segment *old_text, // for dump text segment *stack; // stackchar *data; // data segment\",\"注意这里的类型，虽然是int型，但理解起来应该作为无符号的整型，因为我们会在代码段（text）中存放如指针/内存地址的数据，它们就是无符号的。其中数据段（data）由于只存放字符串，所以是 char * 型的。\",\"接着，在main函数中加入初始化代码，真正为其分配内存：\",\"int main() { close(fd); ... // allocate memory for virtual machine if (!(text = old_text = malloc(poolsize))) { printf(\\\"could not malloc(%d) for text area\\\\n\\\", poolsize); return -1; } if (!(data = malloc(poolsize))) { printf(\\\"could not malloc(%d) for data area\\\\n\\\", poolsize); return -1; } if (!(stack = malloc(poolsize))) { printf(\\\"could not malloc(%d) for stack area\\\\n\\\", poolsize); return -1; } memset(text, 0, poolsize); memset(data, 0, poolsize); memset(stack, 0, poolsize); ... program();}\"]},\"116\":{\"h\":\"寄存器\",\"t\":[\"计算机中的寄存器用于存放计算机的运行状态，真正的计算机中有许多不同种类的寄存器，但我们的虚拟机中只使用 4 个寄存器，分别如下：\",\"PC 程序计数器，它存放的是一个内存地址，该地址中存放着 下一条 要执行的计算机指令。\",\"SP 指针寄存器，永远指向当前的栈顶。注意的是由于栈是位于高地址并向低地址增长的，所以入栈时 SP 的值减小。\",\"BP 基址指针。也是用于指向栈的某些位置，在调用函数时会使用到它。\",\"AX 通用寄存器，我们的虚拟机中，它用于存放一条指令执行后的结果。\",\"要理解这些寄存器的作用，需要去理解程序运行中会有哪些状态。而这些寄存器只是用于保存这些状态的。\",\"在全局中加入如下定义：\",\"int *pc, *bp, *sp, ax, cycle; // virtual machine registers\",\"在 main 函数中加入初始化代码，注意的是PC在初始应指向目标代码中的main函数，但我们还没有写任何编译相关的代码，因此先不处理。代码如下：\",\"memset(stack, 0, poolsize);...bp = sp = (int *)((int)stack + poolsize);ax = 0;...program();\",\"与 CPU 相关的是指令集，我们将专门作为一个小节。\"]},\"117\":{\"h\":\"指令集\",\"t\":[\"指令集是 CPU 能识别的命令的集合，也可以说是 CPU 能理解的语言。这里我们要为我们的虚拟机构建自己的指令集。它们基于 x86 的指令集，但更为简单。\",\"首先在全局变量中加入一个枚举类型，这是我们要支持的全部指令：\",\"// instructionsenum { LEA ,IMM ,JMP ,CALL,JZ ,JNZ ,ENT ,ADJ ,LEV ,LI ,LC ,SI ,SC ,PUSH, OR ,XOR ,AND ,EQ ,NE ,LT ,GT ,LE ,GE ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD , OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT };\",\"这些指令的顺序安排是有意的，稍后你会看到，带有参数的指令在前，没有参数的指令在后。这种顺序的唯一作用就是在打印调试信息时更加方便。但我们讲解的顺序并不依据它。\"]},\"118\":{\"h\":\"MOV\",\"t\":[\"MOV 是所有指令中最基础的一个，它用于将数据放进寄存器或内存地址，有点类似于 C 语言中的赋值语句。x86 的 MOV 指令有两个参数，分别是源地址和目标地址：MOV dest, source （Intel 风格），表示将 source 的内容放在 dest 中，它们可以是一个数、寄存器或是一个内存地址。\",\"一方面，我们的虚拟机只有一个寄存器，另一方面，识别这些参数的类型（是数据还是地址）是比较困难的，因此我们将 MOV 指令拆分成 5 个指令，这些指令只接受一个参数，如下：\",\"IMM <num> 将 <num> 放入寄存器 ax 中。\",\"LC 将对应地址中的字符载入 ax 中，要求 ax 中存放地址。\",\"LI 将对应地址中的整数载入 ax 中，要求 ax 中存放地址。\",\"SC 将 ax 中的数据作为字符存放入地址中，要求栈顶存放地址。\",\"SI 将 ax 中的数据作为整数存放入地址中，要求栈顶存放地址。\",\"你可能会觉得将一个指令变成了许多指令，整个系统就变得复杂了，但实际情况并非如此。首先是 x86 的 MOV 指令其实有许多变种，根据类型的不同有 MOVB, MOVW 等指令，我们这里的 LC/SC 和 LI/SI 就是对应字符型和整型的存取操作。\",\"但最为重要的是，通过将 MOV 指令拆分成这些指令，只有 IMM 需要有参数，且不需要判断类型，所以大大简化了实现的难度。\",\"在 eval() 函数中加入下列代码：\",\"void eval() { int op, *tmp; while (1) { if (op == IMM) {ax = *pc++;} // load immediate value to ax else if (op == LC) {ax = *(char *)ax;} // load character to ax, address in ax else if (op == LI) {ax = *(int *)ax;} // load integer to ax, address in ax else if (op == SC) {ax = *(char *)*sp++ = ax;} // save character to address, value in ax, address on stack else if (op == SI) {*(int *)*sp++ = ax;} // save integer to address, value in ax, address on stack } ... return 0;}\",\"其中的 *sp++ 的作用是退栈，相当于 POP 操作。\",\"这里要解释的一点是，为什么 SI/SC 指令中，地址存放在栈中，而 LI/LC 中，地址存放在 ax 中？原因是默认计算的结果是存放在 ax 中的，而地址通常是需要通过计算获得，所以执行 LI/LC 时直接从 ax 取值会更高效。另一点是我们的 PUSH 指令只能将 ax 的值放到栈上，而不能以值作为参数，详细见下文。\"]},\"119\":{\"h\":\"PUSH\",\"t\":[\"在 x86 中，PUSH 的作用是将值或寄存器，而在我们的虚拟机中，它的作用是将 ax 的值放入栈中。这样做的主要原因是为了简化虚拟机的实现，并且我们也只有一个寄存器 ax 。代码如下：\",\"else if (op == PUSH) {*--sp = ax;} // push the value of ax onto the stack\"]},\"120\":{\"h\":\"JMP\",\"t\":[\"JMP <addr> 是跳转指令，无条件地将当前的 PC 寄存器设置为指定的 <addr>，实现如下：\",\"else if (op == JMP) {pc = (int *)*pc;} // jump to the address\",\"需要注意的是，pc 寄存器指向的是 下一条 指令。所以此时它存放的是 JMP 指令的参数，即 <addr> 的值。\"]},\"121\":{\"h\":\"JZ/JNZ\",\"t\":[\"为了实现 if 语句，我们需要条件判断相关的指令。这里我们只实现两个最简单的条件判断，即结果（ax）为零或不为零情况下的跳转。\",\"实现如下：\",\"else if (op == JZ) {pc = ax ? pc + 1 : (int *)*pc;} // jump if ax is zeroelse if (op == JNZ) {pc = ax ? (int *)*pc : pc + 1;} // jump if ax is not zero\"]},\"122\":{\"h\":\"子函数调用\",\"t\":[\"这是汇编中最难理解的部分，所以合在一起说，要引入的命令有 CALL, ENT, ADJ 及 LEV。\",\"首先我们介绍 CALL <addr> 与 RET 指令，CALL 的作用是跳转到地址为 <addr> 的子函数，RET 则用于从子函数中返回。\",\"为什么不能直接使用 JMP 指令呢？原因是当我们从子函数中返回时，程序需要回到跳转之前的地方继续运行，这就需要事先将这个位置信息存储起来。反过来，子函数要返回时，就需要获取并恢复这个信息。因此实际中我们将 PC 保存在栈中。如下：\",\"else if (op == CALL) {*--sp = (int)(pc+1); pc = (int *)*pc;} // call subroutine//else if (op == RET) {pc = (int *)*sp++;} // return from subroutine;\",\"这里我们把 RET 相关的内容注释了，是因为之后我们将用 LEV 指令来代替它。\",\"在实际调用函数时，不仅要考虑函数的地址，还要考虑如何传递参数和如何返回结果。这里我们约定，如果子函数有返回结果，那么就在返回时保存在 ax 中，它可以是一个值，也可以是一个地址。那么参数的传递呢？\",\"各种编程语言关于如何调用子函数有不同的约定，例如 C 语言的调用标准是：\",\"由调用者将参数入栈。\",\"调用结束时，由调用者将参数出栈。\",\"参数逆序入栈。\",\"事先声明一下，我们的编译器参数是顺序入栈的，下面的例子（C 语言调用标准）取自 维基百科：\",\"int callee(int, int, int);int caller(void){ int i, ret; ret = callee(1, 2, 3); ret += 5; return ret;}\",\"会生成如下的 x86 汇编代码：\",\"caller: ; make new call frame push ebp mov ebp, esp sub 1, esp ; save stack for variable: i ; push call arguments push 3 push 2 push 1 ; call subroutine 'callee' call callee ; remove arguments from frame add esp, 12 ; use subroutine result add eax, 5 ; restore old call frame mov esp, ebp pop ebp ; return ret\",\"上面这段代码在我们自己的虚拟机里会有几个问题：\",\"push ebp，但我们的 PUSH 指令并无法指定寄存器。\",\"mov ebp, esp，我们的 MOV 指令同样功能不足。\",\"add esp, 12，也是一样的问题（尽管我们还没定义）。\",\"也就是说由于我们的指令过于简单（如只能操作ax寄存器），所以用上面提到的指令，我们连函数调用都无法实现。而我们又不希望扩充现有指令的功能，因为这样实现起来就会变得复杂，因此我们采用的方法是增加指令集。毕竟我们不是真正的计算机，增加指令会消耗许多资源（钱）。\"]},\"123\":{\"h\":\"ENT\",\"t\":[\"ENT <size> 指的是 enter，用于实现 ‘make new call frame’ 的功能，即保存当前的栈指针，同时在栈上保留一定的空间，用以存放局部变量。对应的汇编代码为：\",\"; make new call framepush ebpmov ebp, esp sub 1, esp ; save stack for variable: i\",\"实现如下：\",\"else if (op == ENT) {*--sp = (int)bp; bp = sp; sp = sp - *pc++;} // make new stack frame\"]},\"124\":{\"h\":\"ADJ\",\"t\":[\"ADJ <size> 用于实现 ‘remove arguments from frame’。在将调用子函数时压入栈中的数据清除，本质上是因为我们的 ADD 指令功能有限。对应的汇编代码为：\",\"; remove arguments from frameadd esp, 12\",\"实现如下：\",\"else if (op == ADJ) {sp = sp + *pc++;} // add esp, <size>\"]},\"125\":{\"h\":\"LEV\",\"t\":[\"本质上这个指令并不是必需的，只是我们的指令集中并没有 POP 指令。并且三条指令写来比较麻烦且浪费空间，所以用一个指令代替。对应的汇编指令为：\",\"; restore old call frame mov esp, ebppop ebp; returnret\",\"具体的实现如下：\",\"else if (op == LEV) {sp = bp; bp = (int *)*sp++; pc = (int *)*sp++;} // restore call frame and PC\",\"注意的是，LEV 已经把 RET 的功能包含了，所以我们不再需要 RET 指令。\"]},\"126\":{\"h\":\"LEA\",\"t\":[\"上面的一些指令解决了调用帧的问题，但还有一个问题是如何在子函数中获得传入的参数。这里我们首先要了解的是当参数调用时，栈中的调用帧是什么样的。我们依旧用上面的例子（只是现在用“顺序”调用参数）：\",\"sub_function(arg1, arg2, arg3);| .... | high address+---------------+| arg: 1 | new_bp + 4+---------------+| arg: 2 | new_bp + 3+---------------+| arg: 3 | new_bp + 2+---------------+|return address | new_bp + 1+---------------+| old BP | <- new BP+---------------+| local var 1 | new_bp - 1+---------------+| local var 2 | new_bp - 2+---------------+| .... | low address\",\"所以为了获取第一个参数，我们需要得到 new_bp + 4，但就如上面的说，我们的 ADD 指令无法操作除 ax 外的寄存器，所以我们提供了一个新的指令：LEA <offset>\",\"实现如下：\",\"else if (op == LEA) {ax = (int)(bp + *pc++);} // load address for arguments.\",\"以上就是我们为了实现函数调用需要的指令了。\"]},\"127\":{\"h\":\"运算符指令\",\"t\":[\"我们为 C 语言中支持的运算符都提供对应汇编指令。每个运算符都是二元的，即有两个参数，第一个参数放在栈顶，第二个参数放在 ax 中。这个顺序要特别注意。因为像 -，/ 之类的运算符是与参数顺序有关的。计算后会将栈顶的参数退栈，结果存放在寄存器 ax 中。因此计算结束后，两个参数都无法取得了（汇编的意义上，存在内存地址上就另当别论）。\",\"实现如下：\",\"else if (op == OR) ax = *sp++ | ax;else if (op == XOR) ax = *sp++ ^ ax;else if (op == AND) ax = *sp++ & ax;else if (op == EQ) ax = *sp++ == ax;else if (op == NE) ax = *sp++ != ax;else if (op == LT) ax = *sp++ < ax;else if (op == LE) ax = *sp++ <= ax;else if (op == GT) ax = *sp++ > ax;else if (op == GE) ax = *sp++ >= ax;else if (op == SHL) ax = *sp++ << ax;else if (op == SHR) ax = *sp++ >> ax;else if (op == ADD) ax = *sp++ + ax;else if (op == SUB) ax = *sp++ - ax;else if (op == MUL) ax = *sp++ * ax;else if (op == DIV) ax = *sp++ / ax;else if (op == MOD) ax = *sp++ % ax;\"]},\"128\":{\"h\":\"内置函数\",\"t\":[\"写的程序要”有用“，除了核心的逻辑外还需要输入输出，例如 C 语言中我们经常使用的 printf 函数就是用于输出。但是 printf 函数的实现本身就十分复杂，如果我们的编译器要达到自举，就势必要实现 printf 之类的函数，但它又与编译器没有太大的联系，因此我们继续实现新的指令，从虚拟机的角度予以支持。\",\"编译器中我们需要用到的函数有：exit, open, close, read, printf, malloc, memset 及 memcmp。代码如下：\",\"else if (op == EXIT) { printf(\\\"exit(%d)\\\", *sp); return *sp;}else if (op == OPEN) { ax = open((char *)sp[1], sp[0]); }else if (op == CLOS) { ax = close(*sp);}else if (op == READ) { ax = read(sp[2], (char *)sp[1], *sp); }else if (op == PRTF) { tmp = sp + pc[1]; ax = printf((char *)tmp[-1], tmp[-2], tmp[-3], tmp[-4], tmp[-5], tmp[-6]); }else if (op == MALC) { ax = (int)malloc(*sp);}else if (op == MSET) { ax = (int)memset((char *)sp[2], sp[1], *sp);}else if (op == MCMP) { ax = memcmp((char *)sp[2], (char *)sp[1], *sp);}\",\"这里的原理是，我们的电脑上已经有了这些函数的实现，因此编译编译器时，这些函数的二进制代码就被编译进了我们的编译器，因此在我们的编译器/虚拟机上运行我们提供的这些指令时，这些函数就是可用的。换句话说就是不需要我们自己去实现了。\",\"最后再加上一个错误判断：\",\"else { printf(\\\"unknown instruction:%d\\\\n\\\", op); return -1;}\"]},\"129\":{\"h\":\"测试\",\"t\":[\"下面我们用我们的汇编写一小段程序，来计算 10+20，在 main 函数中加入下列代码：\",\"int main(int argc, char *argv[]){ ax = 0; ... i = 0; text[i++] = IMM; text[i++] = 10; text[i++] = PUSH; text[i++] = IMM; text[i++] = 20; text[i++] = ADD; text[i++] = PUSH; text[i++] = EXIT; pc = text; ... program();}\",\"编译程序 gcc xc-tutor.c，运行程序：./a.out hello.c。输出\",\"exit(30)\",\"另外，我们的代码里有一些指针的强制转换，默认是 32 位的，因此在 64 位机器下，会出现 segmentation fault，解决方法（二选一）：\",\"编译时加上 -m32 参数：gcc -m32 xc-tutor.c\",\"在代码的开头，增加 #define int long long，long long 是 64 位的，不会出现强制转换后的问题。\",\"注意我们的之前的程序需要指令一个源文件，只是现在还用不着，但从结果可以看出，我们的虚拟机还是工作良好的。\"]},\"130\":{\"h\":\"小结\",\"t\":[\"本章中我们回顾了计算机的内部运行原理，并仿照 x86 汇编指令设计并实现了我们自己的指令集。希望通过本章的学习，你能对计算机程序的原理有一定的了解，同时能对汇编语言有一定的概念，因为汇编语言就是 C 编译器的输出。\",\"本章的代码可以在 Github 上下载，也可以直接 clone\",\"git clone -b step-1 https://github.com/lotabout/write-a-C-interpreter\",\"实际计算机中，添加一个新的指令需要设计许多新的电路，会增加许多的成本，但我们的虚拟机中，新的指令几乎不消耗资源，因此我们可以利用这一点，用更多的指令来完成更多的功能，从而简化具体的实现。\"]},\"131\":{\"h\":\"手把手教你构建 C 语言编译器（0）- 前言\",\"t\":[\"本文转自 https://lotabout.me/2015/write-a-C-interpreter-3/，如有侵权，请联系删除。\",\"Table of Contents\",\"1. 什么是词法分析器\",\"2. 词法分析器与编译器\",\"3. 词法分析器的实现\",\"3.1. 支持的标记\",\"3.2. 词法分析器的框架\",\"3.3. 换行符\",\"3.4. 宏定义\",\"3.5. 标识符与符号表\",\"3.6. 数字\",\"3.7. 字符串\",\"3.8. 注释\",\"3.9. 其它\",\"3.10. 关键字与内置函数\",\"4. 代码\",\"5. 小结\",\"本章我们要讲解如何构建词法分析器。\",\"手把手教你构建 C 语言编译器系列共有10个部分：\",\"手把手教你构建 C 语言编译器（0）——前言\",\"手把手教你构建 C 语言编译器（1）——设计\",\"手把手教你构建 C 语言编译器（2）——虚拟机\",\"手把手教你构建 C 语言编译器（3）——词法分析器\",\"手把手教你构建 C 语言编译器（4）——递归下降\",\"手把手教你构建 C 语言编译器（5）——变量定义\",\"手把手教你构建 C 语言编译器（6）——函数定义\",\"手把手教你构建 C 语言编译器（7）——语句\",\"手把手教你构建 C 语言编译器（8）——表达式\",\"手把手教你构建 C 语言编译器（9）——总结\"]},\"132\":{\"h\":\"什么是词法分析器\",\"t\":[\"简而言之，词法分析器用于对源码字符串做预处理，以减少语法分析器的复杂程度。\",\"词法分析器以源码字符串为输入，输出为标记流（token stream），即一连串的标记，每个标记通常包括： (token, token value) 即标记本身和标记的值。例如，源码中若包含一个数字 '998' ，词法分析器将输出 (Number, 998)，即（数字，998）。再例如：\",\"2 + 3 * (4 - 5)=>(Number, 2) Add (Number, 3) Multiply Left-Bracket (Number, 4) Subtract (Number, 5) Right-Bracket\",\"通过词法分析器的预处理，语法分析器的复杂度会大大降低，这点在后面的语法分析器我们就能体会。\"]},\"133\":{\"h\":\"词法分析器与编译器\",\"t\":[\"要是深入词法分析器，你就会发现，它的本质上也是编译器。我们的编译器是以标记流为输入，输出汇编代码，而词法分析器则是以源码字符串为输入，输出标记流。\",\" +-------+ +--------+-- source code --> | lexer | --> token stream --> | parser | --> assembly +-------+ +--------+\",\"在这个前提下，我们可以这样认为：直接从源代码编译成汇编代码是很困难的，因为输入的字符串比较难处理。所以我们先编写一个较为简单的编译器（词法分析器）来将字符串转换成标记流，而标记流对于语法分析器而言就容易处理得多了。\"]},\"134\":{\"h\":\"词法分析器的实现\",\"t\":[\"由于词法分析的工作很常见，但又枯燥且容易出错，所以人们已经开发出了许多工具来生成词法分析器，如 lex, flex。这些工具允许我们通过正则表达式来识别标记。\",\"这里注意的是，我们并不会一次性地将所有源码全部转换成标记流，原因有二：\",\"字符串转换成标记流有时是有状态的，即与代码的上下文是有关系的。\",\"保存所有的标记流没有意义且浪费空间。\",\"所以实际的处理方法是提供一个函数（即前几篇中提到的 next()），每次调用该函数则返回下一个标记。\"]},\"135\":{\"h\":\"支持的标记\",\"t\":[\"在全局中添加如下定义：\",\"// tokens and classes (operators last and in precedence order)enum { Num = 128, Fun, Sys, Glo, Loc, Id, Char, Else, Enum, If, Int, Return, Sizeof, While, Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak};\",\"这些就是我们要支持的标记符。例如，我们会将 = 解析为 Assign；将 == 解析为 Eq；将 != 解析为 Ne 等等。\",\"所以这里我们会有这样的印象，一个标记（token）可能包含多个字符，且多数情况下如此。而词法分析器能减小语法分析复杂度的原因，正是因为它相当于通过一定的编码（更多的标记）来压缩了源码字符串。\",\"当然，上面这些标记是有顺序的，跟它们在 C 语言中的优先级有关，如 *(Mul) 的优先级就要高于 +(Add)。它们的具体使用在后面的语法分析中会提到。\",\"最后要注意的是还有一些字符，它们自己就构成了标记，如右方括号 ] 或波浪号 ~ 等。我们不另外处理它们的原因是：\",\"它们是单字符的，即并不是多个字符共同构成标记（如 == 需要两个字符）；\",\"它们不涉及优先级关系。\"]},\"136\":{\"h\":\"词法分析器的框架\",\"t\":[\"即 next() 函数的主体：\",\"void next() { char *last_pos; int hash; while (token = *src) { ++src; // parse token here } return;}\",\"这里的一个问题是，为什么要用 while 循环呢？这就涉及到编译器（记得我们说过词法分析器也是某种意义上的编译器）的一个问题：如何处理错误？\",\"对词法分析器而言，若碰到了一个我们不认识的字符该怎么处理？一般处理的方法有两种：\",\"指出错误发生的位置，并退出整个程序\",\"指出错误发生的位置，跳过当前错误并继续编译\",\"这个 while 循环的作用就是跳过这些我们不识别的字符，我们同时还用它来处理空白字符。我们知道，C 语言中空格是用来作为分隔用的，并不作为语法的一部分。因此在实现中我们将它作为“不识别”的字符，这个 while 循环可以用来跳过它。\"]},\"137\":{\"h\":\"换行符\",\"t\":[\"换行符和空格类似，但有一点不同，每次遇到换行符，我们需要将当前的行号加一：\",\"// parse token here...if (token == '\\\\n') { ++line;}...\"]},\"138\":{\"h\":\"宏定义\",\"t\":[\"C 语言的宏定义以字符 # 开头，如 # include <stdio.h>。我们的编译器并不支持宏定义，所以直接跳过它们。\",\"else if (token == '#') { // skip macro, because we will not support it while (*src != 0 && *src != '\\\\n') { src++; }}\"]},\"139\":{\"h\":\"标识符与符号表\",\"t\":[\"标识符（identifier）可以理解为变量名。对于语法分析而言，我们并不关心一个变量具体叫什么名字，而只关心这个变量名代表的唯一标识。例如 int a; 定义了变量 a，而之后的语句 a = 10，我们需要知道这两个 a 指向的是同一个变量。\",\"基于这个理由，词法分析器会把扫描到的标识符全都保存到一张表中，遇到新的标识符就去查这张表，如果标识符已经存在，就返回它的唯一标识。\",\"那么我们怎么表示标识符呢？如下：\",\"struct identifier { int token; int hash; char * name; int class; int type; int value; int Bclass; int Btype; int Bvalue;}\",\"这里解释一下具体的含义：\",\"token：该标识符返回的标记，理论上所有的变量返回的标记都应该是 Id，但实际上由于我们还将在符号表中加入关键字如 if, while 等，它们都有对应的标记。\",\"hash：顾名思义，就是这个标识符的哈希值，用于标识符的快速比较。\",\"name：存放标识符本身的字符串。\",\"class：该标识符的类别，如数字，全局变量或局部变量等。\",\"type：标识符的类型，即如果它是个变量，变量是 int 型、char 型还是指针型。\",\"value：存放这个标识符的值，如标识符是函数，刚存放函数的地址。\",\"BXXXX：C 语言中标识符可以是全局的也可以是局部的，当局部标识符的名字与全局标识符相同时，用作保存全局标识符的信息。\",\"由上可以看出，我们实现的词法分析器与传统意义上的词法分析器不太相同。传统意义上的符号表只需要知道标识符的唯一标识即可，而我们还存放了一些只有语法分析器才会得到的信息，如 type 。\",\"由于我们的目标是能自举，而我们定义的语法不支持 struct，故而使用下列方式。\",\"Symbol table:----+-----+----+----+----+-----+-----+-----+------+------+---- .. |token|hash|name|type|class|value|btype|bclass|bvalue| ..----+-----+----+----+----+-----+-----+-----+------+------+---- |<--- one single identifier --->|\",\"即用一个整型数组来保存相关的ID信息。每个ID占用数组中的9个空间，分析标识符的相关代码如下：\",\"int token_val; // value of current token (mainly for number)int *current_id, // current parsed ID *symbols; // symbol table// fields of identifierenum {Token, Hash, Name, Type, Class, Value, BType, BClass, BValue, IdSize};void next() { ... else if ((token >= 'a' && token <= 'z') || (token >= 'A' && token <= 'Z') || (token == '_')) { // parse identifier last_pos = src - 1; hash = token; while ((*src >= 'a' && *src <= 'z') || (*src >= 'A' && *src <= 'Z') || (*src >= '0' && *src <= '9') || (*src == '_')) { hash = hash * 147 + *src; src++; } // look for existing identifier, linear search current_id = symbols; while (current_id[Token]) { if (current_id[Hash] == hash && !memcmp((char *)current_id[Name], last_pos, src - last_pos)) { //found one, return token = current_id[Token]; return; } current_id = current_id + IdSize; } // store new ID current_id[Name] = (int)last_pos; current_id[Hash] = hash; token = current_id[Token] = Id; return; } ...}\",\"查找已有标识符的方法是线性查找 symbols 表。\"]},\"140\":{\"h\":\"数字\",\"t\":[\"数字中较为复杂的一点是需要支持十进制、十六进制及八进制。逻辑也较为直接，可能唯一不好理解的是获取十六进制的值相关的代码。\",\"token_val = token_val * 16 + (token & 15) + (token >= 'A' ? 9 : 0);\",\"这里要注意的是在ASCII码中，字符a对应的十六进制值是 61, A是41，故通过 (token & 15) 可以得到个位数的值。其它就不多说了，这里这样写的目的是装B（其实是抄 c4 的源代码的）。\",\"void next() { ... else if (token >= '0' && token <= '9') { // parse number, three kinds: dec(123) hex(0x123) oct(017) token_val = token - '0'; if (token_val > 0) { // dec, starts with [1-9] while (*src >= '0' && *src <= '9') { token_val = token_val*10 + *src++ - '0'; } } else { // starts with number 0 if (*src == 'x' || *src == 'X') { //hex token = *++src; while ((token >= '0' && token <= '9') || (token >= 'a' && token <= 'f') || (token >= 'A' && token <= 'F')) { token_val = token_val * 16 + (token & 15) + (token >= 'A' ? 9 : 0); token = *++src; } } else { // oct while (*src >= '0' && *src <= '7') { token_val = token_val*8 + *src++ - '0'; } } } token = Num; return; } ...}\"]},\"141\":{\"h\":\"字符串\",\"t\":[\"在分析时，如果分析到字符串，我们需要将它存放到前一篇文章中说的 data 段中。然后返回它在 data 段中的地址。另一个特殊的地方是我们需要支持转义符。例如用 \\\\n 表示换行符。由于本编译器的目的是达到自己编译自己，所以代码中并没有支持除 \\\\n 的转义符，如 \\\\t, \\\\r 等，但仍支持 \\\\a 表示字符 a 的语法，如 \\\\\\\" 表示 \\\"。\",\"在分析时，我们将同时分析单个字符如 'a' 和字符串如 \\\"a string\\\"。若得到的是单个字符，我们以 Num 的形式返回。相关代码如下：\",\"void next() { ... else if (token == '\\\"' || token == '\\\\'') { // parse string literal, currently, the only supported escape // character is '\\\\n', store the string literal into data. last_pos = data; while (*src != 0 && *src != token) { token_val = *src++; if (token_val == '\\\\\\\\') { // escape character token_val = *src++; if (token_val == 'n') { token_val = '\\\\n'; } } if (token == '\\\"') { *data++ = token_val; } } src++; // if it is a single character, return Num token if (token == '\\\"') { token_val = (int)last_pos; } else { token = Num; } return; }}\"]},\"142\":{\"h\":\"注释\",\"t\":[\"在我们的 C 语言中，只支持 // 类型的注释，不支持 /* comments */ 的注释。\",\"void next() { ... else if (token == '/') { if (*src == '/') { // skip comments while (*src != 0 && *src != '\\\\n') { ++src; } } else { // divide operator token = Div; return; } } ...}\",\"这里我们要额外介绍 lookahead 的概念，即提前看多个字符。上述代码中我们看到，除了跳过注释，我们还可能返回除号 /(Div) 标记。\",\"提前看字符的原理是：有一个或多个标记是以同样的字符开头的（如本小节中的注释与除号），因此只凭当前的字符我们并无法确定具体应该解释成哪一个标记，所以只能再向前查看字符，如本例需向前查看一个字符，若是 / 则说明是注释，反之则是除号。\",\"我们之前说过，词法分析器本质上也是编译器，其实提前看字符的概念也存在于编译器，只是这时就是提前看k个“标记”而不是“字符”了。平时听到的 LL(k) 中的 k 就是需要向前看的标记的个数了。\",\"另外，我们用词法分析器将源码转换成标记流，能减小语法分析复杂度，原因之一就是减少了语法分析器需要“向前看”的字符个数。\"]},\"143\":{\"h\":\"其它\",\"t\":[\"其它的标记的解析就相对容易一些了，我们直接贴上代码：\",\"void next() { ... else if (token == '=') { // parse '==' and '=' if (*src == '=') { src ++; token = Eq; } else { token = Assign; } return; } else if (token == '+') { // parse '+' and '++' if (*src == '+') { src ++; token = Inc; } else { token = Add; } return; } else if (token == '-') { // parse '-' and '--' if (*src == '-') { src ++; token = Dec; } else { token = Sub; } return; } else if (token == '!') { // parse '!=' if (*src == '=') { src++; token = Ne; } return; } else if (token == '<') { // parse '<=', '<<' or '<' if (*src == '=') { src ++; token = Le; } else if (*src == '<') { src ++; token = Shl; } else { token = Lt; } return; } else if (token == '>') { // parse '>=', '>>' or '>' if (*src == '=') { src ++; token = Ge; } else if (*src == '>') { src ++; token = Shr; } else { token = Gt; } return; } else if (token == '|') { // parse '|' or '||' if (*src == '|') { src ++; token = Lor; } else { token = Or; } return; } else if (token == '&') { // parse '&' and '&&' if (*src == '&') { src ++; token = Lan; } else { token = And; } return; } else if (token == '^') { token = Xor; return; } else if (token == '%') { token = Mod; return; } else if (token == '*') { token = Mul; return; } else if (token == '[') { token = Brak; return; } else if (token == '?') { token = Cond; return; } else if (token == '~' || token == ';' || token == '{' || token == '}' || token == '(' || token == ')' || token == ']' || token == ',' || token == ':') { // directly return the character as token; return; } ...}\",\"代码较多，但主要逻辑就是向前看一个字符来确定真正的标记。\"]},\"144\":{\"h\":\"关键字与内置函数\",\"t\":[\"虽然上面写完了词法分析器，但还有一个问题需要考虑，那就是“关键字”，例如 if, while, return 等。它们不能被作为普通的标识符，因为有特殊的含义。\",\"一般有两种处理方法：\",\"词法分析器中直接解析这些关键字。\",\"在语法分析前将关键字提前加入符号表。\",\"这里我们就采用第二种方法，将它们加入符号表，并提前为它们赋予必要的信息（还记得前面说的标识符 Token 字段吗？）。这样当源代码中出现关键字时，它们会被解析成标识符，但由于符号表中已经有了相关的信息，我们就能知道它们是特殊的关键字。\",\"内置函数的行为也和关键字类似，不同的只是赋值的信息，在main函数中进行初始化如下：\",\"// types of variable/functionenum { CHAR, INT, PTR };int *idmain; // the `main` functionvoid main() { ... src = \\\"char else enum if int return sizeof while \\\" \\\"open read close printf malloc memset memcmp exit void main\\\"; // add keywords to symbol table i = Char; while (i <= While) { next(); current_id[Token] = i++; } // add library to symbol table i = OPEN; while (i <= EXIT) { next(); current_id[Class] = Sys; current_id[Type] = INT; current_id[Value] = i++; } next(); current_id[Token] = Char; // handle void type next(); idmain = current_id; // keep track of main ... program();}\"]},\"145\":{\"h\":\"代码\",\"t\":[\"本章的代码可以在 Github 上下载，也可以直接 clone\",\"git clone -b step-2 https://github.com/lotabout/write-a-C-interpreter\",\"上面的代码运行后会出现 ‘Segmentation Falt’，这是正常的，因为它会尝试运行我们上一章创建的虚拟机，但其中并没有任何汇编代码。\"]},\"146\":{\"h\":\"小结\",\"t\":[\"本章我们为我们的编译器构建了词法分析器，通过本章的学习，我认为有几个要点需要强调：\",\"词法分析器的作用是对源码字符串进行预处理，作用是减小语法分析器的复杂程度。\",\"词法分析器本身可以认为是一个编译器，输入是源码，输出是标记流。\",\"lookahead(k) 的概念，即向前看 k 个字符或标记。\",\"词法分析中如何处理标识符与符号表。\",\"下一章中，我们将介绍递归下降的语法分析器。我们下一章见。\"]},\"147\":{\"h\":\"手把手教你构建 C 语言编译器（0）- 前言\",\"t\":[\"[[[toc]]]\",\"本文转自 https://lotabout.me/2016/write-a-C-interpreter-4/，如有侵权，请联系删除。\",\"Table of Contents\",\"1. 什么是递归下降\",\"2. 终结符与非终结符\",\"3. 四则运算的递归下降\",\"4. 为什么选择递归下降\",\"5. 左递归\",\"6. 四则运算的实现\",\"7. 小结\",\"本章我们将讲解递归下降的方法，并用它完成一个基本的四则运算的语法分析器。\",\"手把手教你构建 C 语言编译器系列共有10个部分：\",\"手把手教你构建 C 语言编译器（0）——前言\",\"手把手教你构建 C 语言编译器（1）——设计\",\"手把手教你构建 C 语言编译器（2）——虚拟机\",\"手把手教你构建 C 语言编译器（3）——词法分析器\",\"手把手教你构建 C 语言编译器（4）——递归下降\",\"手把手教你构建 C 语言编译器（5）——变量定义\",\"手把手教你构建 C 语言编译器（6）——函数定义\",\"手把手教你构建 C 语言编译器（7）——语句\",\"手把手教你构建 C 语言编译器（8）——表达式\",\"手把手教你构建 C 语言编译器（9）——总结\"]},\"148\":{\"h\":\"什么是递归下降\",\"t\":[\"传统上，编写语法分析器有两种方法，一种是自顶向下，一种是自底向上。自顶向下是从起始非终结符开始，不断地对非终结符进行分解，直到匹配输入的终结符；自底向上是不断地将终结符进行合并，直到合并成起始的非终结符。\",\"其中的自顶向下方法就是我们所说的递归下降。\"]},\"149\":{\"h\":\"终结符与非终结符\",\"t\":[\"没有学过编译原理的话可能并不知道什么是“终结符”，“非终结符”。这里我简单介绍一下。首先是 BNF 范式，就是一种用来描述语法的语言，例如，四则运算的规则可以表示如下：\",\"<expr> ::= <expr> + <term> | <expr> - <term> | <term><term> ::= <term> * <factor> | <term> / <factor> | <factor><factor> ::= ( <expr> ) | Num\",\"用尖括号 <> 括起来的就称作 非终结符 ，因为它们可以用 ::= 右侧的式子代替。| 表示选择，如 <expr> 可以是 <expr> + <term>、<expr> - <term>或 <term> 中的一种。而没有出现在::=左边的就称作 终结符 ，一般终结符对应于词法分析器输出的标记。\"]},\"150\":{\"h\":\"四则运算的递归下降\",\"t\":[\"例如，我们对 3 * (4 + 2) 进行语法分析。我们假设词法分析器已经正确地将其中的数字识别成了标记 Num。\",\"递归下降是从起始的非终结符开始（顶），本例中是 <expr>，实际中可以自己指定，不指定的话一般认为是第一个出现的非终结符。\",\"1. <expr> => <expr>2. => <term> * <factor>3. => <factor> |4. => Num (3) |5. => ( <expr> )6. => <expr> + <term>7. => <term> |8. => <factor> |9. => Num (4) |10. => <factor>11. => Num (2)\",\"可以看到，整个解析的过程是在不断对非终结符进行替换（向下），直到遇见了终结符（底）。而我们可以从解析的过程中看出，一些非终结符如<expr>被递归地使用了。\"]},\"151\":{\"h\":\"为什么选择递归下降\",\"t\":[\"从上小节对四则运算的递归下降解析可以看出，整个解析的过程和语法的 BNF 表示是十分接近的，更为重要的是，我们可以很容易地直接将 BNF 表示转换成实际的代码。方法是为每个产生式（即 非终结符 ::= ...）生成一个同名的函数。\",\"这里会有一个疑问，就是上例中，当一个终结符有多个选择时，如何确定具体选择哪一个？如为什么用 <expr> ::= <term> * <factor> 而不是 <expr> ::= <term> / <factor> ？这就用到了上一章中提到的“向前看 k 个标记”的概念了。我们向前看一个标记，发现是 *，而这个标记足够让我们确定用哪个表达式了。\",\"另外，递归下下降方法对 BNF 方法本身有一定的要求，否则会有一些问题，如经典的“左递归”问题。\"]},\"152\":{\"h\":\"左递归\",\"t\":[\"原则上我们是不讲这么深入，但我们上面的四则运算的文法就是左递归的，而左递归的语法是没法直接使用递归下降的方法实现的。因此我们要消除左递归，消除后的文法如下：\",\"<expr> ::= <term> <expr_tail><expr_tail> ::= + <term> <expr_tail> | - <term> <expr_tail> | <empty><term> ::= <factor> <term_tail><term_tail> ::= * <factor> <term_tail> | / <factor> <term_tail> | <empty><factor> ::= ( <expr> ) | Num\",\"消除左递归的相关方法，这里不再多说，请自行查阅相关的资料。\"]},\"153\":{\"h\":\"四则运算的实现\",\"t\":[\"本节中我们专注语法分析器部分的实现，具体实现很容易，我们直接贴上代码，就是上述的消除左递归后的文法直接转换而来的：\",\"int expr();int factor() { int value = 0; if (token == '(') { match('('); value = expr(); match(')'); } else { value = token_val; match(Num); } return value;}int term_tail(int lvalue) { if (token == '*') { match('*'); int value = lvalue * factor(); return term_tail(value); } else if (token == '/') { match('/'); int value = lvalue / factor(); return term_tail(value); } else { return lvalue; }}int term() { int lvalue = factor(); return term_tail(lvalue);}int expr_tail(int lvalue) { if (token == '+') { match('+'); int value = lvalue + term(); return expr_tail(value); } else if (token == '-') { match('-'); int value = lvalue - term(); return expr_tail(value); } else { return lvalue; }}int expr() { int lvalue = term(); return expr_tail(lvalue);}\",\"可以看到，有了BNF方法后，采用递归向下的方法来实现编译器是很直观的。\",\"我们把词法分析器的代码一并贴上：\",\"##include <stdio.h>##include <stdlib.h>enum {Num};int token;int token_val;char *line = NULL;char *src = NULL;void next() { // skip white space while (*src == ' ' || *src == '\\\\t') { src ++; } token = *src++; if (token >= '0' && token <= '9' ) { token_val = token - '0'; token = Num; while (*src >= '0' && *src <= '9') { token_val = token_val*10 + *src - '0'; src ++; } return; }}void match(int tk) { if (token != tk) { printf(\\\"expected token: %d(%c), got: %d(%c)\\\\n\\\", tk, tk, token, token); exit(-1); } next();}\",\"最后是main函数：\",\"int main(int argc, char *argv[]){ size_t linecap = 0; ssize_t linelen; while ((linelen = getline(&line, &linecap, stdin)) > 0) { src = line; next(); printf(\\\"%d\\\\n\\\", expr()); } return 0;}\"]},\"154\":{\"h\":\"小结\",\"t\":[\"本章中我们介绍了递归下降的方法，并用它来实现了四则运算的语法分析器。\",\"花这么大精力讲解递归下降方法，是因为几乎所有手工编写的语法分析器都或多或少地有它的影子。换句话说，掌握了递归下降的方法，就可以应付大多数的语法分析器编写。\",\"同时我们也用实例看到了理论（BNF 语法，左递归的消除）是如何帮助我们的工程实现的。尽管理论不是必需的，但如果能掌握它，对于提高我们的水平还是很有帮助的。\"]},\"155\":{\"h\":\"手把手教你构建 C 语言编译器（0）- 前言\",\"t\":[\"本文转自 https://lotabout.me/2016/write-a-C-interpreter-5/，如有侵权，请联系删除。\",\"Table of Contents\",\"1. EBNF 表示\",\"2. 解析变量的定义\",\"2.1. program()\",\"2.2. global_declaration()\",\"2.3. enum_declaration()\",\"2.4. 其它\",\"3. 代码\",\"4. 小结\",\"本章中我们用 EBNF 来大致描述我们实现的 C 语言的文法，并实现其中解析变量定义部分。\",\"由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定义、函数定义、表达式。\",\"手把手教你构建 C 语言编译器系列共有10个部分：\",\"手把手教你构建 C 语言编译器（0）——前言\",\"手把手教你构建 C 语言编译器（1）——设计\",\"手把手教你构建 C 语言编译器（2）——虚拟机\",\"手把手教你构建 C 语言编译器（3）——词法分析器\",\"手把手教你构建 C 语言编译器（4）——递归下降\",\"手把手教你构建 C 语言编译器（5）——变量定义\",\"手把手教你构建 C 语言编译器（6）——函数定义\",\"手把手教你构建 C 语言编译器（7）——语句\",\"手把手教你构建 C 语言编译器（8）——表达式\",\"手把手教你构建 C 语言编译器（9）——总结\"]},\"156\":{\"h\":\"EBNF 表示\",\"t\":[\"EBNF 是对前一章提到的 BNF 的扩展，它的语法更容易理解，实现起来也更直观。但真正看起来还是很烦，如果不想看可以跳过。\",\"program ::= {global_declaration}+global_declaration ::= enum_decl | variable_decl | function_declenum_decl ::= 'enum' [id] '{' id ['=' 'num'] {',' id ['=' 'num'] '}'variable_decl ::= type {'*'} id { ',' {'*'} id } ';'function_decl ::= type {'*'} id '(' parameter_decl ')' '{' body_decl '}'parameter_decl ::= type {'*'} id {',' type {'*'} id}body_decl ::= {variable_decl}, {statement}statement ::= non_empty_statement | empty_statementnon_empty_statement ::= if_statement | while_statement | '{' statement '}' | 'return' expression | expression ';'if_statement ::= 'if' '(' expression ')' statement ['else' non_empty_statement]while_statement ::= 'while' '(' expression ')' non_empty_statement\",\"其中 expression 相关的内容我们放到后面解释，主要原因是我们的语言不支持跨函数递归，而为了实现自举，实际上我们也不能使用递归（亏我们说了一章的递归下降）。\",\"P.S. 我是先写程序再总结上面的文法，所以实际上它们间的对应关系并不是特别明显。\"]},\"157\":{\"h\":\"解析变量的定义\",\"t\":[\"本章要讲解的就是上节文法中的 enum_decl 和 variable_decl 部分。\"]},\"158\":{\"h\":\"program()\",\"t\":[\"首先是之前定义过的 program 函数，将它改成：\",\"void program() { // get next token next(); while (token > 0) { global_declaration(); }}\",\"我知道 global_declaration 函数还没有出现过，但没有关系，采用自顶向下的编写方法就是要不断地实现我们需要的内容。下面是 global_declaration 函数的内容：\"]},\"159\":{\"h\":\"global_declaration()\",\"t\":[\"即全局的定义语句，包括变量定义，类型定义（只支持枚举）及函数定义。代码如下：\",\"int basetype; // the type of a declaration, make it global for convenienceint expr_type; // the type of an expressionvoid global_declaration() { // global_declaration ::= enum_decl | variable_decl | function_decl // // enum_decl ::= 'enum' [id] '{' id ['=' 'num'] {',' id ['=' 'num'} '}' // // variable_decl ::= type {'*'} id { ',' {'*'} id } ';' // // function_decl ::= type {'*'} id '(' parameter_decl ')' '{' body_decl '}' int type; // tmp, actual type for variable int i; // tmp basetype = INT; // parse enum, this should be treated alone. if (token == Enum) { // enum [id] { a = 10, b = 20, ... } match(Enum); if (token != '{') { match(Id); // skip the [id] part } if (token == '{') { // parse the assign part match('{'); enum_declaration(); match('}'); } match(';'); return; } // parse type information if (token == Int) { match(Int); } else if (token == Char) { match(Char); basetype = CHAR; } // parse the comma seperated variable declaration. while (token != ';' && token != '}') { type = basetype; // parse pointer type, note that there may exist `int ****x;` while (token == Mul) { match(Mul); type = type + PTR; } if (token != Id) { // invalid declaration printf(\\\"%d: bad global declaration\\\\n\\\", line); exit(-1); } if (current_id[Class]) { // identifier exists printf(\\\"%d: duplicate global declaration\\\\n\\\", line); exit(-1); } match(Id); current_id[Type] = type; if (token == '(') { current_id[Class] = Fun; current_id[Value] = (int)(text + 1); // the memory address of function function_declaration(); } else { // variable declaration current_id[Class] = Glo; // global variable current_id[Value] = (int)data; // assign memory address data = data + sizeof(int); } if (token == ',') { match(','); } } next();}\",\"看了上面的代码，能大概理解吗？这里我们讲解其中的一些细节。\",\"向前看标记 ：其中的 if (token == xxx) 语句就是用来向前查看标记以确定使用哪一个产生式，例如只要遇到 enum 我们就知道是需要解析枚举类型。而如果只解析到类型，如 int identifier 时我们并不能确定 identifier 是一个普通的变量还是一个函数，所以还需要继续查看后续的标记，如果遇到 ( 则可以断定是函数了，反之则是变量。\",\"变量类型的表示 ：我们的编译器支持指针类型，那意味着也支持指针的指针，如 int **data;。那么我们如何表示指针类型呢？前文中我们定义了支持的类型：\",\"// types of variable/functionenum { CHAR, INT, PTR };\",\"所以一个类型首先有基本类型，如 CHAR 或 INT，当它是一个指向基本类型的指针时，如 int *data，我们就将它的类型加上 PTR 即代码中的：type = type + PTR;。同理，如果是指针的指针，则再加上 PTR。\"]},\"160\":{\"h\":\"enum_declaration()\",\"t\":[\"用于解析枚举类型的定义。主要的逻辑用于解析用逗号（,）分隔的变量，值得注意的是在编译器中如何保存枚举变量的信息。\",\"即我们将该变量的类别设置成了 Num，这样它就成了全局的常量了，而注意到上节中，正常的全局变量的类别则是 Glo，类别信息在后面章节中解析 expression 会使用到。\",\"void enum_declaration() { // parse enum [id] { a = 1, b = 3, ...} int i; i = 0; while (token != '}') { if (token != Id) { printf(\\\"%d: bad enum identifier %d\\\\n\\\", line, token); exit(-1); } next(); if (token == Assign) { // like {a=10} next(); if (token != Num) { printf(\\\"%d: bad enum initializer\\\\n\\\", line); exit(-1); } i = token_val; next(); } current_id[Class] = Num; current_id[Type] = INT; current_id[Value] = i++; if (token == ',') { next(); } }}\"]},\"161\":{\"h\":\"其它\",\"t\":[\"其中的 function_declaration 函数我们将放到下一章中讲解。match 函数是一个辅助函数：\",\"void match(int tk) { if (token == tk) { next(); } else { printf(\\\"%d: expected token: %d\\\\n\\\", line, tk); exit(-1); }}\",\"它将 next 函数包装起来，如果不是预期的标记则报错并退出。\"]},\"162\":{\"h\":\"代码\",\"t\":[\"本章的代码可以在 Github 上下载，也可以直接 clone\",\"git clone -b step-3 https://github.com/lotabout/write-a-C-interpreter\",\"本章的代码还无法正常运行，因为还有许多功能没有实现，但如果有兴趣的话，可以自己先试着去实现它。\"]},\"163\":{\"h\":\"小结\",\"t\":[\"本章的内容应该不难，除了开头的 EBNF 表达式可能相对不好理解一些，但如果你查看了 EBNF 的具体表示方法后就不难理解了。\",\"剩下的内容就是按部就班地将 EBNF 的产生式转换成函数的过程，如果你理解了上一章中的内容，相信这部分也不难理解。\",\"下一章中我们将介绍如何解析函数的定义，敬请期待。\"]},\"164\":{\"h\":\"手把手教你构建 C 语言编译器（0）- 前言\",\"t\":[\"本文转自 https://lotabout.me/2016/write-a-C-interpreter-6/，如有侵权，请联系删除。\",\"Table of Contents\",\"1. EBNF 表示\",\"2. 解析函数的定义\",\"2.1. 函数参数与汇编代码\",\"2.2. 函数定义的解析\",\"2.3. 解析参数\",\"2.4. 函数体的解析\",\"3. 代码\",\"4. 小结\",\"由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定义、函数定义、表达式。本章讲解函数定义相关的内容。\",\"手把手教你构建 C 语言编译器系列共有10个部分：\",\"手把手教你构建 C 语言编译器（0）——前言\",\"手把手教你构建 C 语言编译器（1）——设计\",\"手把手教你构建 C 语言编译器（2）——虚拟机\",\"手把手教你构建 C 语言编译器（3）——词法分析器\",\"手把手教你构建 C 语言编译器（4）——递归下降\",\"手把手教你构建 C 语言编译器（5）——变量定义\",\"手把手教你构建 C 语言编译器（6）——函数定义\",\"手把手教你构建 C 语言编译器（7）——语句\",\"手把手教你构建 C 语言编译器（8）——表达式\",\"手把手教你构建 C 语言编译器（9）——总结\"]},\"165\":{\"h\":\"EBNF 表示\",\"t\":[\"这是上一章的 EBNF 方法中与函数定义相关的内容。\",\"variable_decl ::= type {'*'} id { ',' {'*'} id } ';'function_decl ::= type {'*'} id '(' parameter_decl ')' '{' body_decl '}'parameter_decl ::= type {'*'} id {',' type {'*'} id}body_decl ::= {variable_decl}, {statement}statement ::= non_empty_statement | empty_statementnon_empty_statement ::= if_statement | while_statement | '{' statement '}' | 'return' expression | expression ';'if_statement ::= 'if' '(' expression ')' statement ['else' non_empty_statement]while_statement ::= 'while' '(' expression ')' non_empty_statement\"]},\"166\":{\"h\":\"解析函数的定义\",\"t\":[\"上一章的代码中，我们已经知道了什么时候开始解析函数的定义，相关的代码如下：\",\"...if (token == '(') { current_id[Class] = Fun; current_id[Value] = (int)(text + 1); // the memory address of function function_declaration();} else {...\",\"即在这断代码之前，我们已经为当前的标识符（identifier）设置了正确的类型，上面这断代码为当前的标识符设置了正确的类别（Fun），以及该函数在代码段（text segment）中的位置。接下来开始解析函数定义相关的内容：parameter_decl 及 body_decl。\"]},\"167\":{\"h\":\"函数参数与汇编代码\",\"t\":[\"现在我们要回忆如何将“函数”转换成对应的汇编代码，因为这决定了在解析时我们需要哪些相关的信息。考虑下列函数：\",\"int demo(int param_a, int *param_b) { int local_1; char local_2; ...}\",\"那么它应该被转换成什么样的汇编代码呢？在思考这个问题之前，我们需要了解当 demo函数被调用时，计算机的栈的状态，如下（参照第三章讲解的虚拟机）：\",\"| .... | high address+---------------+| arg: param_a | new_bp + 3+---------------+| arg: param_b | new_bp + 2+---------------+|return address | new_bp + 1+---------------+| old BP | <- new BP+---------------+| local_1 | new_bp - 1+---------------+| local_2 | new_bp - 2+---------------+| .... | low address\",\"这里最为重要的一点是，无论是函数的参数（如 param_a）还是函数的局部变量（如 local_1）都是存放在计算机的 栈 上的。因此，与存放在 数据段 中的全局变量不同，在函数内访问它们是通过 new_bp 指针和对应的位移量进行的。因此，在解析的过程中，我们需要知道参数的个数，各个参数的位移量。\"]},\"168\":{\"h\":\"函数定义的解析\",\"t\":[\"这相当于是整个函数定义的语法解析的框架，代码如下：\",\"void function_declaration() { // type func_name (...) {...} // | this part match('('); function_parameter(); match(')'); match('{'); function_body(); //match('}'); // ① // ② // unwind local variable declarations for all local variables. current_id = symbols; while (current_id[Token]) { if (current_id[Class] == Loc) { current_id[Class] = current_id[BClass]; current_id[Type] = current_id[BType]; current_id[Value] = current_id[BValue]; } current_id = current_id + IdSize; }}\",\"其中①中我们没有消耗最后的}字符。这么做的原因是：variable_decl 与 function_decl 是放在一起解析的，而 variable_decl 是以字符 ; 结束的。而 function_decl 是以字符 } 结束的，若在此通过 match 消耗了 ‘;’ 字符，那么外层的 while 循环就没法准确地知道函数定义已经结束。所以我们将结束符的解析放在了外层的 while 循环中。\",\"而②中的代码是用于将符号表中的信息恢复成全局的信息。这是因为，局部变量是可以和全局变量同名的，一旦同名，在函数体内局部变量就会覆盖全局变量，出了函数体，全局变量就恢复了原先的作用。这段代码线性地遍历所有标识符，并将保存在 BXXX 中的信息还原。\"]},\"169\":{\"h\":\"解析参数\",\"t\":[\"parameter_decl ::= type {'*'} id {',' type {'*'} id}\",\"解析函数的参数就是解析以逗号分隔的一个个标识符，同时记录它们的位置与类型。\",\"int index_of_bp; // index of bp pointer on stackvoid function_parameter() { int type; int params; params = 0; while (token != ')') { // ① // int name, ... type = INT; if (token == Int) { match(Int); } else if (token == Char) { type = CHAR; match(Char); } // pointer type while (token == Mul) { match(Mul); type = type + PTR; } // parameter name if (token != Id) { printf(\\\"%d: bad parameter declaration\\\\n\\\", line); exit(-1); } if (current_id[Class] == Loc) { printf(\\\"%d: duplicate parameter declaration\\\\n\\\", line); exit(-1); } match(Id); //② // store the local variable current_id[BClass] = current_id[Class]; current_id[Class] = Loc; current_id[BType] = current_id[Type]; current_id[Type] = type; current_id[BValue] = current_id[Value]; current_id[Value] = params++; // index of current parameter if (token == ',') { match(','); } } // ③ index_of_bp = params+1;}\",\"其中①与全局变量定义的解析十分一样，用于解析该参数的类型。\",\"而②则与上节中提到的“局部变量覆盖全局变量”相关，先将全局变量的信息保存（无论是是否真的在全局中用到了这个变量）在 BXXX 中，再赋上局部变量相关的信息，如 Value 中存放的是参数的位置（是第几个参数）。\",\"③则与汇编代码的生成有关，index_of_bp 就是前文提到的 new_bp 的位置。\"]},\"170\":{\"h\":\"函数体的解析\",\"t\":[\"我们实现的 C 语言与现代的 C 语言不太一致，我们需要所有的变量定义出现在所有的语句之前。函数体的代码如下：\",\"void function_body() { // type func_name (...) {...} // -->| |<-- // ... { // 1. local declarations // 2. statements // } int pos_local; // position of local variables on the stack. int type; pos_local = index_of_bp; // ① while (token == Int || token == Char) { // local variable declaration, just like global ones. basetype = (token == Int) ? INT : CHAR; match(token); while (token != ';') { type = basetype; while (token == Mul) { match(Mul); type = type + PTR; } if (token != Id) { // invalid declaration printf(\\\"%d: bad local declaration\\\\n\\\", line); exit(-1); } if (current_id[Class] == Loc) { // identifier exists printf(\\\"%d: duplicate local declaration\\\\n\\\", line); exit(-1); } match(Id); // store the local variable current_id[BClass] = current_id[Class]; current_id[Class] = Loc; current_id[BType] = current_id[Type]; current_id[Type] = type; current_id[BValue] = current_id[Value]; current_id[Value] = ++pos_local; // index of current parameter if (token == ',') { match(','); } } match(';'); } // ② // save the stack size for local variables *++text = ENT; *++text = pos_local - index_of_bp; // statements while (token != '}') { statement(); } // emit code for leaving the sub function *++text = LEV;}\",\"其中①用于解析函数体内的局部变量的定义，代码与全局的变量定义几乎一样。\",\"而②则用于生成汇编代码，我们在第三章的虚拟机中提到过，我们需要在栈上为局部变量预留空间，这两行代码起的就是这个作用。\"]},\"171\":{\"h\":\"代码\",\"t\":[\"本章的代码可以在 Github 上下载，也可以直接 clone\",\"git clone -b step-4 https://github.com/lotabout/write-a-C-interpreter\",\"本章的代码依旧无法运行，还有两个重要函数没有完成：statement 及 expression，感兴趣的话可以尝试自己实现它们。\"]},\"172\":{\"h\":\"小结\",\"t\":[\"本章中我们用了不多的代码完成了函数定义的解析。大部分的代码依旧是用于解析变量：参数和局部变量，而它们的逻辑和全局变量的解析几乎一致，最大的区别就是保存的信息不同。\",\"当然，要理解函数定义的解析过程，最重要的是理解我们会为函数生成怎样的汇编代码，因为这决定了我们需要从解析中获取什么样的信息（例如参数的位置，个数等），而这些可能需要你重新回顾一下“虚拟机”这一章，或是重新学习学习汇编相关的知识。\",\"下一章中我们将讲解语句的解析，敬请期待。\"]},\"173\":{\"h\":\"手把手教你构建 C 语言编译器（0）- 前言\",\"t\":[\"本文转自 https://lotabout.me/2016/write-a-C-interpreter-7/，如有侵权，请联系删除。\",\"Table of Contents\",\"1. 语句\",\"1.1. IF 语句\",\"1.2. While 语句\",\"1.3. Return 语句\",\"1.4. 其它语句\",\"2. 代码\",\"3. 小结\",\"整个编译器还剩下最后两个部分：语句和表达式的解析。它们的内容比较多，主要涉及如何将语句和表达式编译成汇编代码。这章讲解语句的解析，相对于表达式来说它还是较为容易的。\",\"手把手教你构建 C 语言编译器系列共有10个部分：\",\"手把手教你构建 C 语言编译器（0）——前言\",\"手把手教你构建 C 语言编译器（1）——设计\",\"手把手教你构建 C 语言编译器（2）——虚拟机\",\"手把手教你构建 C 语言编译器（3）——词法分析器\",\"手把手教你构建 C 语言编译器（4）——递归下降\",\"手把手教你构建 C 语言编译器（5）——变量定义\",\"手把手教你构建 C 语言编译器（6）——函数定义\",\"手把手教你构建 C 语言编译器（7）——语句\",\"手把手教你构建 C 语言编译器（8）——表达式\",\"手把手教你构建 C 语言编译器（9）——总结\"]},\"174\":{\"h\":\"语句\",\"t\":[\"C 语言区分“语句”（statement）和“表达式”（expression）两个概念。简单地说，可以认为语句就是表达式加上末尾的分号。\",\"在我们的编译器中共识别 6 种语句：\",\"if (...) <statement> [else <statement>]\",\"while (...) <statement>\",\"{ <statement> }\",\"return xxx;\",\"<empty statement>;\",\"expression; (expression end with semicolon)\",\"它们的语法分析都相对容易，重要的是去理解如何将这些语句编译成汇编代码，下面我们逐一解释。\"]},\"175\":{\"h\":\"IF 语句\",\"t\":[\"IF 语句的作用是跳转，跟据条件表达式决定跳转的位置。我们看看下面的伪代码：\",\"if (...) <statement> [else <statement>] if (<cond>) <cond> JZ a <true_statement> ===> <true_statement> else: JMP ba: a: <false_statement> <false_statement>b: b:\",\"对应的汇编代码流程为：\",\"执行条件表达式 <cond>。\",\"如果条件失败，则跳转到 a 的位置，执行 else 语句。这里 else 语句是可以省略的，此时 a 和 b 都指向 IF 语句后方的代码。\",\"因为汇编代码是顺序排列的，所以如果执行了 true_statement，为了防止因为顺序排列而执行了 false_statement，所以需要无条件跳转 JMP b。\",\"对应的 C 代码如下：\",\"if (token == If) { match(If); match('('); expression(Assign); // parse condition match(')'); *++text = JZ; b = ++text; statement(); // parse statement if (token == Else) { // parse else match(Else); // emit code for JMP B *b = (int)(text + 3); *++text = JMP; b = ++text; statement(); } *b = (int)(text + 1);}\"]},\"176\":{\"h\":\"While 语句\",\"t\":[\"While 语句比 If 语句简单，它对应的汇编代码如下：\",\"a: a: while (<cond>) <cond> JZ b <statement> <statement> JMP ab: b:\",\"没有什么值得说明的内容，它的 C 代码如下：\",\"else if (token == While) { match(While); a = text + 1; match('('); expression(Assign); match(')'); *++text = JZ; b = ++text; statement(); *++text = JMP; *++text = (int)a; *b = (int)(text + 1);}\"]},\"177\":{\"h\":\"Return 语句\",\"t\":[\"Return 唯一特殊的地方是：一旦遇到了 Return 语句，则意味着函数要退出了，所以需要生成汇编代码 LEV 来表示退出。\",\"else if (token == Return) { // return [expression]; match(Return); if (token != ';') { expression(Assign); } match(';'); // emit code for return *++text = LEV;}\"]},\"178\":{\"h\":\"其它语句\",\"t\":[\"其它语句并不直接生成汇编代码，所以不多做说明，代码如下：\",\"else if (token == '{') { // { <statement> ... } match('{'); while (token != '}') { statement(); } match('}');}else if (token == ';') { // empty statement match(';');}else { // a = b; or function_call(); expression(Assign); match(';');}\"]},\"179\":{\"h\":\"代码\",\"t\":[\"本章的代码可以在 Github 上下载，也可以直接 clone\",\"git clone -b step-5 https://github.com/lotabout/write-a-C-interpreter\",\"本章的代码依旧无法运行，还剩最后一部分没有完成：expression。\"]},\"180\":{\"h\":\"小结\",\"t\":[\"本章讲解了如何将语句编译成汇编代码，内容相对容易一些，关键就是去理解汇编代码的执行原理。\",\"同时值得一提的是，编译器的语法分析部分其实是很简单的，而真正的难点是如何在语法分析时收集足够多的信息，最终把源代码转换成目标代码（汇编）。我认为这也是初学者实现编译器的一大难点，往往比词法分析/语法分析更困难。\",\"所以建议如果没有学过汇编，可以学习学习，它本身不难，但对理解计算机的原理有很大帮助。\"]},\"181\":{\"h\":\"手把手教你构建 C 语言编译器（0）- 前言\",\"t\":[\"本文转自 https://blog.csdn.net/xzp740813/article/details/142961332?spm=1001.2014.3001.5501，如有侵权，请联系删除。\",\"Table of Contents\",\"1. 运算符的优先级\",\"2. 一元运算符\",\"2.1. 常量\",\"2.2. sizeof\",\"2.3. 变量与函数调用\",\"2.4. 强制转换\",\"2.5. 指针取值\",\"2.6. 取址操作\",\"2.7. 逻辑取反\",\"2.8. 按位取反\",\"2.9. 正负号\",\"2.10. 自增自减\",\"3. 二元运算符\",\"3.1. 赋值操作\",\"3.2. 三目运算符\",\"3.3. 逻辑运算符\",\"3.4. 数学运算符\",\"3.5. 自增自减\",\"3.6. 数组取值操作\",\"4. 代码\",\"5. 小结\",\"这是整个编译器的最后一部分，解析表达式。什么是表达式？表达式是将各种语言要素的一个组合，用来求值。例如：函数调用、变量赋值、运算符运算等等。\",\"表达式的解析难点有二：一是运算符的优先级问题，二是如何将表达式编译成目标代码。我们就来逐一说明。\",\"手把手教你构建 C 语言编译器系列共有10个部分：\",\"手把手教你构建 C 语言编译器（0）——前言\",\"手把手教你构建 C 语言编译器（1）——设计\",\"手把手教你构建 C 语言编译器（2）——虚拟机\",\"手把手教你构建 C 语言编译器（3）——词法分析器\",\"手把手教你构建 C 语言编译器（4）——递归下降\",\"手把手教你构建 C 语言编译器（5）——变量定义\",\"手把手教你构建 C 语言编译器（6）——函数定义\",\"手把手教你构建 C 语言编译器（7）——语句\",\"手把手教你构建 C 语言编译器（8）——表达式\",\"手把手教你构建 C 语言编译器（9）——总结\"]},\"182\":{\"h\":\"运算符的优先级\",\"t\":[\"运算符的优先级决定了表达式的运算顺序，如在普通的四则运算中，乘法 * 优先级高于加法 +，这就意味着表达式 2 + 3 * 4 的实际运行顺序是 2 + (3 * 4) 而不是 (2 + 3) * 4。\",\"C 语言定义了各种表达式的优先级，可以参考 C 语言运算符优先级。\",\"传统的编程书籍会用“逆波兰式”实现四则运算来讲解优先级问题。实际上，优先级关心的就是哪个运算符先计算，哪个运算符后计算（毕竟叫做“优先级”嘛）。而这就意味着我们需要决定先为哪个运算符生成目标代码（汇编），因为汇编代码是顺序排列的，我们必须先计算优先级高的运算符。\",\"那么如何确定运算符的优先级呢？答曰：栈（递归调用的实质也是栈的处理）。\",\"举一个例子：2 + 3 - 4 * 5，它的运算顺序是这样的：\",\"将 2 入栈\",\"遇到运算符 +，入栈，此时我们期待的是+的另一个参数\",\"遇到数字 3，原则上我们需要立即计算 2+3的值，但我们不确定数字 3 是否属于优先级更高的运算符，所以先将它入栈。\",\"遇到运算符 -，它的优先级和 + 相同，此时判断参数 3 属于这前的 +。将运算符 + 出栈，并将之前的 2 和 3 出栈，计算 2+3 的结果，得到 5 入栈。同时将运算符 - 入栈。\",\"遇到数字4，同样不能确定是否能立即计算，入栈\",\"遇到运算符 * 优先级大于 -，入栈\",\"遇到数字5，依旧不能确定是否立即计算，入栈\",\"表达式结束，运算符出栈，为 *，将参数出栈，计算 4*5 得到结果 20 入栈。\",\"运算符出栈，为 -，将参数出栈，计算 5-20，得到 -15 入栈。\",\"此时运算符栈为空，因此得到结果 -15。\",\"// after step 1, 2| |+------+| 3 | | |+------+ +------+| 2 | | + |+------+ +------+// after step 4| | | |+------+ +------+| 5 | | - |+------+ +------+// after step 7| |+------+| 5 |+------+ +------+| 4 | | * |+------+ +------+| 5 | | - |+------+ +------+\",\"综上，在计算一个运算符‘x’之前，必须先查看它的右方，找出并计算所有优先级大于‘x’的运算符，之后再计算运算符‘x’。\",\"最后注意的是优先通常只与多元运算符相关，单元运算符往往没有这个问题（因为只有一个参数）。也可以认为“优先级”的实质就是两个运算符在抢参数。\"]},\"183\":{\"h\":\"一元运算符\",\"t\":[\"上节中说到了运算符的优先级，也提到了优先级一般只与多元运算符有关，这也意味着一元运算符的优先级总是高于多元运算符。因为我们需要先对它们进行解析。\",\"当然，这部分也将同时解析参数本身（如变量、数字、字符串等等）。\",\"关于表达式的解析，与语法分析相关的部分就是上文所说的优先级问题了，而剩下的较难较烦的部分是与目标代码的生成有关的。因此对于需要讲解的运算符，我们主要从它的目标代码入手。\"]},\"184\":{\"h\":\"常量\",\"t\":[\"首先是数字，用 IMM 指令将它加载到 AX 中即可：\",\"if (token == Num) { match(Num); // emit code *++text = IMM; *++text = token_val; expr_type = INT;}\",\"接着是字符串常量。它比较特殊的一点是 C 语言的字符串常量支持如下风格：\",\"char *p;p = \\\"first line\\\" \\\"second line\\\";\",\"即跨行的字符串拼接，它相当于：\",\"char *p;p = \\\"first linesecond line\\\";\",\"所以解析的时候要注意这一点：\",\"else if (token == '\\\"') { // emit code *++text = IMM; *++text = token_val; match('\\\"'); // store the rest strings while (token == '\\\"') { match('\\\"'); } // append the end of string character '\\\\0', all the data are default // to 0, so just move data one position forward. data = (char *)(((int)data + sizeof(int)) & (-sizeof(int))); expr_type = PTR;}\"]},\"185\":{\"h\":\"sizeof\",\"t\":[\"sizeof 是一个一元运算符，我们需要知道后面参数的类型，类型的解析在前面的文章中我们已经很熟悉了。\",\"else if (token == Sizeof) { // sizeof is actually an unary operator // now only `sizeof(int)`, `sizeof(char)` and `sizeof(*...)` are // supported. match(Sizeof); match('('); expr_type = INT; if (token == Int) { match(Int); } else if (token == Char) { match(Char); expr_type = CHAR; } while (token == Mul) { match(Mul); expr_type = expr_type + PTR; } match(')'); // emit code *++text = IMM; *++text = (expr_type == CHAR) ? sizeof(char) : sizeof(int); expr_type = INT;}\",\"注意的是只支持 sizeof(int)，sizeof(char) 及 sizeof(pointer type...)。并且它的结果是 int 型。\"]},\"186\":{\"h\":\"变量与函数调用\",\"t\":[\"由于取变量的值与函数的调用都是以 Id 标记开头的，因此将它们放在一起处理。\",\"else if (token == Id) { // there are several type when occurs to Id // but this is unit, so it can only be // 1. function call // 2. Enum variable // 3. global/local variable match(Id); id = current_id; if (token == '(') { // function call match('('); // ① // pass in arguments tmp = 0; // number of arguments while (token != ')') { expression(Assign); *++text = PUSH; tmp ++; if (token == ',') { match(','); } } match(')'); // ② // emit code if (id[Class] == Sys) { // system functions *++text = id[Value]; } else if (id[Class] == Fun) { // function call *++text = CALL; *++text = id[Value]; } else { printf(\\\"%d: bad function call\\\\n\\\", line); exit(-1); } // ③ // clean the stack for arguments if (tmp > 0) { *++text = ADJ; *++text = tmp; } expr_type = id[Type]; } else if (id[Class] == Num) { // ④ // enum variable *++text = IMM; *++text = id[Value]; expr_type = INT; } else { // ⑤ // variable if (id[Class] == Loc) { *++text = LEA; *++text = index_of_bp - id[Value]; } else if (id[Class] == Glo) { *++text = IMM; *++text = id[Value]; } else { printf(\\\"%d: undefined variable\\\\n\\\", line); exit(-1); } //⑥ // emit code, default behaviour is to load the value of the // address which is stored in `ax` expr_type = id[Type]; *++text = (expr_type == Char) ? LC : LI; }}\",\"①中注意我们是顺序将参数入栈，这和第三章：虚拟机中讲解的指令是对应的。与之不同，标准 C 是逆序将参数入栈的。\",\"②中判断函数的类型，同样在第三章：“虚拟机”中我们介绍过内置函数的支持，如 printf, read, malloc 等等。内置函数有对应的汇编指令，而普通的函数则编译成 CALL <addr> 的形式。\",\"③用于清除入栈的参数。因为我们不在乎出栈的值，所以直接修改栈指针的大小即可。\",\"④：当该标识符是全局定义的枚举类型时，直接将对应的值用 IMM 指令存入 AX 即可。\",\"⑤则是用于加载变量的值，如果是局部变量则采用与 bp 指针相对位置的形式（参见第 7章函数定义）。而如果是全局变量则用 IMM 加载变量的地址。\",\"⑥：无论是全局还是局部变量，最终都根据它们的类型用 LC 或 LI 指令加载对应的值。\",\"关于变量，你可能有疑问，如果遇到标识符就用 LC/LI 载入相应的值，那诸如 a[10] 之类的表达式要如何实现呢？后面我们会看到，根据标识符后的运算符，我们可能会修改或删除现有的 LC/LI 指令。\"]},\"187\":{\"h\":\"强制转换\",\"t\":[\"虽然我们前面没有提到，但我们一直用 expr_type 来保存一个表达式的类型，强制转换的作用是获取转换的类型，并直接修改 expr_type 的值。\",\"else if (token == '(') { // cast or parenthesis match('('); if (token == Int || token == Char) { tmp = (token == Char) ? CHAR : INT; // cast type match(token); while (token == Mul) { match(Mul); tmp = tmp + PTR; } match(')'); expression(Inc); // cast has precedence as Inc(++) expr_type = tmp; } else { // normal parenthesis expression(Assign); match(')'); }}\"]},\"188\":{\"h\":\"指针取值\",\"t\":[\"诸如 *a 的指针取值，关键是判断 a 的类型，而就像上节中提到的，当一个表达式解析结束时，它的类型保存在变量 expr_type 中。\",\"else if (token == Mul) { // dereference *<addr> match(Mul); expression(Inc); // dereference has the same precedence as Inc(++) if (expr_type >= PTR) { expr_type = expr_type - PTR; } else { printf(\\\"%d: bad dereference\\\\n\\\", line); exit(-1); } *++text = (expr_type == CHAR) ? LC : LI;}\"]},\"189\":{\"h\":\"取址操作\",\"t\":[\"这里我们就能看到“变量与函数调用”一节中所说的修改或删除 LC/LI 指令了。前文中我们说到，对于变量，我们会先加载它的地址，并根据它们类型使用 LC/LI 指令加载实际内容，例如对变量 a：\",\"IMM <addr>LI\",\"那么对变量 a 取址，其实只要不执行 LC/LI 即可。因此我们删除相应的指令。\",\"else if (token == And) { // get the address of match(And); expression(Inc); // get the address of if (*text == LC || *text == LI) { text --; } else { printf(\\\"%d: bad address of\\\\n\\\", line); exit(-1); } expr_type = expr_type + PTR;}\"]},\"190\":{\"h\":\"逻辑取反\",\"t\":[\"我们没有直接的逻辑取反指令，因此我们判断它是否与数字 0 相等。而数字 0 代表了逻辑 “False”。\",\"else if (token == '!') { // not match('!'); expression(Inc); // emit code, use <expr> == 0 *++text = PUSH; *++text = IMM; *++text = 0; *++text = EQ; expr_type = INT;}\"]},\"191\":{\"h\":\"按位取反\",\"t\":[\"同样我们没有相应的指令，所以我们用异或来实现，即 ~a = a ^ 0xFFFF。\",\"else if (token == '~') { // bitwise not match('~'); expression(Inc); // emit code, use <expr> XOR -1 *++text = PUSH; *++text = IMM; *++text = -1; *++text = XOR; expr_type = INT;}\"]},\"192\":{\"h\":\"正负号\",\"t\":[\"注意这里并不是四则运算中的加减法，而是单个数字的取正取负操作。同样，我们没有取负的操作，用 0 - x 来实现 -x。\",\"else if (token == Add) { // +var, do nothing match(Add); expression(Inc); expr_type = INT;}else if (token == Sub) { // -var match(Sub); if (token == Num) { *++text = IMM; *++text = -token_val; match(Num); } else { *++text = IMM; *++text = -1; *++text = PUSH; expression(Inc); *++text = MUL; } expr_type = INT;}\"]},\"193\":{\"h\":\"自增自减\",\"t\":[\"注意的是自增自减操作的优先级是和它的位置有关的。如 ++p 的优先级高于 p++，这里我们解析的就是类似 ++p 的操作。\",\"else if (token == Inc || token == Dec) { tmp = token; match(token); expression(Inc); // ① if (*text == LC) { *text = PUSH; // to duplicate the address *++text = LC; } else if (*text == LI) { *text = PUSH; *++text = LI; } else { printf(\\\"%d: bad lvalue of pre-increment\\\\n\\\", line); exit(-1); } *++text = PUSH; *++text = IMM; // ② *++text = (expr_type > PTR) ? sizeof(int) : sizeof(char); *++text = (tmp == Inc) ? ADD : SUB; *++text = (expr_type == CHAR) ? SC : SI;}\",\"对应的汇编代码也比较直观，只是在实现 ++p时，我们要使用变量 p 的地址两次，所以我们需要先 PUSH （①）。\",\"②则是因为自增自减操作还需要处理是指针的情形。\"]},\"194\":{\"h\":\"二元运算符\",\"t\":[\"这里，我们需要处理多运算符的优先级问题，就如前文的“优先级”一节提到的，我们需要不断地向右扫描，直到遇到优先级 小于 当前优先级的运算符。\",\"回想起我们之前定义过的各个标记，它们是以优先级从低到高排列的，即 Assign 的优先级最低，而 Brak（[） 的优先级最高。\",\"enum { Num = 128, Fun, Sys, Glo, Loc, Id, Char, Else, Enum, If, Int, Return, Sizeof, While, Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak};\",\"所以，当我们调用 expression(level) 进行解析的时候，我们其实通过了参数 level 指定了当前的优先级。在前文的一元运算符处理中也用到了这一点。\",\"所以，此时的二元运算符的解析的框架为：\",\"while (token >= level) { // parse token for binary operator and postfix operator}\",\"解决了优先级的问题，让我们继续讲解如何把运算符编译成汇编代码吧。\"]},\"195\":{\"h\":\"赋值操作\",\"t\":[\"赋值操作是优先级最低的运算符。考虑诸如 a = (expession) 的表达式，在解析 = 之前，我们已经为变量 a 生成了如下的汇编代码：\",\"IMM <addr>LC/LI\",\"当解析完=右边的表达式后，相应的值会存放在 ax 中，此时，为了实际将这个值保存起来，我们需要类似下面的汇编代码：\",\"IMM <addr>PUSHSC/SI\",\"明白了这点，也就能理解下面的源代码了：\",\"tmp = expr_type;if (token == Assign) { // var = expr; match(Assign); if (*text == LC || *text == LI) { *text = PUSH; // save the lvalue's pointer } else { printf(\\\"%d: bad lvalue in assignment\\\\n\\\", line); exit(-1); } expression(Assign); expr_type = tmp; *++text = (expr_type == CHAR) ? SC : SI;}\"]},\"196\":{\"h\":\"三目运算符\",\"t\":[\"这是 C 语言中唯一的一个三元运算符： ? :，它相当于一个小型的 If 语句，所以生成的代码也类似于 If 语句，这里就不多作解释。\",\"else if (token == Cond) { // expr ? a : b; match(Cond); *++text = JZ; addr = ++text; expression(Assign); if (token == ':') { match(':'); } else { printf(\\\"%d: missing colon in conditional\\\\n\\\", line); exit(-1); } *addr = (int)(text + 3); *++text = JMP; addr = ++text; expression(Cond); *addr = (int)(text + 1);}\"]},\"197\":{\"h\":\"逻辑运算符\",\"t\":[\"这包括 || 和 &&。它们对应的汇编代码如下：\",\"<expr1> || <expr2> <expr1> && <expr2> ...<expr1>... ...<expr1>... JNZ b JZ b ...<expr2>... ...<expr2>...b: b:\",\"所以源码如下：\",\"else if (token == Lor) { // logic or match(Lor); *++text = JNZ; addr = ++text; expression(Lan); *addr = (int)(text + 1); expr_type = INT;}else if (token == Lan) { // logic and match(Lan); *++text = JZ; addr = ++text; expression(Or); *addr = (int)(text + 1); expr_type = INT;}\"]},\"198\":{\"h\":\"数学运算符\",\"t\":[\"它们包括 |, ^, &, ==, !=<=, >=, <, >, <<, >>, +, -, *, /, %。它们的实现都很类似，我们以异或 ^ 为例：\",\"<expr1> ^ <expr2>...<expr1>... <- now the result is on axPUSH...<expr2>... <- now the value of <expr2> is on axXOR\",\"所以它对应的代码为：\",\"else if (token == Xor) { // bitwise xor match(Xor); *++text = PUSH; expression(And); *++text = XOR; expr_type = INT;}\",\"其它的我们便不再详述。但这当中还有一个问题，就是指针的加减。在 C 语言中，指针加上数值等于将指针移位，且根据不同的类型移动的位移不同。如 a + 1，如果 a 是 char * 型，则移动一字节，而如果 a 是 int * 型，则移动 4 个字节（32位系统）。\",\"另外，在作指针减法时，如果是两个指针相减（相同类型），则结果是两个指针间隔的元素个数。因此要有特殊的处理。\",\"下面以加法为例，对应的汇编代码为：\",\"<expr1> + <expr2>normal pointer<expr1> <expr1>PUSH PUSH<expr2> <expr2> |ADD PUSH | <expr2> * <unit> IMM <unit> | MUL | ADD\",\"即当 <expr1> 是指针时，要根据它的类型放大 <expr2> 的值，因此对应的源码如下：\",\"else if (token == Add) { // add match(Add); *++text = PUSH; expression(Mul); expr_type = tmp; if (expr_type > PTR) { // pointer type, and not `char *` *++text = PUSH; *++text = IMM; *++text = sizeof(int); *++text = MUL; } *++text = ADD;}\",\"相应的减法的代码就不贴了，可以自己实现看看，也可以看文末给出的链接。\"]},\"199\":{\"h\":\"自增自减\",\"t\":[\"这次是后缀形式的，即 p++ 或 p--。与前缀形式不同的是，在执行自增自减后， ax上需要保留原来的值。所以我们首先执行类似前缀自增自减的操作，再将 ax 中的值执行减/增的操作。\",\"// 前缀形式 生成汇编代码*++text = PUSH;*++text = IMM;*++text = (expr_type > PTR) ? sizeof(int) : sizeof(char);*++text = (tmp == Inc) ? ADD : SUB;*++text = (expr_type == CHAR) ? SC : SI;// 后缀形式 生成汇编代码*++text = PUSH;*++text = IMM;*++text = (expr_type > PTR) ? sizeof(int) : sizeof(char);*++text = (token == Inc) ? ADD : SUB;*++text = (expr_type == CHAR) ? SC : SI;*++text = PUSH; //*++text = IMM; // 执行相反的增/减操作*++text = (expr_type > PTR) ? sizeof(int) : sizeof(char); //*++text = (token == Inc) ? SUB : ADD; //\"]},\"200\":{\"h\":\"数组取值操作\",\"t\":[\"在学习 C 语言的时候你可能已经知道了，诸如 a[10] 的操作等价于 *(a + 10)。因此我们要做的就是生成类似的汇编代码：\",\"else if (token == Brak) { // array access var[xx] match(Brak); *++text = PUSH; expression(Assign); match(']'); if (tmp > PTR) { // pointer, `not char *` *++text = PUSH; *++text = IMM; *++text = sizeof(int); *++text = MUL; } else if (tmp < PTR) { printf(\\\"%d: pointer type expected\\\\n\\\", line); exit(-1); } expr_type = tmp - PTR; *++text = ADD; *++text = (expr_type == CHAR) ? LC : LI;}\"]},\"201\":{\"h\":\"代码\",\"t\":[\"除了上述对表达式的解析外，我们还需要初始化虚拟机的栈，我们可以正确调用 main 函数，且当 main 函数结束时退出进程。\",\"int *tmp;// setup stacksp = (int *)((int)stack + poolsize);*--sp = EXIT; // call exit if main returns*--sp = PUSH; tmp = sp;*--sp = argc;*--sp = (int)argv;*--sp = (int)tmp;\",\"当然，最后要注意的一点是：所有的变量定义必须放在语句之前。\",\"本章的代码可以在 Github 上下载，也可以直接 clone\",\"git clone -b step-6 https://github.com/lotabout/write-a-C-interpreter\",\"通过 gcc -o xc-tutor xc-tutor.c 进行编译。并执行 ./xc-tutor hello.c 查看结果。\",\"正如我们保证的那样，我们的代码是自举的，能自己编译自己，所以你可以执行 ./xc-tutor xc-tutor.c hello.c。可以看到和之前有同样的输出。\"]},\"202\":{\"h\":\"小结\",\"t\":[\"本章我们进行了最后的解析，解析表达式。本章有两个难点：\",\"如何通过递归调用 expression 来实现运算符的优先级。\",\"如何为每个运算符生成对应的汇编代码。\",\"尽管代码看起来比较简单（虽然多），但其中用到的原理还是需要仔细推敲的。\",\"最后，恭喜你！通过一步步的学习，自己实现了一个C语言的编译器（好吧，是解释器）。\"]},\"203\":{\"h\":\"手把手教你构建 C 语言编译器（0）- 前言\",\"t\":[\"本文转自 https://lotabout.me/2016/write-a-C-interpreter-9/，如有侵权，请联系删除。\",\"Table of Contents\",\"1. 虚拟机与目标代码\",\"2. 词法分析\",\"3. 语法分析\",\"4. 关于编代码\",\"5. 结语\",\"恭喜你完成了自己的 C 语言编译器，本章中我们发一发牢骚，说一说编写编译器值得注意的一些问题；编写编译器时遇到的一些难题。\",\"手把手教你构建 C 语言编译器系列共有10个部分：\",\"手把手教你构建 C 语言编译器（0）——前言\",\"手把手教你构建 C 语言编译器（1）——设计\",\"手把手教你构建 C 语言编译器（2）——虚拟机\",\"手把手教你构建 C 语言编译器（3）——词法分析器\",\"手把手教你构建 C 语言编译器（4）——递归下降\",\"手把手教你构建 C 语言编译器（5）——变量定义\",\"手把手教你构建 C 语言编译器（6）——函数定义\",\"手把手教你构建 C 语言编译器（7）——语句\",\"手把手教你构建 C 语言编译器（8）——表达式\",\"手把手教你构建 C 语言编译器（9）——总结\"]},\"204\":{\"h\":\"虚拟机与目标代码\",\"t\":[\"整个系列的一开始，我们就着手虚拟机的实现。不知道你是否有同感，这部分对于整个编译器的编写其实是十分重要的。我认为至少占了重要程度的50%。\",\"这里要说明这样一个观点，学习编译原理时常常着眼于词法分析和语法分析，而忽略了同样重要的代码生成。对于学习或考试而言或许可以，但实际编译项目时，最为重要的是能“跑起来”，所以我们需要给予代码生成高度的重视。\",\"同时我们也看到，在后期解析语句和表达式时，难点已经不再是语法分析了，而是如何为运算符生成相应的汇编代码。\"]},\"205\":{\"h\":\"词法分析\",\"t\":[\"我们用了很暴力的手段编写了我们的词法分析器，我认为这并无不可。\",\"但你依旧可以学习相关的知识，了解自动生成词法分析器的原理，它涉及到了“正则表达式”，“状态机”等等知识。相信这部分的知识能够很大程度上提高你的编程水平。\",\"同时，如果今后你仍然想编写编译器，不妨试试这些自动生成工具。\"]},\"206\":{\"h\":\"语法分析\",\"t\":[\"长期以来，语法分析对我而言一直是迷一样的存在，直到真正用递归下降的方式实现了一个。\",\"我们用了专门的一章讲解了“递归下降”与 BNF 文法的关系。希望能减少你对理论的厌恶。至少，实现起来并不是太难。\",\"如果有兴趣，可以学习学习这些文法，因为已经有许多自动生成的工具支持它们。这样你就不需要重复造轮子。可以看看 yacc 等工具，更先进的版本是 bsion。同时其它语言也有许多类似的支持。\",\"题外话，最近知道了一个叫“PEG 文法”的表示方法，无论是读起来，还是实现起来，都比 BNF 要容易，你也可以学习看看。\"]},\"207\":{\"h\":\"关于编代码\",\"t\":[\"这也是我自己的感慨吧。无论多好的教程，想要完全理解它，最好的方式恐怕还是要自己实现它。\",\"只是在编写代码的过程中，我们会遇到许多的挫折，例如需要考虑许多细节，或是调试起来十分困难。但也只有真正静下心来去克服它，我们才能有所成长吧。\",\"例如在编写表达式的解析时，大量重复的代码特别让人崩溃。还有就是调试编译器，简直痛苦地无话可说。\",\"P.S. 如果你按这个系列自己编写代码，记得事先写一些用于输出汇编代码的函数，很有帮助的。\",\"还有就是写这个系列的文章，开始的冲动过了之后，每写一篇都特别心烦，希望文章本身没有受我的这种情绪影响吧。\"]},\"208\":{\"h\":\"结语\",\"t\":[\"编程有趣又无趣，只有身在其中的我们才能体会吧。\"]},\"209\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"210\":{\"h\":\"Design ASimpile CCompiler\"}},\"dirtCount\":0,\"index\":[[\"开始的冲动过了之后\",{\"1\":{\"207\":1}}],[\"开头\",{\"1\":{\"138\":1}}],[\"想要完全理解它\",{\"1\":{\"207\":1}}],[\"想做一个一样的移动app\",{\"1\":{\"84\":1}}],[\"题外话\",{\"1\":{\"206\":1}}],[\"至少\",{\"1\":{\"206\":1}}],[\"希望文章本身没有受我的这种情绪影响吧\",{\"1\":{\"207\":1}}],[\"希望能减少你对理论的厌恶\",{\"1\":{\"206\":1}}],[\"希望通过本章的学习\",{\"1\":{\"130\":1}}],[\"希望通过这个系列\",{\"1\":{\"103\":1}}],[\"长期以来\",{\"1\":{\"206\":1}}],[\"难点已经不再是语法分析了\",{\"1\":{\"204\":1}}],[\"难以调试\",{\"1\":{\"107\":1}}],[\"跑起来\",{\"1\":{\"204\":1}}],[\"说一说编写编译器值得注意的一些问题\",{\"1\":{\"203\":1}}],[\"说得通俗一点就是自己实现一套汇编语言\",{\"1\":{\"113\":1}}],[\"恭喜你完成了自己的\",{\"1\":{\"203\":1}}],[\"恭喜你\",{\"1\":{\"202\":1}}],[\"查看结果\",{\"1\":{\"201\":1}}],[\"查找已有标识符的方法是线性查找\",{\"1\":{\"139\":1}}],[\"减操作\",{\"1\":{\"199\":1}}],[\"减少程序的体积\",{\"1\":{\"115\":1}}],[\"增的操作\",{\"1\":{\"199\":1}}],[\"增加\",{\"1\":{\"129\":1}}],[\"增加指令会消耗许多资源\",{\"1\":{\"122\":1}}],[\"增加请求头和cookie的大小限制\",{\"1\":{\"16\":1}}],[\"明白了这点\",{\"1\":{\"195\":1}}],[\"回想起我们之前定义过的各个标记\",{\"1\":{\"194\":1}}],[\"回到并发竞争带来的安全问题上\",{\"1\":{\"92\":1}}],[\"小于\",{\"1\":{\"194\":1}}],[\"小结\",{\"0\":{\"130\":1,\"146\":1,\"154\":1,\"163\":1,\"172\":1,\"180\":1,\"202\":1},\"1\":{\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1}}],[\"代表了逻辑\",{\"1\":{\"190\":1}}],[\"代码与全局的变量定义几乎一样\",{\"1\":{\"170\":1}}],[\"代码较多\",{\"1\":{\"143\":1}}],[\"代码如下\",{\"1\":{\"116\":1,\"119\":1,\"128\":1,\"159\":1,\"168\":1,\"175\":1,\"176\":1,\"178\":1}}],[\"代码段\",{\"1\":{\"115\":2}}],[\"代码\",{\"0\":{\"145\":1,\"162\":1,\"171\":1,\"179\":1,\"201\":1},\"1\":{\"114\":1,\"131\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1}}],[\"代码难免会有错误\",{\"1\":{\"108\":1}}],[\"代码优化\",{\"1\":{\"105\":1}}],[\"代码的生成\",{\"1\":{\"105\":1}}],[\"代码是否高效显得就不那么重要了\",{\"1\":{\"104\":1}}],[\"诸如\",{\"1\":{\"188\":1,\"200\":1}}],[\"载入相应的值\",{\"1\":{\"186\":1}}],[\"加载变量的地址\",{\"1\":{\"186\":1}}],[\"加法保序性\",{\"0\":{\"63\":1}}],[\"加法消去律\",{\"0\":{\"55\":1},\"1\":{\"55\":1}}],[\"加法结合律\",{\"0\":{\"54\":1}}],[\"加法结果的唯一性\",{\"0\":{\"51\":1}}],[\"加法结果的存在性\",{\"0\":{\"50\":1}}],[\"加法交换律\",{\"0\":{\"53\":1}}],[\"加法的性质\",{\"0\":{\"52\":1}}],[\"加法的定义\",{\"0\":{\"49\":1}}],[\"⑥\",{\"1\":{\"186\":2}}],[\"⑤则是用于加载变量的值\",{\"1\":{\"186\":1}}],[\"⑤\",{\"1\":{\"186\":1}}],[\"④\",{\"1\":{\"186\":2}}],[\"单元运算符往往没有这个问题\",{\"1\":{\"182\":1}}],[\"单核处理器还是同时间只能做一件事\",{\"1\":{\"91\":1}}],[\"单核处理器本来就没法同时处理两件事情\",{\"1\":{\"89\":1}}],[\"单核同时间内只能有一个线程运行\",{\"1\":{\"89\":1}}],[\"找出并计算所有优先级大于\",{\"1\":{\"182\":1}}],[\"必须先查看它的右方\",{\"1\":{\"182\":1}}],[\"必须先获得gil锁\",{\"1\":{\"90\":1}}],[\"依旧不能确定是否立即计算\",{\"1\":{\"182\":1}}],[\"依旧帮助不了我们学习编译器\",{\"1\":{\"105\":1}}],[\"属于这前的\",{\"1\":{\"182\":1}}],[\"入栈\",{\"1\":{\"182\":9}}],[\"入度为\",{\"1\":{\"76\":1}}],[\"举一个例子\",{\"1\":{\"182\":1}}],[\"答曰\",{\"1\":{\"182\":1}}],[\"嘛\",{\"1\":{\"182\":1}}],[\"毕竟叫做\",{\"1\":{\"182\":1}}],[\"毕竟我们不是真正的计算机\",{\"1\":{\"122\":1}}],[\"哪个运算符后计算\",{\"1\":{\"182\":1}}],[\"逆波兰式\",{\"1\":{\"182\":1}}],[\"优先级大于\",{\"1\":{\"182\":1}}],[\"优先级\",{\"1\":{\"182\":2,\"194\":1}}],[\"优先级关心的就是哪个运算符先计算\",{\"1\":{\"182\":1}}],[\"优先级高于加法\",{\"1\":{\"182\":1}}],[\"优雅的解决方案\",{\"1\":{\"1\":1}}],[\"赋值操作是优先级最低的运算符\",{\"1\":{\"195\":1}}],[\"赋值操作\",{\"0\":{\"195\":1},\"1\":{\"181\":1}}],[\"按位取反\",{\"0\":{\"191\":1},\"1\":{\"181\":1}}],[\"强制转换的作用是获取转换的类型\",{\"1\":{\"187\":1}}],[\"强制转换\",{\"0\":{\"187\":1},\"1\":{\"181\":1}}],[\"常量\",{\"0\":{\"184\":1},\"1\":{\"181\":1}}],[\"往往比词法分析\",{\"1\":{\"180\":1}}],[\"执行相反的增\",{\"1\":{\"199\":1}}],[\"执行\",{\"1\":{\"175\":1}}],[\"执行条件表达式\",{\"1\":{\"175\":1}}],[\"执行过程本身就是安全的\",{\"1\":{\"93\":1}}],[\"跟据条件表达式决定跳转的位置\",{\"1\":{\"175\":1}}],[\"跟它们在\",{\"1\":{\"135\":1}}],[\"种语句\",{\"1\":{\"174\":1}}],[\"感兴趣的话可以尝试自己实现它们\",{\"1\":{\"171\":1}}],[\"先将全局变量的信息保存\",{\"1\":{\"169\":1}}],[\"先介绍\",{\"1\":{\"47\":1}}],[\"局部变量覆盖全局变量\",{\"1\":{\"169\":1}}],[\"局部变量是可以和全局变量同名的\",{\"1\":{\"168\":1}}],[\"③用于清除入栈的参数\",{\"1\":{\"186\":1}}],[\"③则与汇编代码的生成有关\",{\"1\":{\"169\":1}}],[\"③\",{\"1\":{\"169\":1,\"186\":1}}],[\"全局变量就恢复了原先的作用\",{\"1\":{\"168\":1}}],[\"全局变量或局部变量等\",{\"1\":{\"139\":1}}],[\"出栈\",{\"1\":{\"182\":2}}],[\"出了函数体\",{\"1\":{\"168\":1}}],[\"出题人不愿意写一个确定精度的\",{\"1\":{\"36\":1}}],[\"消耗了\",{\"1\":{\"168\":1}}],[\"消除左递归的相关方法\",{\"1\":{\"152\":1}}],[\"消除后的文法如下\",{\"1\":{\"152\":1}}],[\"②则是因为自增自减操作还需要处理是指针的情形\",{\"1\":{\"193\":1}}],[\"②中判断函数的类型\",{\"1\":{\"186\":1}}],[\"②\",{\"1\":{\"168\":1,\"169\":1,\"170\":1,\"186\":1,\"193\":1}}],[\"①中注意我们是顺序将参数入栈\",{\"1\":{\"186\":1}}],[\"①\",{\"1\":{\"168\":1,\"169\":1,\"170\":1,\"186\":1,\"193\":2}}],[\"各个参数的位移量\",{\"1\":{\"167\":1}}],[\"各种编程语言关于如何调用子函数有不同的约定\",{\"1\":{\"122\":1}}],[\"接下来开始解析函数定义相关的内容\",{\"1\":{\"166\":1}}],[\"接着是字符串常量\",{\"1\":{\"184\":1}}],[\"接着\",{\"1\":{\"115\":1}}],[\"敬请期待\",{\"1\":{\"163\":1,\"172\":1}}],[\"敬请批评指正\",{\"1\":{\"108\":1}}],[\"剩下的内容就是按部就班地将\",{\"1\":{\"163\":1}}],[\"值得注意的是在编译器中如何保存枚举变量的信息\",{\"1\":{\"160\":1}}],[\"`not\",{\"1\":{\"200\":1}}],[\"`char\",{\"1\":{\"198\":1}}],[\"`ax`\",{\"1\":{\"186\":1}}],[\"`sizeof\",{\"1\":{\"185\":3}}],[\"`\",{\"1\":{\"159\":1,\"185\":3,\"198\":1,\"200\":1}}],[\"`int\",{\"1\":{\"159\":1}}],[\"`main`\",{\"1\":{\"144\":1}}],[\"包括变量定义\",{\"1\":{\"159\":1}}],[\"包括编程\",{\"1\":{\"34\":1}}],[\"亏我们说了一章的递归下降\",{\"1\":{\"156\":1}}],[\"主要涉及如何将语句和表达式编译成汇编代码\",{\"1\":{\"173\":1}}],[\"主要的逻辑用于解析用逗号\",{\"1\":{\"160\":1}}],[\"主要原因是我们的语言不支持跨函数递归\",{\"1\":{\"156\":1}}],[\"主动释放使用权\",{\"1\":{\"92\":1}}],[\"主动\",{\"1\":{\"92\":1}}],[\"主动让出使用权\",{\"1\":{\"92\":1}}],[\"主动让出时间片的协程模式比线程抢占式分配的效率要好\",{\"1\":{\"91\":1}}],[\"主动切换了使用权\",{\"1\":{\"92\":1}}],[\"主动切换\",{\"0\":{\"89\":1}}],[\"掌握了递归下降的方法\",{\"1\":{\"154\":1}}],[\"花这么大精力讲解递归下降方法\",{\"1\":{\"154\":1}}],[\"采用自顶向下的编写方法就是要不断地实现我们需要的内容\",{\"1\":{\"158\":1}}],[\"采用递归向下的方法来实现编译器是很直观的\",{\"1\":{\"153\":1}}],[\"采用反证法\",{\"1\":{\"72\":1,\"75\":1}}],[\"问题\",{\"1\":{\"151\":1}}],[\"问题到底出在哪儿\",{\"1\":{\"90\":1}}],[\"否则会有一些问题\",{\"1\":{\"151\":1}}],[\"方法中与函数定义相关的内容\",{\"1\":{\"165\":1}}],[\"方法本身有一定的要求\",{\"1\":{\"151\":1}}],[\"方法是为每个产生式\",{\"1\":{\"151\":1}}],[\"方式使用\",{\"1\":{\"31\":1}}],[\"底\",{\"1\":{\"150\":1}}],[\"向下\",{\"1\":{\"150\":1}}],[\"向前看标记\",{\"1\":{\"159\":1}}],[\"向前看\",{\"1\":{\"142\":1,\"151\":1}}],[\"整个系列的一开始\",{\"1\":{\"204\":1}}],[\"整个系统就变得复杂了\",{\"1\":{\"118\":1}}],[\"整个编译器还剩下最后两个部分\",{\"1\":{\"173\":1}}],[\"整个解析的过程和语法的\",{\"1\":{\"151\":1}}],[\"整个解析的过程是在不断对非终结符进行替换\",{\"1\":{\"150\":1}}],[\"顶\",{\"1\":{\"150\":1}}],[\"右侧的式子代替\",{\"1\":{\"149\":1}}],[\"括起来的就称作\",{\"1\":{\"149\":1}}],[\"括号太多\",{\"1\":{\"38\":1}}],[\"范式\",{\"1\":{\"149\":1}}],[\"非终结符\",{\"1\":{\"149\":2,\"151\":1}}],[\"终结符\",{\"1\":{\"149\":2}}],[\"终结符与非终结符\",{\"0\":{\"149\":1},\"1\":{\"147\":1}}],[\"直到真正用递归下降的方式实现了一个\",{\"1\":{\"206\":1}}],[\"直到遇到优先级\",{\"1\":{\"194\":1}}],[\"直到遇见了终结符\",{\"1\":{\"150\":1}}],[\"直到合并成起始的非终结符\",{\"1\":{\"148\":1}}],[\"直到匹配输入的终结符\",{\"1\":{\"148\":1}}],[\"直接将对应的值用\",{\"1\":{\"186\":1}}],[\"直接从源代码编译成汇编代码是很困难的\",{\"1\":{\"133\":1}}],[\"直接证明比较困难\",{\"1\":{\"53\":1,\"69\":1}}],[\"直接取模\",{\"0\":{\"38\":1}}],[\"自己实现了一个c语言的编译器\",{\"1\":{\"202\":1}}],[\"自增自减\",{\"0\":{\"193\":1,\"199\":1},\"1\":{\"181\":2}}],[\"自底向上是不断地将终结符进行合并\",{\"1\":{\"148\":1}}],[\"自顶向下是从起始非终结符开始\",{\"1\":{\"148\":1}}],[\"自然数与有向图\",{\"1\":{\"76\":1}}],[\"自然数中最重要的运算当然是加法\",{\"1\":{\"48\":1}}],[\"自然数的乘法也十分重要\",{\"1\":{\"64\":1}}],[\"自然数的乘法运算\",{\"0\":{\"64\":1}}],[\"自然数的序是全序关系\",{\"1\":{\"57\":1}}],[\"自然数的序为两个自然数的关系\",{\"1\":{\"56\":1}}],[\"自然数的序\",{\"0\":{\"56\":1}}],[\"自然数的加法运算\",{\"0\":{\"48\":1}}],[\"自然数的定义\",{\"0\":{\"47\":1}}],[\"自然数的定义则是构建此算术公理系统的第一步\",{\"1\":{\"46\":1}}],[\"自然数这个新的数学对象因我们的假设而确立\",{\"1\":{\"47\":1}}],[\"自然数\",{\"0\":{\"46\":1},\"1\":{\"58\":1}}],[\"四则运算的规则可以表示如下\",{\"1\":{\"149\":1}}],[\"四则运算的实现\",{\"0\":{\"153\":1},\"1\":{\"147\":1}}],[\"四则运算的递归下降\",{\"0\":{\"150\":1},\"1\":{\"147\":1}}],[\"左递归的消除\",{\"1\":{\"154\":1}}],[\"左递归\",{\"0\":{\"152\":1},\"1\":{\"147\":1,\"151\":1}}],[\"左手画方右手画圆在现实中本来就不成立\",{\"1\":{\"89\":1}}],[\"作用是减小语法分析器的复杂程度\",{\"1\":{\"146\":1}}],[\"字段吗\",{\"1\":{\"144\":1}}],[\"字符\",{\"1\":{\"142\":1,\"168\":2}}],[\"字符a对应的十六进制值是\",{\"1\":{\"140\":1}}],[\"字符串等等\",{\"1\":{\"183\":1}}],[\"字符串转换成标记流有时是有状态的\",{\"1\":{\"134\":1}}],[\"字符串\",{\"0\":{\"141\":1},\"1\":{\"131\":1}}],[\"平时听到的\",{\"1\":{\"142\":1}}],[\"了解自动生成词法分析器的原理\",{\"1\":{\"205\":1}}],[\"了解了协程如何主动切换\",{\"1\":{\"92\":1}}],[\"了\",{\"1\":{\"142\":1}}],[\"反之则是变量\",{\"1\":{\"159\":1}}],[\"反之则是除号\",{\"1\":{\"142\":1}}],[\"反过来\",{\"1\":{\"122\":1}}],[\"提前看字符的原理是\",{\"1\":{\"142\":1}}],[\"提示\",{\"1\":{\"12\":1}}],[\"标准\",{\"1\":{\"186\":1}}],[\"标记开头的\",{\"1\":{\"186\":1}}],[\"标记\",{\"1\":{\"142\":2}}],[\"标识符的类型\",{\"1\":{\"139\":1}}],[\"标识符\",{\"1\":{\"139\":1}}],[\"标识符与符号表\",{\"0\":{\"139\":1},\"1\":{\"131\":1}}],[\"除了上述对表达式的解析外\",{\"1\":{\"201\":1}}],[\"除了开头的\",{\"1\":{\"163\":1}}],[\"除了跳过注释\",{\"1\":{\"142\":1}}],[\"除了核心的逻辑外还需要输入输出\",{\"1\":{\"128\":1}}],[\"类别信息在后面章节中解析\",{\"1\":{\"160\":1}}],[\"类型的解析在前面的文章中我们已经很熟悉了\",{\"1\":{\"185\":1}}],[\"类型的注释\",{\"1\":{\"142\":1}}],[\"类型定义\",{\"1\":{\"159\":1}}],[\"类的多项式题目\",{\"1\":{\"36\":1}}],[\"段中的地址\",{\"1\":{\"141\":1}}],[\"段中\",{\"1\":{\"141\":1}}],[\"十六进制及八进制\",{\"1\":{\"140\":1}}],[\"十分有成就感\",{\"1\":{\"107\":1}}],[\"十分钟学会正确的github工作流\",{\"1\":{\"33\":1}}],[\"故通过\",{\"1\":{\"140\":1}}],[\"故而使用下列方式\",{\"1\":{\"139\":1}}],[\"故我们引入一个指令mset\",{\"1\":{\"115\":1}}],[\"传统的编程书籍会用\",{\"1\":{\"182\":1}}],[\"传统上\",{\"1\":{\"148\":1}}],[\"传统意义上的符号表只需要知道标识符的唯一标识即可\",{\"1\":{\"139\":1}}],[\"传递性和完全性\",{\"1\":{\"57\":1}}],[\"刚存放函数的地址\",{\"1\":{\"139\":1}}],[\"型还是指针型\",{\"1\":{\"139\":1}}],[\"型\",{\"1\":{\"139\":1,\"185\":1,\"198\":2}}],[\"型的\",{\"1\":{\"115\":1}}],[\"顾名思义\",{\"1\":{\"139\":1}}],[\"遇到数字5\",{\"1\":{\"182\":1}}],[\"遇到数字4\",{\"1\":{\"182\":1}}],[\"遇到数字\",{\"1\":{\"182\":1}}],[\"遇到运算符\",{\"1\":{\"182\":3}}],[\"遇到新的标识符就去查这张表\",{\"1\":{\"139\":1}}],[\"遇到的时候就知道了\",{\"1\":{\"107\":1}}],[\"基于这个理由\",{\"1\":{\"139\":1}}],[\"基址指针\",{\"1\":{\"116\":1}}],[\"循环中\",{\"1\":{\"168\":1}}],[\"循环就没法准确地知道函数定义已经结束\",{\"1\":{\"168\":1}}],[\"循环可以用来跳过它\",{\"1\":{\"136\":1}}],[\"循环的作用就是跳过这些我们不识别的字符\",{\"1\":{\"136\":1}}],[\"循环呢\",{\"1\":{\"136\":1}}],[\"跳过当前错误并继续编译\",{\"1\":{\"136\":1}}],[\"~a\",{\"1\":{\"191\":1}}],[\"~\",{\"1\":{\"135\":1,\"143\":1,\"191\":2}}],[\"更先进的版本是\",{\"1\":{\"206\":1}}],[\"更为重要的是\",{\"1\":{\"151\":1}}],[\"更多的标记\",{\"1\":{\"135\":1}}],[\"更新代码的原生部分\",{\"1\":{\"86\":1}}],[\"正则表达式\",{\"1\":{\"205\":1}}],[\"正如我们保证的那样\",{\"1\":{\"201\":1}}],[\"正负号\",{\"0\":{\"192\":1},\"1\":{\"181\":1}}],[\"正常的全局变量的类别则是\",{\"1\":{\"160\":1}}],[\"正是因为它相当于通过一定的编码\",{\"1\":{\"135\":1}}],[\"正自然数与自然数相加为正自然数\",{\"1\":{\"59\":2}}],[\"正自然数的性质\",{\"0\":{\"59\":1}}],[\"正自然数\",{\"0\":{\"58\":1}}],[\"保存所有的标记流没有意义且浪费空间\",{\"1\":{\"134\":1}}],[\"保存在栈中\",{\"1\":{\"122\":1}}],[\"来实现运算符的优先级\",{\"1\":{\"202\":1}}],[\"来实现\",{\"1\":{\"192\":1}}],[\"来保存一个表达式的类型\",{\"1\":{\"187\":1}}],[\"来表示退出\",{\"1\":{\"177\":1}}],[\"来大致描述我们实现的\",{\"1\":{\"155\":1}}],[\"来压缩了源码字符串\",{\"1\":{\"135\":1}}],[\"来将字符串转换成标记流\",{\"1\":{\"133\":1}}],[\"来计算\",{\"1\":{\"129\":1}}],[\"源码中若包含一个数字\",{\"1\":{\"132\":1}}],[\"简直痛苦地无话可说\",{\"1\":{\"207\":1}}],[\"简而言之\",{\"1\":{\"132\":1}}],[\"简单ppt\",{\"1\":{\"96\":1}}],[\"简单直接\",{\"1\":{\"38\":1}}],[\"简单地说\",{\"1\":{\"31\":1,\"32\":1,\"174\":1}}],[\"注释\",{\"0\":{\"142\":1},\"1\":{\"131\":1}}],[\"注意这里并不是四则运算中的加减法\",{\"1\":{\"192\":1}}],[\"注意这里的类型\",{\"1\":{\"115\":1}}],[\"注意我们的之前的程序需要指令一个源文件\",{\"1\":{\"129\":1}}],[\"注意的是自增自减操作的优先级是和它的位置有关的\",{\"1\":{\"193\":1}}],[\"注意的是只支持\",{\"1\":{\"185\":1}}],[\"注意的是\",{\"1\":{\"125\":1}}],[\"注意的是pc在初始应指向目标代码中的main函数\",{\"1\":{\"116\":1}}],[\"注意的是由于栈是位于高地址并向低地址增长的\",{\"1\":{\"116\":1}}],[\"注意\",{\"1\":{\"86\":1}}],[\"宏定义\",{\"0\":{\"138\":1},\"1\":{\"131\":1}}],[\"支持的标记\",{\"0\":{\"135\":1},\"1\":{\"131\":1}}],[\"支持实时预览和多种导出格式\",{\"1\":{\"102\":1}}],[\"新的指令几乎不消耗资源\",{\"1\":{\"130\":1}}],[\"添加一个新的指令需要设计许多新的电路\",{\"1\":{\"130\":1}}],[\"添加flask+nginx配置\",{\"1\":{\"24\":1}}],[\"实际上\",{\"1\":{\"182\":1}}],[\"实际上我们也不能使用递归\",{\"1\":{\"156\":1}}],[\"实际中可以自己指定\",{\"1\":{\"150\":1}}],[\"实际计算机中\",{\"1\":{\"130\":1}}],[\"实现起来并不是太难\",{\"1\":{\"206\":1}}],[\"实现起来也更直观\",{\"1\":{\"156\":1}}],[\"实现四则运算来讲解优先级问题\",{\"1\":{\"182\":1}}],[\"实现如下\",{\"1\":{\"120\":1,\"121\":1,\"123\":1,\"124\":1,\"126\":1,\"127\":1}}],[\"实现一个功能完善的\",{\"1\":{\"106\":1}}],[\"实现也很复杂\",{\"0\":{\"105\":1}}],[\"二是如何将表达式编译成目标代码\",{\"1\":{\"181\":1}}],[\"二是容易中间运算时搞错运算顺序\",{\"1\":{\"38\":1}}],[\"二元运算符\",{\"0\":{\"194\":1},\"1\":{\"181\":1}}],[\"二选一\",{\"1\":{\"129\":1}}],[\"解决了优先级的问题\",{\"1\":{\"194\":1}}],[\"解决方法\",{\"1\":{\"129\":1}}],[\"解析表达式\",{\"1\":{\"181\":1,\"202\":1}}],[\"解析函数的参数就是解析以逗号分隔的一个个标识符\",{\"1\":{\"169\":1}}],[\"解析函数的定义\",{\"0\":{\"166\":1},\"1\":{\"164\":1}}],[\"解析参数\",{\"0\":{\"169\":1},\"1\":{\"164\":1}}],[\"解析变量的定义\",{\"0\":{\"157\":1},\"1\":{\"155\":1}}],[\"解析为\",{\"1\":{\"135\":3}}],[\"解释器\",{\"1\":{\"115\":1}}],[\"解释器需要我们实现自己的虚拟机与指令集\",{\"1\":{\"109\":1}}],[\"解释器与编译器仅在代码生成阶段有区别\",{\"1\":{\"109\":1}}],[\"解释器就自动释放gil锁\",{\"1\":{\"90\":1}}],[\"位机器下\",{\"1\":{\"129\":1}}],[\"位的\",{\"1\":{\"129\":2}}],[\"位的机器中\",{\"1\":{\"115\":1}}],[\"另外\",{\"1\":{\"129\":1,\"142\":1,\"151\":1,\"198\":1}}],[\"另一个特殊的地方是我们需要支持转义符\",{\"1\":{\"141\":1}}],[\"另一点是我们的\",{\"1\":{\"118\":1}}],[\"另一方面需要对照生成的代码来调试\",{\"1\":{\"107\":1}}],[\"另一方面希望挑战一下自己\",{\"1\":{\"104\":1}}],[\"另一方面\",{\"1\":{\"91\":1,\"118\":1}}],[\"另一方面采取了常数更小的加减法操作\",{\"1\":{\"40\":1}}],[\"输出是标记流\",{\"1\":{\"146\":1}}],[\"输出标记流\",{\"1\":{\"133\":1}}],[\"输出汇编代码\",{\"1\":{\"133\":1}}],[\"输出为标记流\",{\"1\":{\"132\":1}}],[\"输出\",{\"1\":{\"129\":1}}],[\"输入是源码\",{\"1\":{\"146\":1}}],[\"输入任意邮箱和刚才生成的序列号到激活窗口\",{\"1\":{\"102\":1}}],[\"输入\",{\"1\":{\"32\":1,\"102\":2}}],[\"换句话说\",{\"1\":{\"154\":1}}],[\"换句话说就是不需要我们自己去实现了\",{\"1\":{\"128\":1}}],[\"换行符和空格类似\",{\"1\":{\"137\":1}}],[\"换行符\",{\"0\":{\"137\":1},\"1\":{\"131\":1}}],[\"换成对应的版本\",{\"1\":{\"8\":1}}],[\"写的程序要\",{\"1\":{\"128\":1}}],[\"写起来很无聊\",{\"1\":{\"107\":1}}],[\"两个概念\",{\"1\":{\"174\":1}}],[\"两个参数都无法取得了\",{\"1\":{\"127\":1}}],[\"两个自然数\",{\"1\":{\"62\":1}}],[\"结语\",{\"0\":{\"208\":1},\"1\":{\"203\":1}}],[\"结束的\",{\"1\":{\"168\":2}}],[\"结果存放在寄存器\",{\"1\":{\"127\":1}}],[\"结论当然就是看使用场景\",{\"1\":{\"93\":1}}],[\"计算\",{\"1\":{\"182\":3}}],[\"计算后会将栈顶的参数退栈\",{\"1\":{\"127\":1}}],[\"计算机的栈的状态\",{\"1\":{\"167\":1}}],[\"计算机的内部工作原理\",{\"0\":{\"114\":1},\"1\":{\"113\":1}}],[\"计算机中的寄存器用于存放计算机的运行状态\",{\"1\":{\"116\":1}}],[\"计算机中有三个基本部件需要我们关注\",{\"1\":{\"114\":1}}],[\"之前\",{\"1\":{\"182\":1,\"195\":1}}],[\"之类的表达式要如何实现呢\",{\"1\":{\"186\":1}}],[\"之类的函数\",{\"1\":{\"128\":1}}],[\"之类的运算符是与参数顺序有关的\",{\"1\":{\"127\":1}}],[\"之后再计算运算符\",{\"1\":{\"182\":1}}],[\"之后\",{\"1\":{\"92\":1}}],[\"外的寄存器\",{\"1\":{\"126\":1}}],[\"调用参数\",{\"1\":{\"126\":1}}],[\"调用结束时\",{\"1\":{\"122\":1}}],[\"顺序\",{\"1\":{\"126\":1}}],[\"已经把\",{\"1\":{\"125\":1}}],[\"已经有许多工具能帮助我们处理阶段1和2\",{\"1\":{\"110\":1}}],[\"具体实现很容易\",{\"1\":{\"153\":1}}],[\"具体的实现如下\",{\"1\":{\"125\":1}}],[\"具有一定的参考价值\",{\"1\":{\"108\":1}}],[\"钱\",{\"1\":{\"122\":1}}],[\"尽管代码看起来比较简单\",{\"1\":{\"202\":1}}],[\"尽管理论不是必需的\",{\"1\":{\"154\":1}}],[\"尽管我们还没定义\",{\"1\":{\"122\":1}}],[\"尽管有许多语法并不支持\",{\"1\":{\"103\":1}}],[\"汇编\",{\"1\":{\"180\":1,\"182\":1}}],[\"汇编的意义上\",{\"1\":{\"127\":1}}],[\"汇编代码\",{\"1\":{\"122\":1}}],[\"汇编指令设计并实现了我们自己的指令集\",{\"1\":{\"130\":1}}],[\"汇编指令\",{\"1\":{\"114\":1}}],[\"维基百科\",{\"1\":{\"122\":1}}],[\"事先声明一下\",{\"1\":{\"122\":1}}],[\"事实上\",{\"1\":{\"90\":1}}],[\"参见第\",{\"1\":{\"186\":1}}],[\"参照第三章讲解的虚拟机\",{\"1\":{\"167\":1}}],[\"参数和局部变量\",{\"1\":{\"172\":1}}],[\"参数\",{\"1\":{\"129\":1}}],[\"参数逆序入栈\",{\"1\":{\"122\":1}}],[\"参考资料\",{\"0\":{\"25\":1,\"108\":1}}],[\"子函数要返回时\",{\"1\":{\"122\":1}}],[\"子函数调用\",{\"0\":{\"122\":1},\"1\":{\"113\":1}}],[\"无论多好的教程\",{\"1\":{\"207\":1}}],[\"无论是读起来\",{\"1\":{\"206\":1}}],[\"无论是全局还是局部变量\",{\"1\":{\"186\":1}}],[\"无论是是否真的在全局中用到了这个变量\",{\"1\":{\"169\":1}}],[\"无论是函数的参数\",{\"1\":{\"167\":1}}],[\"无论是结果\",{\"1\":{\"92\":1}}],[\"无论是执行过程中\",{\"1\":{\"92\":1}}],[\"无条件地将当前的\",{\"1\":{\"120\":1}}],[\"详细见下文\",{\"1\":{\"118\":1}}],[\"取址\",{\"1\":{\"189\":1}}],[\"取址操作\",{\"0\":{\"189\":1},\"1\":{\"181\":1}}],[\"取自\",{\"1\":{\"122\":1}}],[\"取值会更高效\",{\"1\":{\"118\":1}}],[\"取模运算就成为了编程中不可缺少的一部分\",{\"1\":{\"37\":1}}],[\"地址存放在\",{\"1\":{\"118\":1}}],[\"地址存放在栈中\",{\"1\":{\"118\":1}}],[\"操作\",{\"1\":{\"118\":1}}],[\"操作系统将我们使用的虚拟地址映射到了到实际的内存上\",{\"1\":{\"115\":1}}],[\"放入寄存器\",{\"1\":{\"118\":1}}],[\"识别这些参数的类型\",{\"1\":{\"118\":1}}],[\"风格\",{\"1\":{\"118\":1}}],[\"风格统一\",{\"0\":{\"44\":1}}],[\"带有参数的指令在前\",{\"1\":{\"117\":1}}],[\"稍后你会看到\",{\"1\":{\"117\":1}}],[\"能自己编译自己\",{\"1\":{\"201\":1}}],[\"能大概理解吗\",{\"1\":{\"159\":1}}],[\"能减小语法分析复杂度\",{\"1\":{\"142\":1}}],[\"能理解的语言\",{\"1\":{\"117\":1}}],[\"能识别的命令的集合\",{\"1\":{\"117\":1}}],[\"能不能理解\",{\"1\":{\"104\":1}}],[\"与前缀形式不同的是\",{\"1\":{\"199\":1}}],[\"与之不同\",{\"1\":{\"186\":1}}],[\"与语法分析相关的部分就是上文所说的优先级问题了\",{\"1\":{\"183\":1}}],[\"与存放在\",{\"1\":{\"167\":1}}],[\"与\",{\"1\":{\"116\":1,\"122\":1,\"168\":1,\"206\":1}}],[\"与线程相比\",{\"1\":{\"91\":1}}],[\"通用寄存器\",{\"1\":{\"116\":1}}],[\"通过一步步的学习\",{\"1\":{\"202\":1}}],[\"通过一个有趣的代码示例\",{\"1\":{\"98\":1}}],[\"通过\",{\"1\":{\"201\":1}}],[\"通过本章的学习\",{\"1\":{\"146\":1}}],[\"通过词法分析器的预处理\",{\"1\":{\"132\":1}}],[\"通过将\",{\"1\":{\"118\":1}}],[\"通过教程来说明这个过程\",{\"1\":{\"106\":1}}],[\"通过举反例的方式\",{\"1\":{\"73\":1}}],[\"通过上述步骤\",{\"1\":{\"73\":1,\"102\":1}}],[\"永远指向当前的栈顶\",{\"1\":{\"116\":1}}],[\"指定了当前的优先级\",{\"1\":{\"194\":1}}],[\"指针加上数值等于将指针移位\",{\"1\":{\"198\":1}}],[\"指针相对位置的形式\",{\"1\":{\"186\":1}}],[\"指针取值\",{\"0\":{\"188\":1},\"1\":{\"181\":1}}],[\"指针和对应的位移量进行的\",{\"1\":{\"167\":1}}],[\"指针寄存器\",{\"1\":{\"116\":1}}],[\"指向的是同一个变量\",{\"1\":{\"139\":1}}],[\"指出错误发生的位置\",{\"1\":{\"136\":2}}],[\"指的是\",{\"1\":{\"123\":1}}],[\"指令加载实际内容\",{\"1\":{\"189\":1}}],[\"指令加载对应的值\",{\"1\":{\"186\":1}}],[\"指令了\",{\"1\":{\"189\":1}}],[\"指令存入\",{\"1\":{\"186\":1}}],[\"指令将它加载到\",{\"1\":{\"184\":1}}],[\"指令无法操作除\",{\"1\":{\"126\":1}}],[\"指令功能有限\",{\"1\":{\"124\":1}}],[\"指令同样功能不足\",{\"1\":{\"122\":1}}],[\"指令并无法指定寄存器\",{\"1\":{\"122\":1}}],[\"指令来代替它\",{\"1\":{\"122\":1}}],[\"指令呢\",{\"1\":{\"122\":1}}],[\"指令的参数\",{\"1\":{\"120\":1}}],[\"指令只能将\",{\"1\":{\"118\":1}}],[\"指令中\",{\"1\":{\"118\":1}}],[\"指令其实有许多变种\",{\"1\":{\"118\":1}}],[\"指令拆分成这些指令\",{\"1\":{\"118\":1}}],[\"指令拆分成\",{\"1\":{\"118\":1}}],[\"指令有两个参数\",{\"1\":{\"118\":1}}],[\"指令\",{\"1\":{\"115\":1,\"120\":1,\"122\":1,\"125\":2,\"186\":1}}],[\"指令集是\",{\"1\":{\"117\":1}}],[\"指令集\",{\"0\":{\"117\":1},\"1\":{\"113\":1}}],[\"该标识符的类别\",{\"1\":{\"139\":1}}],[\"该标识符返回的标记\",{\"1\":{\"139\":1}}],[\"该地址中存放着\",{\"1\":{\"116\":1}}],[\"该怎么办\",{\"1\":{\"92\":1}}],[\"程序需要回到跳转之前的地方继续运行\",{\"1\":{\"122\":1}}],[\"程序计数器\",{\"1\":{\"116\":1}}],[\"程序运行的状态保存在寄存器中\",{\"1\":{\"114\":1}}],[\"分隔的变量\",{\"1\":{\"160\":1}}],[\"分别是\",{\"1\":{\"155\":1,\"164\":1}}],[\"分别是源地址和目标地址\",{\"1\":{\"118\":1}}],[\"分别如下\",{\"1\":{\"116\":1}}],[\"分析标识符的相关代码如下\",{\"1\":{\"139\":1}}],[\"分析整个\",{\"1\":{\"111\":1}}],[\"分析\",{\"1\":{\"105\":1}}],[\"真正的计算机中有许多不同种类的寄存器\",{\"1\":{\"116\":1}}],[\"真正为其分配内存\",{\"1\":{\"115\":1}}],[\"真正来实现一个简单的编译器\",{\"1\":{\"105\":1}}],[\"综上\",{\"1\":{\"115\":1,\"182\":1}}],[\"综上所述\",{\"1\":{\"50\":1,\"51\":1,\"55\":1,\"66\":1,\"67\":1,\"72\":1}}],[\"理论上所有的变量返回的标记都应该是\",{\"1\":{\"139\":1}}],[\"理论上我们的虚拟机需要维护一个堆用于内存分配\",{\"1\":{\"115\":1}}],[\"理论很复杂\",{\"0\":{\"105\":1}}],[\"^\",{\"1\":{\"115\":1,\"127\":1,\"143\":1,\"191\":1,\"198\":3}}],[\"堆\",{\"1\":{\"115\":1}}],[\"栈中的调用帧是什么样的\",{\"1\":{\"126\":1}}],[\"栈\",{\"1\":{\"115\":1,\"167\":1,\"182\":1}}],[\"未初始化数据段\",{\"1\":{\"115\":1}}],[\"虚拟内存可以理解为一种映射\",{\"1\":{\"115\":1}}],[\"虚拟内存\",{\"1\":{\"115\":1}}],[\"虚拟机与目标代码\",{\"0\":{\"204\":1},\"1\":{\"203\":1}}],[\"虚拟机中讲解的指令是对应的\",{\"1\":{\"186\":1}}],[\"虚拟机上运行我们提供的这些指令时\",{\"1\":{\"128\":1}}],[\"虚拟机的入口\",{\"1\":{\"111\":1}}],[\"虚拟机\",{\"1\":{\"103\":1,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"172\":1,\"173\":1,\"181\":1,\"186\":1,\"203\":1}}],[\"物理内存\",{\"1\":{\"115\":1}}],[\"现代操作系统在操作内存时\",{\"1\":{\"115\":1}}],[\"现在我们要回忆如何将\",{\"1\":{\"167\":1}}],[\"现在电话亭上加了把锁\",{\"1\":{\"90\":1}}],[\"现在不存在这种情况了\",{\"1\":{\"39\":1}}],[\"测试\",{\"0\":{\"129\":1},\"1\":{\"113\":1}}],[\"寄存器指向的是\",{\"1\":{\"120\":1}}],[\"寄存器设置为指定的\",{\"1\":{\"120\":1}}],[\"寄存器或是一个内存地址\",{\"1\":{\"118\":1}}],[\"寄存器及内存\",{\"1\":{\"114\":1}}],[\"寄存器\",{\"0\":{\"116\":1},\"1\":{\"113\":1}}],[\"内置函数有对应的汇编指令\",{\"1\":{\"186\":1}}],[\"内置函数的行为也和关键字类似\",{\"1\":{\"144\":1}}],[\"内置函数\",{\"0\":{\"128\":1},\"1\":{\"113\":1}}],[\"内存地址的数据\",{\"1\":{\"115\":1}}],[\"内存用于存储数据\",{\"1\":{\"115\":1}}],[\"内存\",{\"0\":{\"115\":1},\"1\":{\"113\":1}}],[\"内容相对容易一些\",{\"1\":{\"180\":1}}],[\"内容为\",{\"1\":{\"111\":1}}],[\"内容过于复杂\",{\"1\":{\"105\":1}}],[\"逐个读取文件中的字符\",{\"1\":{\"111\":1}}],[\"读取一个文件\",{\"1\":{\"111\":1}}],[\">|\",{\"1\":{\"139\":1,\"170\":1}}],[\">>\",{\"1\":{\"127\":1,\"143\":1,\"198\":1}}],[\">=\",{\"1\":{\"127\":1,\"139\":5,\"140\":8,\"143\":1,\"153\":2,\"188\":1,\"194\":1,\"198\":1}}],[\">\",{\"1\":{\"111\":1,\"127\":1,\"133\":4,\"140\":1,\"143\":3,\"153\":1,\"158\":1,\"186\":1,\"193\":1,\"198\":2,\"199\":3,\"200\":1}}],[\"<unit>\",{\"1\":{\"198\":2}}],[\"<false\",{\"1\":{\"175\":2}}],[\"<factor>11\",{\"1\":{\"150\":1}}],[\"<factor>3\",{\"1\":{\"150\":1}}],[\"<factor><factor>\",{\"1\":{\"149\":1}}],[\"<factor>\",{\"1\":{\"149\":2,\"150\":2,\"151\":2,\"152\":3}}],[\"<true\",{\"1\":{\"175\":2}}],[\"<term\",{\"1\":{\"152\":3}}],[\"<term>7\",{\"1\":{\"150\":1}}],[\"<term>或\",{\"1\":{\"149\":1}}],[\"<term><term>\",{\"1\":{\"149\":1}}],[\"<term>\",{\"1\":{\"149\":6,\"150\":2,\"151\":2,\"152\":3}}],[\"<cond>\",{\"1\":{\"175\":3,\"176\":2}}],[\"<empty\",{\"1\":{\"174\":1}}],[\"<empty><factor>\",{\"1\":{\"152\":1}}],[\"<empty><term>\",{\"1\":{\"152\":1}}],[\"<expr2>normal\",{\"1\":{\"198\":1}}],[\"<expr2>\",{\"1\":{\"197\":4,\"198\":6}}],[\"<expr1>push\",{\"1\":{\"198\":1}}],[\"<expr1>\",{\"1\":{\"197\":4,\"198\":4}}],[\"<expr\",{\"1\":{\"152\":3}}],[\"<expr>2\",{\"1\":{\"150\":1}}],[\"<expr>\",{\"1\":{\"149\":7,\"150\":4,\"151\":2,\"152\":2,\"190\":1,\"191\":1}}],[\"<>\",{\"1\":{\"149\":1}}],[\"<<\",{\"1\":{\"127\":1,\"143\":1,\"198\":1}}],[\"<offset>\",{\"1\":{\"126\":1}}],[\"<size>\",{\"1\":{\"123\":1,\"124\":2}}],[\"<statement>\",{\"1\":{\"174\":4,\"175\":2,\"176\":2,\"178\":1}}],[\"<string\",{\"1\":{\"111\":1}}],[\"<stdlib\",{\"1\":{\"111\":1,\"153\":1}}],[\"<stdio\",{\"1\":{\"111\":1,\"138\":1,\"153\":1}}],[\"<addr>pushsc\",{\"1\":{\"195\":1}}],[\"<addr>lc\",{\"1\":{\"195\":1}}],[\"<addr>li\",{\"1\":{\"189\":1}}],[\"<addr>\",{\"1\":{\"120\":3,\"122\":2,\"186\":1,\"188\":1}}],[\"<num>\",{\"1\":{\"118\":2}}],[\"<=\",{\"1\":{\"111\":1,\"127\":1,\"139\":5,\"140\":6,\"143\":1,\"144\":2,\"153\":2}}],[\"<\",{\"1\":{\"111\":1,\"126\":1,\"127\":1,\"143\":3,\"167\":1,\"198\":3,\"200\":1}}],[\"<memory\",{\"1\":{\"111\":1}}],[\"获取下一个标记\",{\"1\":{\"111\":1}}],[\"构建语法分析器\",{\"1\":{\"110\":1}}],[\"构建我们的词法分析器\",{\"1\":{\"110\":1}}],[\"构建我们自己的虚拟机以及指令集\",{\"1\":{\"110\":1}}],[\"屏蔽了许多实现上的细节\",{\"1\":{\"110\":1}}],[\"目标代码的生成\",{\"1\":{\"110\":1}}],[\"目录的构建\",{\"1\":{\"86\":1}}],[\"生成汇编代码\",{\"1\":{\"199\":2}}],[\"生成了如下的汇编代码\",{\"1\":{\"195\":1}}],[\"生成一个同名的函数\",{\"1\":{\"151\":1}}],[\"生成一棵语法树\",{\"1\":{\"110\":1}}],[\"生活记录等非技术类文章\",{\"1\":{\"2\":1}}],[\"个字节\",{\"1\":{\"198\":1}}],[\"个字符或标记\",{\"1\":{\"146\":1}}],[\"个数等\",{\"1\":{\"172\":1}}],[\"个部分进行讲解\",{\"1\":{\"155\":1,\"164\":1}}],[\"个标记\",{\"1\":{\"151\":1}}],[\"个指令\",{\"1\":{\"118\":1}}],[\"个寄存器\",{\"1\":{\"116\":1}}],[\"个函数\",{\"1\":{\"111\":1}}],[\"个函数来实现了一个小的\",{\"1\":{\"106\":1}}],[\"个步骤\",{\"1\":{\"110\":1}}],[\"虽然多\",{\"1\":{\"202\":1}}],[\"虽然我们前面没有提到\",{\"1\":{\"187\":1}}],[\"虽然上面写完了词法分析器\",{\"1\":{\"144\":1}}],[\"虽然是int型\",{\"1\":{\"115\":1}}],[\"虽然标题是编译器\",{\"1\":{\"109\":1}}],[\"虽然同时只能有一个线程执行\",{\"1\":{\"92\":1}}],[\"系列的第三篇\",{\"1\":{\"113\":1}}],[\"系列的第二篇\",{\"1\":{\"109\":1}}],[\"系统的线程调度器是假设不同的线程是毫无关系的\",{\"1\":{\"90\":1}}],[\"系统\",{\"0\":{\"76\":1}}],[\"观看效果更佳\",{\"1\":{\"108\":1}}],[\"英文的\",{\"1\":{\"108\":1}}],[\"很有帮助的\",{\"1\":{\"207\":1}}],[\"很好的初学者教程\",{\"1\":{\"108\":1}}],[\"很难懂\",{\"1\":{\"106\":1}}],[\"相应的减法的代码就不贴了\",{\"1\":{\"198\":1}}],[\"相应的值会存放在\",{\"1\":{\"195\":1}}],[\"相等\",{\"1\":{\"190\":1}}],[\"相同类型\",{\"1\":{\"198\":1}}],[\"相同\",{\"1\":{\"182\":1}}],[\"相对于表达式来说它还是较为容易的\",{\"1\":{\"173\":1}}],[\"相信这部分的知识能够很大程度上提高你的编程水平\",{\"1\":{\"205\":1}}],[\"相信这部分也不难理解\",{\"1\":{\"163\":1}}],[\"相信当你真正完成的时候会像我一样\",{\"1\":{\"107\":1}}],[\"相当于\",{\"1\":{\"118\":1}}],[\"相关\",{\"1\":{\"169\":1}}],[\"相关代码如下\",{\"1\":{\"141\":1}}],[\"相关的代码如下\",{\"1\":{\"166\":1}}],[\"相关的内容我们放到后面解释\",{\"1\":{\"156\":1}}],[\"相关的内容注释了\",{\"1\":{\"122\":1}}],[\"相关的是指令集\",{\"1\":{\"116\":1}}],[\"相关信息\",{\"1\":{\"33\":1,\"43\":1,\"86\":1,\"108\":1}}],[\"相反\",{\"1\":{\"108\":1}}],[\"繁琐\",{\"1\":{\"107\":1}}],[\"做好心理准备\",{\"0\":{\"107\":1}}],[\"声明\",{\"1\":{\"106\":1}}],[\"总共代码加注释1400行\",{\"1\":{\"106\":1}}],[\"总结\",{\"1\":{\"103\":1,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1}}],[\"号称用\",{\"1\":{\"106\":1}}],[\"名叫\",{\"1\":{\"106\":1}}],[\"试图教会我们的是如何构造\",{\"1\":{\"105\":1}}],[\"试证乘法交换律\",{\"1\":{\"69\":1}}],[\"试证加法交换律\",{\"1\":{\"53\":1}}],[\"试证\",{\"1\":{\"53\":2,\"55\":2,\"69\":2,\"72\":2}}],[\"学习编译原理时常常着眼于词法分析和语法分析\",{\"1\":{\"204\":1}}],[\"学习了编译原理\",{\"1\":{\"104\":1}}],[\"学了这么多也没用\",{\"1\":{\"105\":1}}],[\"什么是表达式\",{\"1\":{\"181\":1}}],[\"什么是递归下降\",{\"0\":{\"148\":1},\"1\":{\"147\":1}}],[\"什么是词法分析器\",{\"0\":{\"132\":1},\"1\":{\"131\":1}}],[\"什么都不干的编译器\",{\"1\":{\"111\":1}}],[\"什么\",{\"1\":{\"105\":1}}],[\"词法分析中如何处理标识符与符号表\",{\"1\":{\"146\":1}}],[\"词法分析\",{\"0\":{\"205\":1},\"1\":{\"105\":1,\"203\":1}}],[\"词法分析器本身可以认为是一个编译器\",{\"1\":{\"146\":1}}],[\"词法分析器本质上也是编译器\",{\"1\":{\"142\":1}}],[\"词法分析器中直接解析这些关键字\",{\"1\":{\"144\":1}}],[\"词法分析器会把扫描到的标识符全都保存到一张表中\",{\"1\":{\"139\":1}}],[\"词法分析器将输出\",{\"1\":{\"132\":1}}],[\"词法分析器以源码字符串为输入\",{\"1\":{\"132\":1}}],[\"词法分析器用于对源码字符串做预处理\",{\"1\":{\"132\":1}}],[\"词法分析器的作用是对源码字符串进行预处理\",{\"1\":{\"146\":1}}],[\"词法分析器的框架\",{\"0\":{\"136\":1},\"1\":{\"131\":1}}],[\"词法分析器的实现\",{\"0\":{\"134\":1},\"1\":{\"131\":1}}],[\"词法分析器与编译器\",{\"0\":{\"133\":1},\"1\":{\"131\":1}}],[\"词法分析器\",{\"1\":{\"103\":1,\"109\":1,\"110\":1,\"113\":1,\"131\":1,\"133\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1}}],[\"听不懂\",{\"1\":{\"105\":1}}],[\"看了上面的代码\",{\"1\":{\"159\":1}}],[\"看看自己能走多远\",{\"1\":{\"104\":1}}],[\"看起来是这样的\",{\"1\":{\"92\":1}}],[\"好吧\",{\"1\":{\"104\":1,\"202\":1}}],[\"装b\",{\"1\":{\"104\":1}}],[\"以及该函数在代码段\",{\"1\":{\"166\":1}}],[\"以减少语法分析器的复杂程度\",{\"1\":{\"132\":1}}],[\"以上就是我们为了实现函数调用需要的指令了\",{\"1\":{\"126\":1}}],[\"以二进制的形式保存在内存中\",{\"1\":{\"114\":1}}],[\"以前人们会说\",{\"1\":{\"104\":1}}],[\"以管理员身份在\",{\"1\":{\"102\":1}}],[\"像是程序员的第一道门槛\",{\"1\":{\"104\":1}}],[\"递归调用的实质也是栈的处理\",{\"1\":{\"182\":1}}],[\"递归下下降方法对\",{\"1\":{\"151\":1}}],[\"递归下降是从起始的非终结符开始\",{\"1\":{\"150\":1}}],[\"递归下降法\",{\"1\":{\"105\":1}}],[\"递归下降\",{\"1\":{\"103\":1,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1,\"206\":1}}],[\"递归\",{\"1\":{\"104\":1}}],[\"编程有趣又无趣\",{\"1\":{\"208\":1}}],[\"编写编译器时遇到的一些难题\",{\"1\":{\"203\":1}}],[\"编写语法分析器有两种方法\",{\"1\":{\"148\":1}}],[\"编译时加上\",{\"1\":{\"129\":1}}],[\"编译程序\",{\"1\":{\"129\":1}}],[\"编译器中我们需要用到的函数有\",{\"1\":{\"128\":1}}],[\"编译器的语法分析部分其实是很简单的\",{\"1\":{\"180\":1}}],[\"编译器的输出\",{\"1\":{\"130\":1}}],[\"编译器的编写分为\",{\"1\":{\"110\":1}}],[\"编译器的构建流程\",{\"0\":{\"110\":1},\"1\":{\"109\":1}}],[\"编译器框架\",{\"0\":{\"111\":1},\"1\":{\"109\":1}}],[\"编译器生成器\",{\"1\":{\"105\":1}}],[\"编译原理\",{\"1\":{\"104\":1,\"105\":3,\"108\":1}}],[\"编辑器\",{\"1\":{\"102\":1}}],[\"算法\",{\"1\":{\"104\":1}}],[\"算术公理系统\",{\"0\":{\"46\":1}}],[\"数组取值操作\",{\"0\":{\"200\":1},\"1\":{\"181\":1}}],[\"数字中较为复杂的一点是需要支持十进制\",{\"1\":{\"140\":1}}],[\"数字\",{\"0\":{\"140\":1},\"1\":{\"131\":1,\"132\":1,\"183\":1}}],[\"数据段以及栈\",{\"1\":{\"115\":1}}],[\"数据段\",{\"1\":{\"115\":1,\"167\":1}}],[\"数据结构\",{\"1\":{\"104\":1}}],[\"数学运算符\",{\"0\":{\"198\":1},\"1\":{\"181\":1}}],[\"数学\",{\"2\":{\"82\":1}}],[\"请自行查阅相关的资料\",{\"1\":{\"152\":1}}],[\"请跳过本章\",{\"1\":{\"103\":1}}],[\"请联系删除\",{\"1\":{\"103\":1,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1}}],[\"谈谈这个系列的初衷\",{\"1\":{\"103\":1}}],[\"表\",{\"1\":{\"139\":1}}],[\"表达式结束\",{\"1\":{\"182\":1}}],[\"表达式的解析难点有二\",{\"1\":{\"181\":1}}],[\"表达式是将各种语言要素的一个组合\",{\"1\":{\"181\":1}}],[\"表达式可能相对不好理解一些\",{\"1\":{\"163\":1}}],[\"表达式\",{\"1\":{\"103\":1,\"109\":1,\"111\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":2,\"164\":2,\"173\":1,\"174\":1,\"181\":1,\"203\":1}}],[\"表示转换成实际的代码\",{\"1\":{\"151\":1}}],[\"表示是十分接近的\",{\"1\":{\"151\":1}}],[\"表示选择\",{\"1\":{\"149\":1}}],[\"表示字符\",{\"1\":{\"141\":1}}],[\"表示换行符\",{\"1\":{\"141\":1}}],[\"表示将\",{\"1\":{\"118\":1}}],[\"表示\",{\"0\":{\"156\":1,\"165\":1},\"1\":{\"47\":1,\"50\":1,\"51\":1,\"66\":1,\"67\":1,\"141\":1,\"155\":1,\"164\":1}}],[\"语法\",{\"1\":{\"154\":1}}],[\"语法分析对我而言一直是迷一样的存在\",{\"1\":{\"206\":1}}],[\"语法分析更困难\",{\"1\":{\"180\":1}}],[\"语法分析的入口\",{\"1\":{\"111\":1}}],[\"语法分析器的复杂度会大大降低\",{\"1\":{\"132\":1}}],[\"语法分析器\",{\"1\":{\"110\":1}}],[\"语法分析是一样的\",{\"1\":{\"109\":1}}],[\"语法分析\",{\"0\":{\"206\":1},\"1\":{\"105\":1,\"203\":1}}],[\"语句简单\",{\"1\":{\"176\":1}}],[\"语句比\",{\"1\":{\"176\":1}}],[\"语句后方的代码\",{\"1\":{\"175\":1}}],[\"语句是可以省略的\",{\"1\":{\"175\":1}}],[\"语句的作用是跳转\",{\"1\":{\"175\":1}}],[\"语句和表达式的解析\",{\"1\":{\"173\":1}}],[\"语句就是用来向前查看标记以确定使用哪一个产生式\",{\"1\":{\"159\":1}}],[\"语句\",{\"0\":{\"174\":1,\"175\":1,\"176\":1,\"177\":1},\"1\":{\"103\":1,\"109\":1,\"113\":1,\"121\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":5,\"174\":1,\"175\":1,\"177\":1,\"181\":1,\"196\":2,\"203\":1}}],[\"语言运算符优先级\",{\"1\":{\"182\":1}}],[\"语言定义了各种表达式的优先级\",{\"1\":{\"182\":1}}],[\"语言区分\",{\"1\":{\"174\":1}}],[\"语言不太一致\",{\"1\":{\"170\":1}}],[\"语言与现代的\",{\"1\":{\"170\":1}}],[\"语言中唯一的一个三元运算符\",{\"1\":{\"196\":1}}],[\"语言中\",{\"1\":{\"142\":1,\"198\":1}}],[\"语言中标识符可以是全局的也可以是局部的\",{\"1\":{\"139\":1}}],[\"语言中空格是用来作为分隔用的\",{\"1\":{\"136\":1}}],[\"语言中的优先级有关\",{\"1\":{\"135\":1}}],[\"语言中的赋值语句\",{\"1\":{\"118\":1}}],[\"语言中我们经常使用的\",{\"1\":{\"128\":1}}],[\"语言中支持的运算符都提供对应汇编指令\",{\"1\":{\"127\":1}}],[\"语言调用标准\",{\"1\":{\"122\":1}}],[\"语言代码\",{\"1\":{\"111\":1}}],[\"语言程序\",{\"1\":{\"111\":1}}],[\"语言的时候你可能已经知道了\",{\"1\":{\"200\":1}}],[\"语言的字符串常量支持如下风格\",{\"1\":{\"184\":1}}],[\"语言的文法\",{\"1\":{\"155\":1}}],[\"语言的宏定义以字符\",{\"1\":{\"138\":1}}],[\"语言的调用标准是\",{\"1\":{\"122\":1}}],[\"语言的源代码文件\",{\"1\":{\"109\":1}}],[\"语言的解释器\",{\"1\":{\"109\":1}}],[\"语言的编译器\",{\"1\":{\"103\":1}}],[\"语言编译器系列共有10个部分\",{\"1\":{\"103\":1,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1}}],[\"语言编译器\",{\"0\":{\"103\":1,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1},\"1\":{\"103\":13,\"106\":3,\"109\":12,\"113\":11,\"131\":10,\"147\":10,\"155\":10,\"164\":10,\"173\":10,\"181\":10,\"203\":11}}],[\"函数结束时退出进程\",{\"1\":{\"201\":1}}],[\"函数调用\",{\"1\":{\"181\":1}}],[\"函数体的代码如下\",{\"1\":{\"170\":1}}],[\"函数体的解析\",{\"0\":{\"170\":1},\"1\":{\"164\":1}}],[\"函数参数与汇编代码\",{\"0\":{\"167\":1},\"1\":{\"164\":1}}],[\"函数包装起来\",{\"1\":{\"161\":1}}],[\"函数是一个辅助函数\",{\"1\":{\"161\":1}}],[\"函数我们将放到下一章中讲解\",{\"1\":{\"161\":1}}],[\"函数还没有出现过\",{\"1\":{\"158\":1}}],[\"函数的内容\",{\"1\":{\"158\":1}}],[\"函数的主体\",{\"1\":{\"136\":1}}],[\"函数的实现本身就十分复杂\",{\"1\":{\"128\":1}}],[\"函数就是用于输出\",{\"1\":{\"128\":1}}],[\"函数中加入下列代码\",{\"1\":{\"118\":1,\"129\":1}}],[\"函数中加入初始化代码\",{\"1\":{\"116\":1}}],[\"函数\",{\"1\":{\"111\":1,\"158\":1,\"167\":1,\"201\":1}}],[\"函数定义的解析\",{\"0\":{\"168\":1},\"1\":{\"164\":1}}],[\"函数定义\",{\"1\":{\"103\":1,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":2,\"164\":2,\"173\":1,\"181\":1,\"203\":1}}],[\"函数取模\",{\"0\":{\"39\":1}}],[\"61\",{\"1\":{\"140\":1}}],[\"64\",{\"1\":{\"129\":2}}],[\"6\",{\"1\":{\"103\":1,\"109\":1,\"113\":2,\"128\":1,\"131\":2,\"147\":2,\"150\":1,\"155\":1,\"164\":2,\"173\":1,\"174\":1,\"181\":3,\"201\":1,\"203\":1}}],[\"65\",{\"1\":{\"16\":1}}],[\"设置了正确的类型\",{\"1\":{\"166\":1}}],[\"设置把你主机\",{\"1\":{\"31\":1}}],[\"设计我们自己的指令集\",{\"1\":{\"113\":1}}],[\"设计\",{\"0\":{\"109\":1},\"1\":{\"103\":1,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1}}],[\"三目运算符\",{\"0\":{\"196\":1},\"1\":{\"181\":1}}],[\"三点水\",{\"1\":{\"103\":1}}],[\"三是式子太长\",{\"1\":{\"38\":1}}],[\"原则上我们需要立即计算\",{\"1\":{\"182\":1}}],[\"原则上我们是不讲这么深入\",{\"1\":{\"152\":1}}],[\"原因之一就是减少了语法分析器需要\",{\"1\":{\"142\":1}}],[\"原因有二\",{\"1\":{\"134\":1}}],[\"原因是当我们从子函数中返回时\",{\"1\":{\"122\":1}}],[\"原因是默认计算的结果是存放在\",{\"1\":{\"118\":1}}],[\"原因是太复杂了\",{\"1\":{\"105\":1}}],[\"原因只有一个\",{\"1\":{\"104\":1}}],[\"原文链接\",{\"1\":{\"103\":2}}],[\"原文转载自\",{\"1\":{\"89\":1,\"93\":1}}],[\"原作者\",{\"1\":{\"103\":1}}],[\"前缀形式\",{\"1\":{\"199\":1}}],[\"前文中我们说到\",{\"1\":{\"189\":1}}],[\"前文中我们定义了支持的类型\",{\"1\":{\"159\":1}}],[\"前言\",{\"0\":{\"103\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1},\"1\":{\"103\":2,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1}}],[\"前端\",{\"1\":{\"14\":1}}],[\"手把手教你构建\",{\"0\":{\"103\":1,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1},\"1\":{\"103\":13,\"109\":12,\"113\":12,\"131\":11,\"147\":11,\"155\":11,\"164\":11,\"173\":11,\"181\":11,\"203\":11}}],[\"手动修改后可正常运行\",{\"1\":{\"87\":1}}],[\"您可以免费安装并使用\",{\"1\":{\"102\":1}}],[\"启动\",{\"1\":{\"102\":1}}],[\"启动项目\",{\"0\":{\"18\":1}}],[\"复制到\",{\"1\":{\"102\":1}}],[\"复杂演示推荐\",{\"1\":{\"95\":1}}],[\"密码\",{\"1\":{\"102\":1}}],[\"百度网盘\",{\"1\":{\"102\":1}}],[\"官网\",{\"1\":{\"102\":1}}],[\"官方推荐的\",{\"1\":{\"31\":1}}],[\"适用于编写笔记\",{\"1\":{\"102\":1}}],[\"教程\",{\"0\":{\"101\":1}}],[\"准备好了吗\",{\"1\":{\"98\":1}}],[\"展示如何用闭包来实现这一点\",{\"1\":{\"98\":1}}],[\"页面\",{\"1\":{\"97\":1}}],[\"才能正常看到渲染后的\",{\"1\":{\"97\":1}}],[\"才能透过现象\",{\"1\":{\"93\":1}}],[\"预览功能\",{\"1\":{\"97\":1}}],[\"转换成对应的汇编代码\",{\"1\":{\"167\":1}}],[\"转而使用\",{\"1\":{\"97\":1}}],[\"转载声明\",{\"0\":{\"112\":1}}],[\"转载工具\",{\"1\":{\"103\":1}}],[\"转载请附上原文出处链接和本声明\",{\"1\":{\"29\":1}}],[\"转载自\",{\"1\":{\"28\":1}}],[\"卸载\",{\"1\":{\"97\":1}}],[\"禁用\",{\"1\":{\"97\":1}}],[\"渲染插件\",{\"1\":{\"97\":1}}],[\"⚠️注意事项\",{\"1\":{\"97\":1}}],[\"缺点\",{\"0\":{\"96\":1,\"97\":1}}],[\"文法\",{\"1\":{\"206\":1}}],[\"文法的关系\",{\"1\":{\"206\":1}}],[\"文章\",{\"1\":{\"108\":1}}],[\"文档和博客等\",{\"1\":{\"102\":1}}],[\"文档\",{\"1\":{\"94\":1}}],[\"文件\",{\"1\":{\"102\":1}}],[\"文件来实现风格统一\",{\"1\":{\"44\":1}}],[\"文件目录\",{\"1\":{\"32\":1}}],[\"文件管理器\",{\"1\":{\"32\":1}}],[\"文件的实际位置很奇怪\",{\"1\":{\"31\":1}}],[\"把握本质\",{\"1\":{\"93\":1}}],[\"脱离具体场景孤立存在的\",{\"1\":{\"93\":1}}],[\"脱离对象孤立存在的\",{\"1\":{\"93\":1}}],[\"抛开场景谈逻辑\",{\"1\":{\"93\":1}}],[\"抛开剂量谈毒性\",{\"1\":{\"93\":1}}],[\"道德不是空泛的\",{\"1\":{\"93\":1}}],[\"给一个健康的人注射吗啡是犯罪\",{\"1\":{\"93\":1}}],[\"只支持枚举\",{\"1\":{\"159\":1}}],[\"只支持\",{\"1\":{\"142\":1}}],[\"只有身在其中的我们才能体会吧\",{\"1\":{\"208\":1}}],[\"只有\",{\"1\":{\"118\":1}}],[\"只有掌握了辩证的矛盾思维才能更全面更灵活的看待问题\",{\"1\":{\"93\":1}}],[\"只是在编写代码的过程中\",{\"1\":{\"207\":1}}],[\"只是在实现\",{\"1\":{\"193\":1}}],[\"只是这时就是提前看k个\",{\"1\":{\"142\":1}}],[\"只是现在还用不着\",{\"1\":{\"129\":1}}],[\"只是现在用\",{\"1\":{\"126\":1}}],[\"只是我们的指令集中并没有\",{\"1\":{\"125\":1}}],[\"只是它们的功能都过于强大\",{\"1\":{\"110\":1}}],[\"只是对于一般的学生或程序员来说\",{\"1\":{\"105\":1}}],[\"只能说它是一个相当大的挑战吧\",{\"1\":{\"104\":1}}],[\"只关注最终结果一致性\",{\"1\":{\"93\":1}}],[\"只不过这个让出的过程是线程调度器主动抢占的\",{\"1\":{\"89\":1}}],[\"没有什么值得说明的内容\",{\"1\":{\"176\":1}}],[\"没有学过编译原理的话可能并不知道什么是\",{\"1\":{\"149\":1}}],[\"没有参数的指令在后\",{\"1\":{\"117\":1}}],[\"没有主动放弃执行权\",{\"1\":{\"93\":1}}],[\"没锁的话\",{\"1\":{\"90\":1}}],[\"还有就是写这个系列的文章\",{\"1\":{\"207\":1}}],[\"还有就是调试编译器\",{\"1\":{\"207\":1}}],[\"还有两个重要函数没有完成\",{\"1\":{\"171\":1}}],[\"还剩最后一部分没有完成\",{\"1\":{\"179\":1}}],[\"还记得前面说的标识符\",{\"1\":{\"144\":1}}],[\"还要考虑如何传递参数和如何返回结果\",{\"1\":{\"122\":1}}],[\"还没仔细了解过\",{\"1\":{\"108\":1}}],[\"还想变量安全\",{\"1\":{\"92\":1}}],[\"还是实现起来\",{\"1\":{\"206\":1}}],[\"还是函数的局部变量\",{\"1\":{\"167\":1}}],[\"还是过程中\",{\"1\":{\"92\":1}}],[\"还是只能加锁\",{\"1\":{\"92\":1}}],[\"还是只能一个人打电话\",{\"1\":{\"90\":1}}],[\"还是最后执行结果\",{\"1\":{\"92\":1}}],[\"世界上的事情本来就是这样\",{\"1\":{\"92\":1}}],[\"话说回来\",{\"1\":{\"92\":1}}],[\"切换过程是协作的\",{\"1\":{\"92\":1}}],[\"连最终一致性也无法保证\",{\"1\":{\"92\":1}}],[\"连接你的\",{\"1\":{\"31\":1}}],[\"意味着协程操作变量的最终一致性是可以保证的\",{\"1\":{\"92\":1}}],[\"变量赋值\",{\"1\":{\"181\":1}}],[\"变量与函数调用\",{\"0\":{\"186\":1},\"1\":{\"181\":1,\"189\":1}}],[\"变量类型的表示\",{\"1\":{\"159\":1}}],[\"变量是\",{\"1\":{\"139\":1}}],[\"变量定义\",{\"1\":{\"103\":1,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":2,\"164\":2,\"173\":1,\"181\":1,\"203\":1}}],[\"变量balance的最终结果是0\",{\"1\":{\"92\":1}}],[\"变量的状态并不会进行同步\",{\"1\":{\"92\":1}}],[\"混乱状态\",{\"1\":{\"92\":1}}],[\"状态机\",{\"1\":{\"205\":1}}],[\"状态一致\",{\"1\":{\"92\":1}}],[\"状自然数系统\",{\"1\":{\"80\":1}}],[\"998\",{\"1\":{\"132\":3}}],[\"998244353>\",{\"1\":{\"40\":3}}],[\"998244353\",{\"1\":{\"36\":1}}],[\"98\",{\"1\":{\"105\":1}}],[\"9\",{\"1\":{\"92\":1,\"103\":1,\"109\":1,\"113\":2,\"131\":2,\"139\":1,\"140\":6,\"147\":1,\"153\":2,\"155\":1,\"164\":1,\"173\":1,\"181\":2,\"203\":2}}],[\"再将\",{\"1\":{\"199\":1}}],[\"再赋上局部变量相关的信息\",{\"1\":{\"169\":1}}],[\"再例如\",{\"1\":{\"132\":1}}],[\"再也没有异步的加持了\",{\"1\":{\"92\":1}}],[\"再进行减法运算\",{\"1\":{\"92\":1}}],[\"再根据\",{\"1\":{\"50\":1,\"51\":1,\"66\":1,\"67\":1}}],[\"逻辑运算符\",{\"0\":{\"197\":1},\"1\":{\"181\":1}}],[\"逻辑取反\",{\"0\":{\"190\":1},\"1\":{\"181\":1}}],[\"逻辑也较为直接\",{\"1\":{\"140\":1}}],[\"逻辑有了些许修改\",{\"1\":{\"92\":1}}],[\"逻辑紧凑\",{\"1\":{\"91\":1}}],[\"继续执行我们当前的任务\",{\"1\":{\"92\":1}}],[\"让我们继续讲解如何把运算符编译成汇编代码吧\",{\"1\":{\"194\":1}}],[\"让我们继续之前的逻辑\",{\"1\":{\"92\":1}}],[\"让我们开始这段有趣的旅程吧\",{\"1\":{\"98\":1}}],[\"让我们来看一下代码运行结果\",{\"1\":{\"92\":1}}],[\"让别的协程运行\",{\"1\":{\"92\":1}}],[\"让别的线程有机会执行\",{\"1\":{\"90\":1}}],[\"让出了使用权\",{\"1\":{\"92\":1}}],[\"又想多协程\",{\"1\":{\"92\":1}}],[\"又要共享状态\",{\"1\":{\"92\":1}}],[\"又或者别的协程任务也\",{\"1\":{\"92\":1}}],[\"又不确定性\",{\"1\":{\"90\":1}}],[\"随后立刻切换回来\",{\"1\":{\"92\":1}}],[\"随后当我们让出使用权1秒之后\",{\"1\":{\"92\":1}}],[\"随笔\",{\"0\":{\"2\":1}}],[\"别的协程就可以进行执行\",{\"1\":{\"92\":1}}],[\"别的线程表一定不能改\",{\"1\":{\"90\":1}}],[\"此时的二元运算符的解析的框架为\",{\"1\":{\"194\":1}}],[\"此时运算符栈为空\",{\"1\":{\"182\":1}}],[\"此时判断参数\",{\"1\":{\"182\":1}}],[\"此时我们期待的是+的另一个参数\",{\"1\":{\"182\":1}}],[\"此时我们可以使用ionic无缝将其迁移到移动端\",{\"1\":{\"84\":1}}],[\"此时\",{\"1\":{\"175\":1,\"195\":1}}],[\"此时使用权让出以后\",{\"1\":{\"92\":1}}],[\"暂时\",{\"1\":{\"92\":1}}],[\"关于编代码\",{\"0\":{\"207\":1},\"1\":{\"203\":1}}],[\"关于变量\",{\"1\":{\"186\":1}}],[\"关于表达式的解析\",{\"1\":{\"183\":1}}],[\"关键是判断\",{\"1\":{\"188\":1}}],[\"关键就是去理解汇编代码的执行原理\",{\"1\":{\"180\":1}}],[\"关键字与内置函数\",{\"0\":{\"144\":1},\"1\":{\"131\":1}}],[\"关键字\",{\"1\":{\"92\":1,\"144\":1}}],[\"关闭vscode\",{\"1\":{\"45\":1}}],[\"那诸如\",{\"1\":{\"186\":1}}],[\"那意味着也支持指针的指针\",{\"1\":{\"159\":1}}],[\"那就不需要加锁\",{\"1\":{\"93\":1}}],[\"那就是\",{\"1\":{\"144\":1}}],[\"那就是最大的道德\",{\"1\":{\"93\":1}}],[\"那就是任务又回到了线性同步执行\",{\"1\":{\"92\":1}}],[\"那就是代码中没有\",{\"1\":{\"92\":1}}],[\"那到底怎么主动让出使用权\",{\"1\":{\"92\":1}}],[\"那么对变量\",{\"1\":{\"189\":1}}],[\"那么如何确定运算符的优先级呢\",{\"1\":{\"182\":1}}],[\"那么外层的\",{\"1\":{\"168\":1}}],[\"那么它应该被转换成什么样的汇编代码呢\",{\"1\":{\"167\":1}}],[\"那么我们如何表示指针类型呢\",{\"1\":{\"159\":1}}],[\"那么我们怎么表示标识符呢\",{\"1\":{\"139\":1}}],[\"那么参数的传递呢\",{\"1\":{\"122\":1}}],[\"那么就在返回时保存在\",{\"1\":{\"122\":1}}],[\"那么你会发现\",{\"1\":{\"105\":1}}],[\"那么为什么要学习编译原理呢\",{\"1\":{\"104\":1}}],[\"那么协程一定是安全的\",{\"1\":{\"92\":1}}],[\"那么值会是0\",{\"1\":{\"90\":1}}],[\"上节中说到了运算符的优先级\",{\"1\":{\"183\":1}}],[\"上的\",{\"1\":{\"167\":1}}],[\"上一章的代码中\",{\"1\":{\"166\":1}}],[\"上述代码中我们看到\",{\"1\":{\"142\":1}}],[\"上述等式表明\",{\"1\":{\"72\":1}}],[\"上面这断代码为当前的标识符设置了正确的类别\",{\"1\":{\"166\":1}}],[\"上面这些标记是有顺序的\",{\"1\":{\"135\":1}}],[\"上面这段代码在我们自己的虚拟机里会有几个问题\",{\"1\":{\"122\":1}}],[\"上面的一些指令解决了调用帧的问题\",{\"1\":{\"126\":1}}],[\"上面的代码运行后会出现\",{\"1\":{\"145\":1}}],[\"上面的代码看上去挺复杂\",{\"1\":{\"111\":1}}],[\"上面的代码也充分说明了这个结论的正确性\",{\"1\":{\"92\":1}}],[\"上下载\",{\"1\":{\"111\":1,\"130\":1,\"145\":1,\"162\":1,\"171\":1,\"179\":1,\"201\":1}}],[\"上看到了一个项目\",{\"1\":{\"106\":1}}],[\"谁举证\",{\"1\":{\"92\":1}}],[\"谁主张\",{\"1\":{\"92\":1}}],[\"毫无疑问\",{\"1\":{\"92\":2}}],[\"运行程序\",{\"1\":{\"129\":1}}],[\"运行我们的指令集\",{\"1\":{\"113\":1}}],[\"运行结果\",{\"1\":{\"92\":1}}],[\"运算符出栈\",{\"1\":{\"182\":2}}],[\"运算符运算等等\",{\"1\":{\"181\":1}}],[\"运算符的优先级决定了表达式的运算顺序\",{\"1\":{\"182\":1}}],[\"运算符的优先级\",{\"0\":{\"182\":1},\"1\":{\"181\":1}}],[\"运算符指令\",{\"0\":{\"127\":1},\"1\":{\"113\":1}}],[\"运算更快\",{\"1\":{\"40\":1}}],[\"既然同一时间只能有一个协程任务运行\",{\"1\":{\"92\":1}}],[\"避免了多线程的上下文切换\",{\"1\":{\"91\":1}}],[\"体本身就无缝保持了程序状态\",{\"1\":{\"91\":1}}],[\"闭包实现类\",{\"0\":{\"98\":1}}],[\"闭包\",{\"1\":{\"91\":1}}],[\"比起可怕的\",{\"1\":{\"105\":1}}],[\"比操作系统的抢占式调度所需要的时间代价要小很多\",{\"1\":{\"91\":1}}],[\"比如大量的\",{\"1\":{\"36\":1}}],[\"比如\",{\"1\":{\"31\":1}}],[\"人们发现经常需要异步操作共享资源的情况下\",{\"1\":{\"91\":1}}],[\"过了一段时间\",{\"1\":{\"91\":1}}],[\"过去的做法\",{\"0\":{\"37\":1}}],[\"抢占式的线程就不那么让人愉快了\",{\"1\":{\"90\":1}}],[\"抢占式的线程调度器是非常不错的选择\",{\"1\":{\"90\":1}}],[\"因而灵活性较差\",{\"1\":{\"108\":1}}],[\"因为已经有许多自动生成的工具支持它们\",{\"1\":{\"206\":1}}],[\"因为只有一个参数\",{\"1\":{\"182\":1}}],[\"因为汇编代码是顺序排列的\",{\"1\":{\"175\":1,\"182\":1}}],[\"因为汇编语言就是\",{\"1\":{\"130\":1}}],[\"因为这决定了我们需要从解析中获取什么样的信息\",{\"1\":{\"172\":1}}],[\"因为这决定了在解析时我们需要哪些相关的信息\",{\"1\":{\"167\":1}}],[\"因为这样实现起来就会变得复杂\",{\"1\":{\"122\":1}}],[\"因为还有许多功能没有实现\",{\"1\":{\"162\":1}}],[\"因为它们可以用\",{\"1\":{\"149\":1}}],[\"因为它会尝试运行我们上一章创建的虚拟机\",{\"1\":{\"145\":1}}],[\"因为它可以保证所有的线程都可以被分到时间片不被垃圾代码所拖累\",{\"1\":{\"90\":1}}],[\"因为有特殊的含义\",{\"1\":{\"144\":1}}],[\"因为输入的字符串比较难处理\",{\"1\":{\"133\":1}}],[\"因为像\",{\"1\":{\"127\":1}}],[\"因为我们不在乎出栈的值\",{\"1\":{\"186\":1}}],[\"因为我们需要先对它们进行解析\",{\"1\":{\"183\":1}}],[\"因为我们会在代码段\",{\"1\":{\"115\":1}}],[\"因为我们的编译器并不支持初始化变量\",{\"1\":{\"115\":1}}],[\"因为不关心其中的真正数值\",{\"1\":{\"115\":1}}],[\"因为好多理论根本用不上\",{\"1\":{\"105\":1}}],[\"因为协程是用户态\",{\"1\":{\"92\":1}}],[\"因为线程是系统态切换\",{\"1\":{\"92\":1}}],[\"因此对应的源码如下\",{\"1\":{\"198\":1}}],[\"因此对于需要讲解的运算符\",{\"1\":{\"183\":1}}],[\"因此要有特殊的处理\",{\"1\":{\"198\":1}}],[\"因此将它们放在一起处理\",{\"1\":{\"186\":1}}],[\"因此得到结果\",{\"1\":{\"182\":1}}],[\"因此只凭当前的字符我们并无法确定具体应该解释成哪一个标记\",{\"1\":{\"142\":1}}],[\"因此在实现中我们将它作为\",{\"1\":{\"136\":1}}],[\"因此在\",{\"1\":{\"129\":1}}],[\"因此在我们的编译器\",{\"1\":{\"128\":1}}],[\"因此编译编译器时\",{\"1\":{\"128\":1}}],[\"因此计算结束后\",{\"1\":{\"127\":1}}],[\"因此实际中我们将\",{\"1\":{\"122\":1}}],[\"因此我们要做的就是生成类似的汇编代码\",{\"1\":{\"200\":1}}],[\"因此我们要消除左递归\",{\"1\":{\"152\":1}}],[\"因此我们判断它是否与数字\",{\"1\":{\"190\":1}}],[\"因此我们删除相应的指令\",{\"1\":{\"189\":1}}],[\"因此我们可以利用这一点\",{\"1\":{\"130\":1}}],[\"因此我们继续实现新的指令\",{\"1\":{\"128\":1}}],[\"因此我们采用的方法是增加指令集\",{\"1\":{\"122\":1}}],[\"因此我们将\",{\"1\":{\"118\":1}}],[\"因此我们也不需要未初始化数据段\",{\"1\":{\"115\":1}}],[\"因此先不处理\",{\"1\":{\"116\":1}}],[\"因此简单起见\",{\"1\":{\"115\":1}}],[\"因此一个进程可以容纳数量相当可观的协程任务\",{\"1\":{\"91\":1}}],[\"因此假设不成立\",{\"1\":{\"75\":1}}],[\"因此\",{\"1\":{\"38\":1,\"60\":2,\"62\":2,\"63\":1,\"74\":1,\"167\":2}}],[\"而忽略了同样重要的代码生成\",{\"1\":{\"204\":1}}],[\"而是如何为运算符生成相应的汇编代码\",{\"1\":{\"204\":1}}],[\"而是单个数字的取正取负操作\",{\"1\":{\"192\":1}}],[\"而是操作\",{\"1\":{\"115\":1}}],[\"而数字\",{\"1\":{\"190\":1}}],[\"而就像上节中提到的\",{\"1\":{\"188\":1}}],[\"而普通的函数则编译成\",{\"1\":{\"186\":1}}],[\"而剩下的较难较烦的部分是与目标代码的生成有关的\",{\"1\":{\"183\":1}}],[\"而真正的难点是如何在语法分析时收集足够多的信息\",{\"1\":{\"180\":1}}],[\"而它们的逻辑和全局变量的解析几乎一致\",{\"1\":{\"172\":1}}],[\"而②则用于生成汇编代码\",{\"1\":{\"170\":1}}],[\"而②则与上节中提到的\",{\"1\":{\"169\":1}}],[\"而②中的代码是用于将符号表中的信息恢复成全局的信息\",{\"1\":{\"168\":1}}],[\"而注意到上节中\",{\"1\":{\"160\":1}}],[\"而如果\",{\"1\":{\"198\":1}}],[\"而如果是全局变量则用\",{\"1\":{\"186\":1}}],[\"而如果只解析到类型\",{\"1\":{\"159\":1}}],[\"而如果操作同一资源\",{\"1\":{\"90\":1}}],[\"而为了实现自举\",{\"1\":{\"156\":1}}],[\"而左递归的语法是没法直接使用递归下降的方法实现的\",{\"1\":{\"152\":1}}],[\"而没有出现在\",{\"1\":{\"149\":1}}],[\"而我们可以从解析的过程中看出\",{\"1\":{\"150\":1}}],[\"而我们定义的语法不支持\",{\"1\":{\"139\":1}}],[\"而我们还存放了一些只有语法分析器才会得到的信息\",{\"1\":{\"139\":1}}],[\"而我们又不希望扩充现有指令的功能\",{\"1\":{\"122\":1}}],[\"而我们又想在执行过程中保证共享数据的强一致性\",{\"1\":{\"92\":1}}],[\"而之后的语句\",{\"1\":{\"139\":1}}],[\"而只关心这个变量名代表的唯一标识\",{\"1\":{\"139\":1}}],[\"而词法分析器能减小语法分析复杂度的原因\",{\"1\":{\"135\":1}}],[\"而词法分析器则是以源码字符串为输入\",{\"1\":{\"133\":1}}],[\"而标记流对于语法分析器而言就容易处理得多了\",{\"1\":{\"133\":1}}],[\"而在我们的虚拟机中\",{\"1\":{\"119\":1}}],[\"而不是\",{\"1\":{\"142\":1,\"151\":1,\"182\":1}}],[\"而不是硬编码\",{\"1\":{\"24\":1}}],[\"而不能以值作为参数\",{\"1\":{\"118\":1}}],[\"而地址通常是需要通过计算获得\",{\"1\":{\"118\":1}}],[\"而这就意味着我们需要决定先为哪个运算符生成目标代码\",{\"1\":{\"182\":1}}],[\"而这些可能需要你重新回顾一下\",{\"1\":{\"172\":1}}],[\"而这些寄存器只是用于保存这些状态的\",{\"1\":{\"116\":1}}],[\"而这个标记足够让我们确定用哪个表达式了\",{\"1\":{\"151\":1}}],[\"而这部分能帮助我们了解计算机的工作原理\",{\"1\":{\"109\":1}}],[\"而电脑上的实际内存可能只有\",{\"1\":{\"115\":1}}],[\"而其它方面如词法分析\",{\"1\":{\"109\":1}}],[\"而\",{\"1\":{\"106\":1,\"118\":1,\"168\":2,\"194\":1}}],[\"而会不会写编译器则是第二道\",{\"1\":{\"104\":1}}],[\"而协程虽然在手动切换过程中也无法保证状态一致\",{\"1\":{\"92\":1}}],[\"而线程是抢占使用权\",{\"1\":{\"91\":1}}],[\"而有没有锁\",{\"1\":{\"90\":1}}],[\"而现在\",{\"1\":{\"90\":1}}],[\"处理器本来同一时间就只能有一个线程在运行\",{\"1\":{\"90\":1}}],[\"然而如果你能跟我一样\",{\"1\":{\"105\":1}}],[\"然而我们都忽略了一个客观事实\",{\"1\":{\"92\":1}}],[\"然而人们很快发现\",{\"1\":{\"90\":1}}],[\"然后返回它在\",{\"1\":{\"141\":1}}],[\"然后\",{\"1\":{\"90\":1}}],[\"然后才能去处理另一件事情\",{\"1\":{\"89\":1}}],[\"然后在\",{\"1\":{\"31\":1}}],[\"然后就能正常访问\",{\"1\":{\"18\":1}}],[\"防止中途出错了\",{\"1\":{\"90\":1}}],[\"交替进行\",{\"1\":{\"90\":1}}],[\"如变量\",{\"1\":{\"183\":1}}],[\"如在普通的四则运算中\",{\"1\":{\"182\":1}}],[\"如经典的\",{\"1\":{\"151\":1}}],[\"如为什么用\",{\"1\":{\"151\":1}}],[\"如本例需向前查看一个字符\",{\"1\":{\"142\":1}}],[\"如本小节中的注释与除号\",{\"1\":{\"142\":1}}],[\"如标识符是函数\",{\"1\":{\"139\":1}}],[\"如数字\",{\"1\":{\"139\":1}}],[\"如右方括号\",{\"1\":{\"135\":1}}],[\"如只能操作ax寄存器\",{\"1\":{\"122\":1}}],[\"如下\",{\"1\":{\"118\":1,\"122\":1,\"139\":1,\"167\":1}}],[\"如调用帧\",{\"1\":{\"115\":1}}],[\"如int\",{\"1\":{\"115\":1}}],[\"如实现四则运算\",{\"1\":{\"106\":1}}],[\"如\",{\"1\":{\"105\":1,\"106\":1,\"108\":1,\"110\":1,\"115\":1,\"134\":1,\"135\":2,\"138\":1,\"139\":1,\"141\":2,\"149\":1,\"159\":4,\"167\":2,\"169\":1,\"186\":1,\"193\":1,\"198\":1}}],[\"如有侵权\",{\"1\":{\"103\":1,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1}}],[\"如果有兴趣\",{\"1\":{\"206\":1}}],[\"如果今后你仍然想编写编译器\",{\"1\":{\"205\":1}}],[\"如果\",{\"1\":{\"198\":1}}],[\"如果是两个指针相减\",{\"1\":{\"198\":1}}],[\"如果是局部变量则采用与\",{\"1\":{\"186\":1}}],[\"如果是指针的指针\",{\"1\":{\"159\":1}}],[\"如果条件失败\",{\"1\":{\"175\":1}}],[\"如果不是预期的标记则报错并退出\",{\"1\":{\"161\":1}}],[\"如果不想看可以跳过\",{\"1\":{\"156\":1}}],[\"如果遇到标识符就用\",{\"1\":{\"186\":1}}],[\"如果遇到\",{\"1\":{\"159\":1}}],[\"如果分析到字符串\",{\"1\":{\"141\":1}}],[\"如果标识符已经存在\",{\"1\":{\"139\":1}}],[\"如果我们的编译器要达到自举\",{\"1\":{\"128\":1}}],[\"如果我们不关注执行过程中的状态\",{\"1\":{\"93\":1}}],[\"如果子函数有返回结果\",{\"1\":{\"122\":1}}],[\"如果要我说计算机专业最重要的三门课\",{\"1\":{\"104\":1}}],[\"如果你按这个系列自己编写代码\",{\"1\":{\"207\":1}}],[\"如果你理解了上一章中的内容\",{\"1\":{\"163\":1}}],[\"如果你尝试阅读\",{\"1\":{\"105\":1}}],[\"如果你急切地想进入正篇\",{\"1\":{\"103\":1}}],[\"如果你的\",{\"1\":{\"97\":1}}],[\"如果在逻辑执行过程中我们需要判断变量状态\",{\"1\":{\"93\":1}}],[\"如果协程在操作共享变量的过程中\",{\"1\":{\"93\":1}}],[\"如果每个线程按顺序执行\",{\"1\":{\"90\":1}}],[\"如此往复\",{\"1\":{\"92\":1}}],[\"如图所示\",{\"1\":{\"91\":1}}],[\"如何为每个运算符生成对应的汇编代码\",{\"1\":{\"202\":1}}],[\"如何通过递归调用\",{\"1\":{\"202\":1}}],[\"如何确定具体选择哪一个\",{\"1\":{\"151\":1}}],[\"如何处理错误\",{\"1\":{\"136\":1}}],[\"如何表示语法\",{\"1\":{\"105\":1}}],[\"如何实现风格统一\",{\"1\":{\"44\":1}}],[\"如何给python\",{\"1\":{\"25\":1}}],[\"最好的方式恐怕还是要自己实现它\",{\"1\":{\"207\":1}}],[\"最近知道了一个叫\",{\"1\":{\"206\":1}}],[\"最为重要的是能\",{\"1\":{\"204\":1}}],[\"最终都根据它们的类型用\",{\"1\":{\"186\":1}}],[\"最终把源代码转换成目标代码\",{\"1\":{\"180\":1}}],[\"最终构建起我们的编译器\",{\"1\":{\"111\":1}}],[\"最重要的是理解我们会为函数生成怎样的汇编代码\",{\"1\":{\"172\":1}}],[\"最大的区别就是保存的信息不同\",{\"1\":{\"172\":1}}],[\"最后\",{\"1\":{\"202\":1}}],[\"最后要注意的一点是\",{\"1\":{\"201\":1}}],[\"最后要注意的是还有一些字符\",{\"1\":{\"135\":1}}],[\"最后注意的是优先通常只与多元运算符相关\",{\"1\":{\"182\":1}}],[\"最后是main函数\",{\"1\":{\"153\":1}}],[\"最后再加上一个错误判断\",{\"1\":{\"128\":1}}],[\"最后祝你学得愉快\",{\"1\":{\"108\":1}}],[\"最后想介绍几个资料\",{\"1\":{\"108\":1}}],[\"最后的值不是0\",{\"1\":{\"90\":1}}],[\"最新推荐文章于\",{\"1\":{\"29\":2}}],[\"大量重复的代码特别让人崩溃\",{\"1\":{\"207\":1}}],[\"大量的函数调用将会耗费不少的时间\",{\"1\":{\"39\":1}}],[\"大部分的代码依旧是用于解析变量\",{\"1\":{\"172\":1}}],[\"大致500+行\",{\"1\":{\"106\":1}}],[\"大家又发明了同步锁\",{\"1\":{\"90\":1}}],[\"于是\",{\"1\":{\"90\":1,\"92\":1}}],[\"它涉及到了\",{\"1\":{\"205\":1}}],[\"它相当于一个小型的\",{\"1\":{\"196\":1}}],[\"它相当于\",{\"1\":{\"184\":1}}],[\"它比较特殊的一点是\",{\"1\":{\"184\":1}}],[\"它本身不难\",{\"1\":{\"180\":1}}],[\"它对应的汇编代码如下\",{\"1\":{\"176\":1}}],[\"它将\",{\"1\":{\"161\":1}}],[\"它将自动忽略空白字符\",{\"1\":{\"111\":1}}],[\"它用于将数据放进寄存器或内存地址\",{\"1\":{\"118\":1}}],[\"它用于存放一条指令执行后的结果\",{\"1\":{\"116\":1}}],[\"它存放的是一个内存地址\",{\"1\":{\"116\":1}}],[\"它的类型保存在变量\",{\"1\":{\"188\":1}}],[\"它的优先级和\",{\"1\":{\"182\":1}}],[\"它的运算顺序是这样的\",{\"1\":{\"182\":1}}],[\"它的\",{\"1\":{\"176\":1}}],[\"它的语法更容易理解\",{\"1\":{\"156\":1}}],[\"它的本质上也是编译器\",{\"1\":{\"133\":1}}],[\"它的作用是将\",{\"1\":{\"119\":1}}],[\"它的作用是屏蔽了物理的细节\",{\"1\":{\"115\":1}}],[\"它的流程为\",{\"1\":{\"111\":1}}],[\"它通过定义自己的指令集并支持该指令集的虚拟机来模拟编译的部分过程\",{\"1\":{\"108\":1}}],[\"它最让我震惊的是能够自举\",{\"1\":{\"106\":1}}],[\"它们包括\",{\"1\":{\"198\":1}}],[\"它们对应的汇编代码如下\",{\"1\":{\"197\":1}}],[\"它们是以优先级从低到高排列的\",{\"1\":{\"194\":1}}],[\"它们是单字符的\",{\"1\":{\"135\":1}}],[\"它们的实现都很类似\",{\"1\":{\"198\":1}}],[\"它们的语法分析都相对容易\",{\"1\":{\"174\":1}}],[\"它们的内容比较多\",{\"1\":{\"173\":1}}],[\"它们的具体使用在后面的语法分析中会提到\",{\"1\":{\"135\":1}}],[\"它们会被解析成标识符\",{\"1\":{\"144\":1}}],[\"它们会操作同一个资源\",{\"1\":{\"90\":1}}],[\"它们不能被作为普通的标识符\",{\"1\":{\"144\":1}}],[\"它们不涉及优先级关系\",{\"1\":{\"135\":1}}],[\"它们都有对应的标记\",{\"1\":{\"139\":1}}],[\"它们自己就构成了标记\",{\"1\":{\"135\":1}}],[\"它们可以是一个数\",{\"1\":{\"118\":1}}],[\"它们基于\",{\"1\":{\"117\":1}}],[\"它们就是无符号的\",{\"1\":{\"115\":1}}],[\"它们在内存中的位置类似于下图\",{\"1\":{\"115\":1}}],[\"它们将作为我们的编译器最终输出的目标代码\",{\"1\":{\"113\":1}}],[\"它们过于强大\",{\"1\":{\"105\":1}}],[\"它们有很强的实际意义\",{\"1\":{\"105\":1}}],[\"它可以是一个值\",{\"1\":{\"122\":1}}],[\"它可以挂起当前协程任务\",{\"1\":{\"92\":1}}],[\"它可以在协程内部用await调用另一个协程实现异步操作\",{\"1\":{\"92\":1}}],[\"它能做什么\",{\"1\":{\"92\":1}}],[\"它和线程的最主要差别就是\",{\"1\":{\"91\":1}}],[\"它让调用者自己来决定什么时候让出\",{\"1\":{\"91\":1}}],[\"它应该具有反对称性\",{\"1\":{\"57\":1}}],[\"多线程在未加锁的情况下\",{\"1\":{\"92\":1}}],[\"多线程在python中只能交替执行\",{\"1\":{\"90\":1}}],[\"多线程逻辑执行结果\",{\"1\":{\"92\":1}}],[\"多了把锁\",{\"1\":{\"90\":1}}],[\"多个线程同时改同一个变量\",{\"1\":{\"90\":1}}],[\"多个线程之前也并不是完全独立的\",{\"1\":{\"90\":1}}],[\"就如前文的\",{\"1\":{\"194\":1}}],[\"就可以应付大多数的语法分析器编写\",{\"1\":{\"154\":1}}],[\"就返回它的唯一标识\",{\"1\":{\"139\":1}}],[\"就势必要实现\",{\"1\":{\"128\":1}}],[\"就需要获取并恢复这个信息\",{\"1\":{\"122\":1}}],[\"就需要存放到数据段中\",{\"1\":{\"115\":1}}],[\"就会发现太可怕了\",{\"1\":{\"105\":1}}],[\"就像以前的公共电话亭\",{\"1\":{\"90\":1}}],[\"就算只能用单核处理任务\",{\"1\":{\"90\":1}}],[\"就是指针的加减\",{\"1\":{\"198\":1}}],[\"就是前文提到的\",{\"1\":{\"169\":1}}],[\"就是上述的消除左递归后的文法直接转换而来的\",{\"1\":{\"153\":1}}],[\"就是上例中\",{\"1\":{\"151\":1}}],[\"就是一种用来描述语法的语言\",{\"1\":{\"149\":1}}],[\"就是需要向前看的标记的个数了\",{\"1\":{\"142\":1}}],[\"就是这个标识符的哈希值\",{\"1\":{\"139\":1}}],[\"就是对应字符型和整型的存取操作\",{\"1\":{\"118\":1}}],[\"就是\",{\"1\":{\"51\":1,\"67\":1}}],[\"每写一篇都特别心烦\",{\"1\":{\"207\":1}}],[\"每次遇到换行符\",{\"1\":{\"137\":1}}],[\"每次调用该函数则返回下一个标记\",{\"1\":{\"134\":1}}],[\"每次执行更新你的\",{\"1\":{\"86\":1}}],[\"每个id占用数组中的9个空间\",{\"1\":{\"139\":1}}],[\"每个标记通常包括\",{\"1\":{\"132\":1}}],[\"每个运算符都是二元的\",{\"1\":{\"127\":1}}],[\"每个协程的体积比线程要小得多\",{\"1\":{\"91\":1}}],[\"每执行100条字节码\",{\"1\":{\"90\":1}}],[\"雨露均沾\",{\"1\":{\"90\":1}}],[\"刘悦的技术博客\",{\"1\":{\"89\":1,\"93\":1}}],[\"挂起\",{\"0\":{\"89\":1},\"1\":{\"92\":1}}],[\"线程是系统态\",{\"1\":{\"91\":1}}],[\"线程操作共享资源需要加锁\",{\"1\":{\"90\":1}}],[\"线程并不安全\",{\"1\":{\"90\":1}}],[\"线程共享数据危险在于\",{\"1\":{\"90\":1}}],[\"线程安全\",{\"0\":{\"90\":1}}],[\"线程更被我们所熟知\",{\"1\":{\"89\":1}}],[\"线程\",{\"0\":{\"89\":1}}],[\"协程也不是虚空的\",{\"1\":{\"93\":1}}],[\"协程加锁执行后结果\",{\"1\":{\"92\":1}}],[\"协程在工作状态中\",{\"1\":{\"92\":1}}],[\"协程运行过程中\",{\"1\":{\"92\":1}}],[\"协程又可以切回来\",{\"1\":{\"92\":1}}],[\"协程操作共享变量不需要加锁的结论开始在坊间流传\",{\"1\":{\"92\":1}}],[\"协程本身就是单线程的\",{\"1\":{\"91\":1}}],[\"协程本身可以做成用户态\",{\"1\":{\"91\":1}}],[\"协程是否需要加锁\",{\"0\":{\"93\":1}}],[\"协程是用户态\",{\"1\":{\"91\":1}}],[\"协程是主动让出使用权\",{\"1\":{\"91\":1}}],[\"协程保证了编写过程中的思维连贯性\",{\"1\":{\"91\":1}}],[\"协程与线程向来焦孟不离\",{\"1\":{\"89\":1}}],[\"协程安全\",{\"0\":{\"89\":1,\"92\":1}}],[\"协程\",{\"0\":{\"89\":1,\"91\":1,\"94\":1}}],[\"插件\",{\"1\":{\"86\":1}}],[\"命令\",{\"1\":{\"86\":1}}],[\"后缀形式\",{\"1\":{\"199\":1}}],[\"后面我们会看到\",{\"1\":{\"186\":1}}],[\"后面的文章中\",{\"1\":{\"111\":1}}],[\"后来集成的\",{\"1\":{\"97\":1}}],[\"后者为了能恢复现场会在切换线程时保存相当多的状态\",{\"1\":{\"91\":1}}],[\"后\",{\"1\":{\"86\":1}}],[\"你也可以学习看看\",{\"1\":{\"206\":1}}],[\"你可能有疑问\",{\"1\":{\"186\":1}}],[\"你可能会觉得将一个指令变成了许多指令\",{\"1\":{\"118\":1}}],[\"你就会发现\",{\"1\":{\"133\":1}}],[\"你就能写出更加高效的代码\",{\"1\":{\"104\":1}}],[\"你能对计算机程序的原理有一定的了解\",{\"1\":{\"130\":1}}],[\"你将看到闭包是如何捕获变量并提供类似类的功能的\",{\"1\":{\"98\":1}}],[\"你是否曾经想过\",{\"1\":{\"98\":1}}],[\"你需要将这些更改复制到你的原生项目中\",{\"1\":{\"86\":1}}],[\"你的用\",{\"1\":{\"31\":1}}],[\"默认是\",{\"1\":{\"129\":1}}],[\"默认为\",{\"1\":{\"102\":1}}],[\"默认不支持http\",{\"1\":{\"86\":1}}],[\"默认\",{\"1\":{\"86\":1}}],[\"到底需不需要加锁\",{\"0\":{\"89\":1}}],[\"到底在哪里\",{\"0\":{\"32\":1}}],[\"到任意点的路径\",{\"1\":{\"76\":1}}],[\"点\",{\"1\":{\"76\":1}}],[\"所有的变量定义必须放在语句之前\",{\"1\":{\"201\":1}}],[\"所有点的出度为\",{\"1\":{\"76\":1}}],[\"所谓主动让出使用权\",{\"1\":{\"92\":1}}],[\"所以你可以执行\",{\"1\":{\"201\":1}}],[\"所以源码如下\",{\"1\":{\"197\":1}}],[\"所以生成的代码也类似于\",{\"1\":{\"196\":1}}],[\"所以直接修改栈指针的大小即可\",{\"1\":{\"186\":1}}],[\"所以直接跳过它们\",{\"1\":{\"138\":1}}],[\"所以解析的时候要注意这一点\",{\"1\":{\"184\":1}}],[\"所以先将它入栈\",{\"1\":{\"182\":1}}],[\"所以建议如果没有学过汇编\",{\"1\":{\"180\":1}}],[\"所以不多做说明\",{\"1\":{\"178\":1}}],[\"所以需要生成汇编代码\",{\"1\":{\"177\":1}}],[\"所以需要无条件跳转\",{\"1\":{\"175\":1}}],[\"所以如果执行了\",{\"1\":{\"175\":1}}],[\"所以一个类型首先有基本类型\",{\"1\":{\"159\":1}}],[\"所以还需要继续查看后续的标记\",{\"1\":{\"159\":1}}],[\"所以实际上它们间的对应关系并不是特别明显\",{\"1\":{\"156\":1}}],[\"所以实际的处理方法是提供一个函数\",{\"1\":{\"134\":1}}],[\"所以只能再向前查看字符\",{\"1\":{\"142\":1}}],[\"所以代码中并没有支持除\",{\"1\":{\"141\":1}}],[\"所以这里我们会有这样的印象\",{\"1\":{\"135\":1}}],[\"所以人们已经开发出了许多工具来生成词法分析器\",{\"1\":{\"134\":1}}],[\"所以为了获取第一个参数\",{\"1\":{\"126\":1}}],[\"所以用一个指令代替\",{\"1\":{\"125\":1}}],[\"所以用上面提到的指令\",{\"1\":{\"122\":1}}],[\"所以合在一起说\",{\"1\":{\"122\":1}}],[\"所以此时它存放的是\",{\"1\":{\"120\":1}}],[\"所以执行\",{\"1\":{\"118\":1}}],[\"所以大大简化了实现的难度\",{\"1\":{\"118\":1}}],[\"所以入栈时\",{\"1\":{\"116\":1}}],[\"所以是\",{\"1\":{\"115\":1}}],[\"所以单独存放可以节省空间\",{\"1\":{\"115\":1}}],[\"所以我们需要给予代码生成高度的重视\",{\"1\":{\"204\":1}}],[\"所以我们需要先\",{\"1\":{\"193\":1}}],[\"所以我们首先执行类似前缀自增自减的操作\",{\"1\":{\"199\":1}}],[\"所以我们用异或来实现\",{\"1\":{\"191\":1}}],[\"所以我们将结束符的解析放在了外层的\",{\"1\":{\"168\":1}}],[\"所以我们将它拆分成\",{\"1\":{\"155\":1,\"164\":1}}],[\"所以我们将它单独作为一个模块\",{\"1\":{\"111\":1}}],[\"所以我们先编写一个较为简单的编译器\",{\"1\":{\"133\":1}}],[\"所以我们提供了一个新的指令\",{\"1\":{\"126\":1}}],[\"所以我们不再需要\",{\"1\":{\"125\":1}}],[\"所以我们会依照以下步骤来构建我们的编译器\",{\"1\":{\"110\":1}}],[\"所以我们要完全手写这些功能\",{\"1\":{\"110\":1}}],[\"所以我希望你有足够的耐心和时间来学习\",{\"1\":{\"107\":1}}],[\"所以本项目的主要目的\",{\"1\":{\"106\":1}}],[\"所以写得很乱\",{\"1\":{\"106\":1}}],[\"所以写操作不会被争抢覆盖\",{\"1\":{\"92\":1}}],[\"所以当学校开\",{\"1\":{\"105\":1}}],[\"所以说\",{\"1\":{\"93\":1}}],[\"所以肯定可以保证最终一致性\",{\"1\":{\"92\":1}}],[\"所以它对应的代码为\",{\"1\":{\"198\":1}}],[\"所以它的性能要比多线程好\",{\"1\":{\"91\":1}}],[\"所以它平均地分配时间片让处理器一视同仁\",{\"1\":{\"90\":1}}],[\"所以同一时间点还是只能有一个协程任务运行\",{\"1\":{\"91\":1}}],[\"所以加锁是为了同时只有一个线程再修改\",{\"1\":{\"90\":1}}],[\"所以\",{\"1\":{\"62\":1,\"90\":2,\"194\":2}}],[\"同样\",{\"1\":{\"192\":1}}],[\"同样我们没有相应的指令\",{\"1\":{\"191\":1}}],[\"同样在第三章\",{\"1\":{\"186\":1}}],[\"同样不能确定是否能立即计算\",{\"1\":{\"182\":1}}],[\"同理\",{\"1\":{\"93\":1,\"159\":1}}],[\"同时其它语言也有许多类似的支持\",{\"1\":{\"206\":1}}],[\"同时我们也看到\",{\"1\":{\"204\":1}}],[\"同时我们也用实例看到了理论\",{\"1\":{\"154\":1}}],[\"同时将运算符\",{\"1\":{\"182\":1}}],[\"同时值得一提的是\",{\"1\":{\"180\":1}}],[\"同时记录它们的位置与类型\",{\"1\":{\"169\":1}}],[\"同时能对汇编语言有一定的概念\",{\"1\":{\"130\":1}}],[\"同时在栈上保留一定的空间\",{\"1\":{\"123\":1}}],[\"同时开启四个协程任务\",{\"1\":{\"92\":1}}],[\"同时也不需要系统的线程调度器参与抢占式的调度\",{\"1\":{\"91\":1}}],[\"同时\",{\"1\":{\"91\":1,\"103\":1,\"205\":1}}],[\"同时修改变量\",{\"1\":{\"90\":1}}],[\"同时为了解决多个模数的问题\",{\"1\":{\"40\":1}}],[\"同构\",{\"1\":{\"76\":1}}],[\"用\",{\"1\":{\"184\":1,\"192\":1}}],[\"用来求值\",{\"1\":{\"181\":1}}],[\"用尖括号\",{\"1\":{\"149\":1}}],[\"用作保存全局标识符的信息\",{\"1\":{\"139\":1}}],[\"用更多的指令来完成更多的功能\",{\"1\":{\"130\":1}}],[\"用以存放局部变量\",{\"1\":{\"123\":1}}],[\"用于标识符的快速比较\",{\"1\":{\"139\":1}}],[\"用于实现\",{\"1\":{\"123\":1,\"124\":1}}],[\"用于为程序动态分配内存\",{\"1\":{\"115\":1}}],[\"用于处理函数调用相关的数据\",{\"1\":{\"115\":1}}],[\"用于存放未初始化的数据\",{\"1\":{\"115\":1}}],[\"用于存放初始化了的数据\",{\"1\":{\"115\":1}}],[\"用于存放代码\",{\"1\":{\"115\":1}}],[\"用于解析该参数的类型\",{\"1\":{\"169\":1}}],[\"用于解析枚举类型的定义\",{\"1\":{\"160\":1}}],[\"用于解析一个表达式\",{\"1\":{\"111\":1}}],[\"用于解释目标代码\",{\"1\":{\"111\":1}}],[\"用于语法分析\",{\"1\":{\"110\":1}}],[\"用于词法分析\",{\"1\":{\"110\":1,\"111\":1}}],[\"用于将字符串转化成内部的表示结构\",{\"1\":{\"110\":1}}],[\"用什么有穷自动机和无穷自动机\",{\"1\":{\"105\":1}}],[\"用android\",{\"1\":{\"87\":1}}],[\"用acme\",{\"1\":{\"25\":1}}],[\"用图论阐述\",{\"0\":{\"76\":1}}],[\"图论\",{\"1\":{\"73\":1}}],[\"研究\",{\"1\":{\"73\":1}}],[\"少了任何一条都不足以构建出上述的自然数系统\",{\"1\":{\"73\":1}}],[\"从上小节对四则运算的递归下降解析可以看出\",{\"1\":{\"151\":1}}],[\"从上述步骤中我们看出\",{\"1\":{\"73\":1}}],[\"从虚拟机的角度予以支持\",{\"1\":{\"128\":1}}],[\"从中一条条地加载指令执行\",{\"1\":{\"114\":1}}],[\"从而简化具体的实现\",{\"1\":{\"130\":1}}],[\"从而导致执行过程中变量状态的\",{\"1\":{\"92\":1}}],[\"从而启动失败\",{\"1\":{\"45\":1}}],[\"从代码结构上看\",{\"1\":{\"91\":1}}],[\"从实际开发角度看\",{\"1\":{\"91\":1}}],[\"但也只有真正静下心来去克服它\",{\"1\":{\"207\":1}}],[\"但你依旧可以学习相关的知识\",{\"1\":{\"205\":1}}],[\"但这当中还有一个问题\",{\"1\":{\"198\":1}}],[\"但对理解计算机的原理有很大帮助\",{\"1\":{\"180\":1}}],[\"但没有关系\",{\"1\":{\"158\":1}}],[\"但真正看起来还是很烦\",{\"1\":{\"156\":1}}],[\"但如果你查看了\",{\"1\":{\"163\":1}}],[\"但如果有兴趣的话\",{\"1\":{\"162\":1}}],[\"但如果能掌握它\",{\"1\":{\"154\":1}}],[\"但如有条件还请支持正版\",{\"1\":{\"102\":1}}],[\"但其中用到的原理还是需要仔细推敲的\",{\"1\":{\"202\":1}}],[\"但其中并没有任何汇编代码\",{\"1\":{\"145\":1}}],[\"但其实内容不多\",{\"1\":{\"111\":1}}],[\"但其实\",{\"1\":{\"90\":1}}],[\"但由于符号表中已经有了相关的信息\",{\"1\":{\"144\":1}}],[\"但还有一个问题需要考虑\",{\"1\":{\"144\":1}}],[\"但还有一个问题是如何在子函数中获得传入的参数\",{\"1\":{\"126\":1}}],[\"但主要逻辑就是向前看一个字符来确定真正的标记\",{\"1\":{\"143\":1}}],[\"但仍支持\",{\"1\":{\"141\":1}}],[\"但有一点不同\",{\"1\":{\"137\":1}}],[\"但又枯燥且容易出错\",{\"1\":{\"134\":1}}],[\"但从结果可以看出\",{\"1\":{\"129\":1}}],[\"但它又与编译器没有太大的联系\",{\"1\":{\"128\":1}}],[\"但就如上面的说\",{\"1\":{\"126\":1}}],[\"但最为重要的是\",{\"1\":{\"118\":1}}],[\"但更为简单\",{\"1\":{\"117\":1}}],[\"但我们一直用\",{\"1\":{\"187\":1}}],[\"但我们不确定数字\",{\"1\":{\"182\":1}}],[\"但我们上面的四则运算的文法就是左递归的\",{\"1\":{\"152\":1}}],[\"但我们的虚拟机中\",{\"1\":{\"130\":1}}],[\"但我们的虚拟机中只使用\",{\"1\":{\"116\":1}}],[\"但我们的\",{\"1\":{\"122\":1}}],[\"但我们讲解的顺序并不依据它\",{\"1\":{\"117\":1}}],[\"但我们还没有写任何编译相关的代码\",{\"1\":{\"116\":1}}],[\"但理解起来应该作为无符号的整型\",{\"1\":{\"115\":1}}],[\"但实际编译项目时\",{\"1\":{\"204\":1}}],[\"但实际上由于我们还将在符号表中加入关键字如\",{\"1\":{\"139\":1}}],[\"但实际上我们构建的是\",{\"1\":{\"109\":1}}],[\"但实际情况并非如此\",{\"1\":{\"118\":1}}],[\"但实际实现上较为复杂且与编译无关\",{\"1\":{\"115\":1}}],[\"但需要了解的是\",{\"1\":{\"115\":1}}],[\"但确为自己重写\",{\"1\":{\"106\":1}}],[\"但随着计算机性能的提升\",{\"1\":{\"104\":1}}],[\"但切换过程是争抢的\",{\"1\":{\"92\":1}}],[\"但归根结底\",{\"1\":{\"91\":1}}],[\"但事实上是\",{\"1\":{\"89\":1}}],[\"但\",{\"1\":{\"73\":1}}],[\"但是两节课后我就放弃了\",{\"1\":{\"105\":1}}],[\"但是给一个垂死的人注射吗啡\",{\"1\":{\"93\":1}}],[\"但是我们也付出了相应的代价\",{\"1\":{\"92\":1}}],[\"但是可以保证最终一致性呢\",{\"1\":{\"92\":1}}],[\"但是所有协程执行完毕后\",{\"1\":{\"92\":1}}],[\"但是线程时系统调度\",{\"1\":{\"90\":1}}],[\"但是python受限于gil全局解释器锁\",{\"1\":{\"90\":1}}],[\"但是模数个数少的时候可以缩写\",{\"1\":{\"40\":1}}],[\"但是\",{\"1\":{\"39\":1,\"128\":1}}],[\"但是这种方法有着严重的缺陷\",{\"1\":{\"38\":1}}],[\"ⅳ\",{\"0\":{\"80\":1},\"1\":{\"72\":1}}],[\"其实只要不执行\",{\"1\":{\"189\":1}}],[\"其实提前看字符的概念也存在于编译器\",{\"1\":{\"142\":1}}],[\"其实是抄\",{\"1\":{\"140\":1}}],[\"其它的我们便不再详述\",{\"1\":{\"198\":1}}],[\"其它的标记的解析就相对容易一些了\",{\"1\":{\"143\":1}}],[\"其它语句并不直接生成汇编代码\",{\"1\":{\"178\":1}}],[\"其它语句\",{\"0\":{\"178\":1},\"1\":{\"173\":1}}],[\"其它就不多说了\",{\"1\":{\"140\":1}}],[\"其它\",{\"0\":{\"143\":1,\"161\":1},\"1\":{\"131\":1,\"155\":1}}],[\"其他线程又说我拿不到锁\",{\"1\":{\"90\":1}}],[\"其他线程只能等待\",{\"1\":{\"90\":1}}],[\"其中①用于解析函数体内的局部变量的定义\",{\"1\":{\"170\":1}}],[\"其中①与全局变量定义的解析十分一样\",{\"1\":{\"169\":1}}],[\"其中①中我们没有消耗最后的\",{\"1\":{\"168\":1}}],[\"其中的自顶向下方法就是我们所说的递归下降\",{\"1\":{\"148\":1}}],[\"其中的\",{\"1\":{\"118\":1,\"159\":1,\"161\":1}}],[\"其中的数据段我们只用来存放字符串\",{\"1\":{\"115\":1}}],[\"其中数据段\",{\"1\":{\"115\":1}}],[\"其中\",{\"1\":{\"72\":1,\"156\":1}}],[\"其与自然数\",{\"1\":{\"59\":1}}],[\"可能唯一不好理解的是获取十六进制的值相关的代码\",{\"1\":{\"140\":1}}],[\"可能包含多个字符\",{\"1\":{\"135\":1}}],[\"可能会更具普适性\",{\"1\":{\"108\":1}}],[\"可惜的是它的代码初衷是代码最小化\",{\"1\":{\"106\":1}}],[\"可是如果在执行事务逻辑块中主动放弃执行权了\",{\"1\":{\"93\":1}}],[\"可调试性强\",{\"1\":{\"91\":1}}],[\"可读性高\",{\"1\":{\"91\":1}}],[\"可以看看\",{\"1\":{\"206\":1}}],[\"可以看到和之前有同样的输出\",{\"1\":{\"201\":1}}],[\"可以看到\",{\"1\":{\"92\":2,\"150\":1,\"153\":1}}],[\"可以自己实现看看\",{\"1\":{\"198\":1}}],[\"可以自己先试着去实现它\",{\"1\":{\"162\":1}}],[\"可以参考\",{\"1\":{\"182\":1}}],[\"可以学习学习这些文法\",{\"1\":{\"206\":1}}],[\"可以学习学习\",{\"1\":{\"180\":1}}],[\"可以认为语句就是表达式加上末尾的分号\",{\"1\":{\"174\":1}}],[\"可以是\",{\"1\":{\"149\":1}}],[\"可以得到个位数的值\",{\"1\":{\"140\":1}}],[\"可以理解为变量名\",{\"1\":{\"139\":1}}],[\"可以构造出分段状自然数系统\",{\"1\":{\"81\":1}}],[\"可以构造出\",{\"1\":{\"80\":1}}],[\"可以构造出环状自然数系统\",{\"1\":{\"79\":1}}],[\"可以构造出菊花图自然数系统\",{\"1\":{\"78\":1}}],[\"可以构造出空集自然数系统\",{\"1\":{\"77\":1}}],[\"可以使用\",{\"1\":{\"44\":1}}],[\"可以使用的\",{\"1\":{\"31\":1}}],[\"可知\",{\"1\":{\"72\":1}}],[\"假设\",{\"1\":{\"72\":1,\"75\":1}}],[\"假设存在一个算数系统的模型满足\",{\"1\":{\"46\":1}}],[\"证明了乘法运算规则的交换律之后\",{\"1\":{\"69\":1}}],[\"证明了加法运算规则的交换律之后\",{\"1\":{\"53\":1}}],[\"存在内存地址上就另当别论\",{\"1\":{\"127\":1}}],[\"存在从\",{\"1\":{\"76\":1}}],[\"存在点\",{\"1\":{\"76\":1}}],[\"存在\",{\"1\":{\"66\":1}}],[\"存放这个标识符的值\",{\"1\":{\"139\":1}}],[\"存放标识符本身的字符串\",{\"1\":{\"139\":1}}],[\"存放日志\",{\"1\":{\"14\":1}}],[\"存放ssl证书\",{\"1\":{\"14\":1}}],[\"乘法\",{\"1\":{\"182\":1}}],[\"乘法消去保序性\",{\"0\":{\"75\":1}}],[\"乘法消去律\",{\"0\":{\"72\":1},\"1\":{\"72\":1}}],[\"乘法保序性\",{\"0\":{\"74\":1}}],[\"乘法结合律\",{\"0\":{\"71\":1}}],[\"乘法结果的唯一性\",{\"0\":{\"67\":1}}],[\"乘法结果的存在性\",{\"0\":{\"66\":1}}],[\"乘法分配律\",{\"0\":{\"70\":1}}],[\"乘法交换律\",{\"0\":{\"69\":1}}],[\"乘法的性质\",{\"0\":{\"68\":1}}],[\"乘法的定义\",{\"0\":{\"65\":1}}],[\"任何python线程执行前\",{\"1\":{\"90\":1}}],[\"任何自然数的后继存在且唯一\",{\"1\":{\"47\":1}}],[\"任意点的入度小于等于\",{\"1\":{\"76\":1}}],[\"任意非零自然数\",{\"1\":{\"72\":1}}],[\"任意两个自然数\",{\"1\":{\"62\":1}}],[\"序的完全性\",{\"0\":{\"62\":1}}],[\"序的传递性\",{\"0\":{\"61\":1}}],[\"序的反对称性\",{\"0\":{\"60\":1}}],[\"序的定义\",{\"0\":{\"57\":1}}],[\"ⅲ\",{\"0\":{\"79\":1},\"1\":{\"59\":1,\"72\":3}}],[\"当解析完=右边的表达式后\",{\"1\":{\"195\":1}}],[\"当前优先级的运算符\",{\"1\":{\"194\":1}}],[\"当一个表达式解析结束时\",{\"1\":{\"188\":1}}],[\"当一个终结符有多个选择时\",{\"1\":{\"151\":1}}],[\"当该标识符是全局定义的枚举类型时\",{\"1\":{\"186\":1}}],[\"当它是一个指向基本类型的指针时\",{\"1\":{\"159\":1}}],[\"当局部标识符的名字与全局标识符相同时\",{\"1\":{\"139\":1}}],[\"当用户的程序需要分配内存时\",{\"1\":{\"115\":1}}],[\"当时很火的\",{\"1\":{\"106\":1}}],[\"当然\",{\"1\":{\"104\":1,\"115\":1,\"135\":1,\"172\":1,\"183\":1,\"201\":1}}],[\"当我对全局变量balance进行加法运算后\",{\"1\":{\"92\":1}}],[\"当我们调用\",{\"1\":{\"194\":1}}],[\"当我们执行第一句代码print\",{\"1\":{\"92\":1}}],[\"当我们写完了vue项目后\",{\"1\":{\"84\":1}}],[\"当别的协程任务执行完毕\",{\"1\":{\"92\":1}}],[\"当\",{\"1\":{\"59\":1,\"62\":2}}],[\"当且仅当\",{\"1\":{\"57\":1}}],[\"当且仅当存在自然数\",{\"1\":{\"57\":1}}],[\"满足\",{\"1\":{\"57\":1,\"72\":1,\"75\":1}}],[\"时我们并不能确定\",{\"1\":{\"159\":1}}],[\"时直接从\",{\"1\":{\"118\":1}}],[\"时由乘法运算规则\",{\"1\":{\"69\":1}}],[\"时\",{\"1\":{\"53\":1,\"54\":1,\"59\":1,\"69\":1,\"70\":1,\"71\":1,\"86\":1}}],[\"时有\",{\"1\":{\"53\":2,\"54\":1,\"55\":4,\"62\":1,\"69\":3,\"70\":1,\"71\":1,\"72\":2}}],[\"首先我们介绍\",{\"1\":{\"122\":1}}],[\"首先是数字\",{\"1\":{\"184\":1}}],[\"首先是之前定义过的\",{\"1\":{\"158\":1}}],[\"首先是\",{\"1\":{\"118\":1,\"149\":1}}],[\"首先在全局变量中加入一个枚举类型\",{\"1\":{\"117\":1}}],[\"首先要说明的是\",{\"1\":{\"109\":1}}],[\"首先\",{\"1\":{\"59\":1,\"69\":1}}],[\"首先当\",{\"1\":{\"54\":1,\"55\":2,\"69\":1,\"70\":1,\"71\":1,\"72\":1}}],[\"首先由加法运算规则\",{\"1\":{\"53\":1}}],[\"首先有\",{\"1\":{\"53\":2,\"69\":1}}],[\"对应的\",{\"1\":{\"175\":1}}],[\"对应的汇编代码也比较直观\",{\"1\":{\"193\":1}}],[\"对应的汇编代码流程为\",{\"1\":{\"175\":1}}],[\"对应的汇编代码为\",{\"1\":{\"123\":1,\"124\":1,\"198\":1}}],[\"对应的汇编指令为\",{\"1\":{\"125\":1}}],[\"对词法分析器而言\",{\"1\":{\"136\":1}}],[\"对照\",{\"1\":{\"108\":1}}],[\"对于学习或考试而言或许可以\",{\"1\":{\"204\":1}}],[\"对于学习构建编译器帮助不大\",{\"1\":{\"110\":1}}],[\"对于变量\",{\"1\":{\"189\":1}}],[\"对于提高我们的水平还是很有帮助的\",{\"1\":{\"154\":1}}],[\"对于语法分析而言\",{\"1\":{\"139\":1}}],[\"对于\",{\"1\":{\"62\":1}}],[\"对于任意自然数\",{\"1\":{\"47\":1,\"50\":1,\"51\":1,\"66\":1,\"67\":1}}],[\"对任意自然数\",{\"1\":{\"53\":3,\"54\":1,\"55\":3,\"69\":3,\"70\":1,\"71\":1,\"72\":2}}],[\"根据标识符后的运算符\",{\"1\":{\"186\":1}}],[\"根据类型的不同有\",{\"1\":{\"118\":1}}],[\"根据文法来生成编译器\",{\"1\":{\"105\":1}}],[\"根据乘法消去律有\",{\"1\":{\"75\":1}}],[\"根据乘法运算规则\",{\"1\":{\"66\":1,\"67\":1}}],[\"根据序的反对称性有\",{\"1\":{\"75\":1}}],[\"根据加法结合律得出\",{\"1\":{\"61\":1}}],[\"根据加法结果的存在性得到\",{\"1\":{\"61\":1}}],[\"根据加法运算规则\",{\"1\":{\"50\":1,\"51\":1}}],[\"根据正自然数的性质得出\",{\"1\":{\"60\":1}}],[\"根据\",{\"1\":{\"53\":3,\"54\":1,\"55\":2,\"59\":2,\"69\":3,\"70\":1,\"71\":1,\"72\":1}}],[\"考虑诸如\",{\"1\":{\"195\":1}}],[\"考虑下列函数\",{\"1\":{\"167\":1}}],[\"考虑从乘法运算的定义下手\",{\"1\":{\"69\":1}}],[\"考虑从加法运算的定义下手\",{\"1\":{\"53\":1}}],[\"考虑到函数取模的优点\",{\"1\":{\"40\":1}}],[\"且当\",{\"1\":{\"201\":1}}],[\"且根据不同的类型移动的位移不同\",{\"1\":{\"198\":1}}],[\"且多数情况下如此\",{\"1\":{\"135\":1}}],[\"且不需要判断类型\",{\"1\":{\"118\":1}}],[\"且需要导出为pptx推荐\",{\"1\":{\"96\":1}}],[\"且乘法运算的结果存在且唯一之后\",{\"1\":{\"68\":1}}],[\"且\",{\"1\":{\"57\":1,\"60\":1,\"61\":1}}],[\"且加法运算的结果存在且唯一之后\",{\"1\":{\"52\":1}}],[\"且满足两个条件\",{\"1\":{\"47\":1}}],[\"成立\",{\"1\":{\"50\":1,\"51\":1,\"53\":3,\"54\":1,\"55\":3,\"66\":1,\"67\":1,\"69\":3,\"70\":1,\"71\":1,\"72\":2}}],[\"ⅴ\",{\"0\":{\"81\":1},\"1\":{\"50\":1,\"51\":1,\"53\":3,\"54\":1,\"55\":2,\"59\":1,\"62\":1,\"66\":1,\"67\":1,\"69\":3,\"70\":1,\"71\":1,\"72\":1}}],[\"ⅱ\",{\"0\":{\"78\":1},\"1\":{\"50\":2,\"51\":2,\"53\":1,\"66\":1,\"67\":1,\"69\":1,\"72\":1}}],[\"得到结果\",{\"1\":{\"182\":1}}],[\"得到\",{\"1\":{\"182\":2}}],[\"得到的\",{\"1\":{\"32\":1}}],[\"得知\",{\"1\":{\"53\":3,\"54\":1,\"55\":2,\"69\":3,\"70\":1,\"71\":1,\"72\":1}}],[\"得出对于任意自然数\",{\"1\":{\"50\":1,\"51\":1,\"66\":1,\"67\":1}}],[\"得证\",{\"1\":{\"50\":1,\"51\":1,\"66\":1,\"67\":1}}],[\"有了bnf方法后\",{\"1\":{\"153\":1}}],[\"有一个或多个标记是以同样的字符开头的\",{\"1\":{\"142\":1}}],[\"有一次在\",{\"1\":{\"106\":1}}],[\"有用\",{\"1\":{\"128\":1}}],[\"有点类似于\",{\"1\":{\"118\":1}}],[\"有什么区别呢\",{\"1\":{\"90\":1}}],[\"有任意两个自然数\",{\"1\":{\"62\":1}}],[\"有\",{\"1\":{\"50\":4,\"51\":4,\"53\":3,\"54\":2,\"55\":1,\"60\":2,\"61\":2,\"63\":1,\"66\":3,\"67\":3,\"69\":3,\"70\":1,\"71\":2,\"72\":3,\"74\":1,\"75\":1}}],[\"有大量的题目要求对一些数字取模\",{\"1\":{\"35\":1}}],[\"ⅰ\",{\"0\":{\"77\":1},\"1\":{\"50\":1,\"51\":1,\"53\":1,\"66\":1,\"67\":1,\"69\":1}}],[\"记得事先写一些用于输出汇编代码的函数\",{\"1\":{\"207\":1}}],[\"记得我们说过词法分析器也是某种意义上的编译器\",{\"1\":{\"136\":1}}],[\"记录\",{\"0\":{\"87\":1}}],[\"记\",{\"1\":{\"50\":1,\"51\":1,\"66\":1,\"67\":1}}],[\"也提到了优先级一般只与多元运算符有关\",{\"1\":{\"183\":1}}],[\"也许现在还想学习编译原理的人只可能是因为兴趣了\",{\"1\":{\"104\":1}}],[\"也是一样的问题\",{\"1\":{\"122\":1}}],[\"也是用于指向栈的某些位置\",{\"1\":{\"116\":1}}],[\"也是不客观的\",{\"1\":{\"93\":1}}],[\"也是自然数\",{\"1\":{\"50\":1,\"66\":1}}],[\"也就能理解下面的源代码了\",{\"1\":{\"195\":1}}],[\"也就会导致写操作被原子性覆盖\",{\"1\":{\"92\":1}}],[\"也就是没有切换挂起状态\",{\"1\":{\"93\":1}}],[\"也就是一旦通过await关键字切换协程\",{\"1\":{\"92\":1}}],[\"也就是第二行代码print\",{\"1\":{\"92\":1}}],[\"也就是说由于我们的指令过于简单\",{\"1\":{\"122\":1}}],[\"也就是说\",{\"1\":{\"49\":1,\"65\":1}}],[\"也可以看文末给出的链接\",{\"1\":{\"198\":1}}],[\"也可以认为\",{\"1\":{\"182\":1}}],[\"也可以是一个地址\",{\"1\":{\"122\":1}}],[\"也可以是其它的数据\",{\"1\":{\"115\":1}}],[\"也可以说是\",{\"1\":{\"117\":1}}],[\"也可以直接\",{\"1\":{\"111\":1,\"130\":1,\"145\":1,\"162\":1,\"171\":1,\"179\":1,\"201\":1}}],[\"也可以理解为把程序\",{\"1\":{\"92\":1}}],[\"也可另外指定\",{\"1\":{\"9\":1}}],[\"也更简单\",{\"1\":{\"91\":1}}],[\"也能释放锁\",{\"1\":{\"90\":1}}],[\"也只能用到1个核\",{\"1\":{\"90\":1}}],[\"也唯一\",{\"1\":{\"51\":1,\"67\":1}}],[\"都比\",{\"1\":{\"206\":1}}],[\"都指向\",{\"1\":{\"175\":1}}],[\"都保持了其一致性\",{\"1\":{\"92\":1}}],[\"都保证了其状态的一致性\",{\"1\":{\"92\":1}}],[\"都有唯一的数\",{\"1\":{\"72\":1}}],[\"都有序关系\",{\"1\":{\"62\":2}}],[\"都可以进行乘法运算\",{\"1\":{\"65\":1}}],[\"都可以进行加法运算\",{\"1\":{\"49\":1}}],[\"都是存放在计算机的\",{\"1\":{\"167\":1}}],[\"都是唯一的\",{\"1\":{\"51\":1,\"67\":1}}],[\"都是自然数\",{\"1\":{\"49\":1,\"50\":1,\"65\":1,\"66\":1}}],[\"都是在这个路径下的\",{\"1\":{\"32\":1}}],[\"定义了变量\",{\"1\":{\"139\":1}}],[\"定义乘法的运算规则\",{\"1\":{\"65\":1}}],[\"定义正自然数为非\",{\"1\":{\"58\":1}}],[\"定义\",{\"1\":{\"57\":1}}],[\"定义自然数的序即定义\",{\"1\":{\"57\":1}}],[\"定义加法的运算规则\",{\"1\":{\"49\":1}}],[\"定义dns解析器\",{\"1\":{\"16\":1}}],[\"则结果是两个指针间隔的元素个数\",{\"1\":{\"198\":1}}],[\"则移动\",{\"1\":{\"198\":1}}],[\"则移动一字节\",{\"1\":{\"198\":1}}],[\"则意味着函数要退出了\",{\"1\":{\"177\":1}}],[\"则跳转到\",{\"1\":{\"175\":1}}],[\"则再加上\",{\"1\":{\"159\":1}}],[\"则可以断定是函数了\",{\"1\":{\"159\":1}}],[\"则说明是注释\",{\"1\":{\"142\":1}}],[\"则用于从子函数中返回\",{\"1\":{\"122\":1}}],[\"则不需要加锁\",{\"1\":{\"93\":1}}],[\"则必须加锁\",{\"1\":{\"93\":1}}],[\"则对连通性无要求\",{\"1\":{\"81\":1}}],[\"则对一个数可以是多个数的后继\",{\"1\":{\"80\":1}}],[\"则对\",{\"1\":{\"79\":1}}],[\"则对点的出度无规定\",{\"1\":{\"78\":1}}],[\"则允许不存在\",{\"1\":{\"77\":1}}],[\"则存在正自然数\",{\"1\":{\"75\":1}}],[\"则由加法运算规则\",{\"1\":{\"72\":1}}],[\"则\",{\"1\":{\"49\":2,\"50\":1,\"51\":1,\"60\":1,\"61\":1,\"62\":3,\"63\":1,\"65\":2,\"66\":1,\"67\":1,\"74\":1,\"75\":1}}],[\"则有\",{\"1\":{\"47\":1,\"72\":1}}],[\"则需要写多个函数\",{\"1\":{\"39\":1}}],[\"为例\",{\"1\":{\"198\":1}}],[\"为例介绍几种写法\",{\"1\":{\"37\":1}}],[\"为\",{\"1\":{\"182\":2}}],[\"为零或不为零情况下的跳转\",{\"1\":{\"121\":1}}],[\"为了实际将这个值保存起来\",{\"1\":{\"195\":1}}],[\"为了实现\",{\"1\":{\"121\":1}}],[\"为了防止因为顺序排列而执行了\",{\"1\":{\"175\":1}}],[\"为了对比\",{\"1\":{\"92\":1}}],[\"为什么选择递归下降\",{\"0\":{\"151\":1},\"1\":{\"147\":1}}],[\"为什么要用\",{\"1\":{\"136\":1}}],[\"为什么要学编译原理\",{\"0\":{\"104\":1}}],[\"为什么不能直接使用\",{\"1\":{\"122\":1}}],[\"为什么\",{\"1\":{\"118\":1}}],[\"为自然数时\",{\"1\":{\"62\":1}}],[\"为自然数且\",{\"1\":{\"54\":1,\"55\":2,\"59\":1,\"70\":1,\"71\":1,\"72\":1}}],[\"为正自然数时有\",{\"1\":{\"59\":1}}],[\"为正自然数\",{\"1\":{\"59\":4}}],[\"为真命题可以推出\",{\"1\":{\"50\":1,\"51\":1,\"66\":1,\"67\":1}}],[\"为真命题可以推理出\",{\"1\":{\"47\":1}}],[\"为真命题\",{\"1\":{\"47\":2,\"50\":1,\"51\":1,\"66\":1,\"67\":1}}],[\"由上可以看出\",{\"1\":{\"139\":1}}],[\"由调用者将参数出栈\",{\"1\":{\"122\":1}}],[\"由调用者将参数入栈\",{\"1\":{\"122\":1}}],[\"由于取变量的值与函数的调用都是以\",{\"1\":{\"186\":1}}],[\"由于语法分析本身比较复杂\",{\"1\":{\"155\":1,\"164\":1}}],[\"由于本编译器的目的是达到自己编译自己\",{\"1\":{\"141\":1}}],[\"由于本人水平一般\",{\"1\":{\"108\":1}}],[\"由于我们的目标是能自举\",{\"1\":{\"139\":1}}],[\"由于词法分析的工作很常见\",{\"1\":{\"134\":1}}],[\"由于只存放字符串\",{\"1\":{\"115\":1}}],[\"由此有\",{\"1\":{\"75\":1}}],[\"由此知道假设不成立\",{\"1\":{\"72\":1}}],[\"由乘法运算规则\",{\"1\":{\"66\":1,\"67\":1}}],[\"由加法结果的唯一性有\",{\"1\":{\"67\":1}}],[\"由加法结果的存在性有\",{\"1\":{\"66\":1}}],[\"由加法消去律得到\",{\"1\":{\"60\":1}}],[\"由加法运算规则\",{\"1\":{\"50\":1,\"51\":1}}],[\"由\",{\"1\":{\"47\":1,\"50\":2,\"51\":2,\"60\":2,\"61\":2,\"62\":1,\"63\":1,\"66\":1,\"67\":1,\"72\":2,\"74\":1}}],[\"是解释器\",{\"1\":{\"202\":1}}],[\"是指针时\",{\"1\":{\"198\":1}}],[\"是逆序将参数入栈的\",{\"1\":{\"186\":1}}],[\"是第几个参数\",{\"1\":{\"169\":1}}],[\"是以字符\",{\"1\":{\"168\":2}}],[\"是放在一起解析的\",{\"1\":{\"168\":1}}],[\"是一个一元运算符\",{\"1\":{\"185\":1}}],[\"是一个普通的变量还是一个函数\",{\"1\":{\"159\":1}}],[\"是一款简洁高效的\",{\"1\":{\"102\":1}}],[\"是对前一章提到的\",{\"1\":{\"156\":1}}],[\"是如何帮助我们的工程实现的\",{\"1\":{\"154\":1}}],[\"是因为几乎所有手工编写的语法分析器都或多或少地有它的影子\",{\"1\":{\"154\":1}}],[\"是因为之后我们将用\",{\"1\":{\"122\":1}}],[\"是因为表达式在语法分析中相对独立并且比较复杂\",{\"1\":{\"111\":1}}],[\"是跳转指令\",{\"1\":{\"120\":1}}],[\"是比较困难的\",{\"1\":{\"118\":1}}],[\"是数据还是地址\",{\"1\":{\"118\":1}}],[\"是所有指令中最基础的一个\",{\"1\":{\"118\":1}}],[\"是不客观的\",{\"1\":{\"93\":1}}],[\"是的\",{\"1\":{\"92\":1,\"93\":1}}],[\"是线程调度器抢占划分时间片给其他线程跑\",{\"1\":{\"90\":1}}],[\"是\",{\"1\":{\"72\":1,\"92\":1,\"129\":1,\"198\":2}}],[\"是唯一的\",{\"1\":{\"51\":2,\"67\":2}}],[\"是否属于优先级更高的运算符\",{\"1\":{\"182\":1}}],[\"是否唯一\",{\"1\":{\"51\":1,\"67\":1}}],[\"是否存在\",{\"1\":{\"50\":1,\"66\":1}}],[\"是否是自然数\",{\"1\":{\"50\":1,\"66\":1}}],[\"是任意自然数\",{\"1\":{\"50\":1,\"51\":1,\"66\":1,\"67\":1}}],[\"是真命题\",{\"1\":{\"47\":1}}],[\"是关于自然数\",{\"1\":{\"47\":1}}],[\"是自然数且\",{\"1\":{\"51\":1,\"53\":3,\"69\":3}}],[\"是自然数\",{\"1\":{\"47\":1,\"49\":1,\"50\":7,\"51\":2,\"61\":1,\"65\":1,\"66\":6,\"67\":2}}],[\"是什么\",{\"0\":{\"31\":1}}],[\"共有五条\",{\"1\":{\"47\":1}}],[\"即当\",{\"1\":{\"198\":1}}],[\"即可\",{\"1\":{\"186\":1,\"189\":1}}],[\"即跨行的字符串拼接\",{\"1\":{\"184\":1}}],[\"即在这断代码之前\",{\"1\":{\"166\":1}}],[\"即我们将该变量的类别设置成了\",{\"1\":{\"160\":1}}],[\"即我们自己的虚拟机\",{\"1\":{\"111\":1}}],[\"即代码中的\",{\"1\":{\"159\":1}}],[\"即全局的定义语句\",{\"1\":{\"159\":1}}],[\"即向前看\",{\"1\":{\"146\":1}}],[\"即提前看多个字符\",{\"1\":{\"142\":1}}],[\"即用一个整型数组来保存相关的id信息\",{\"1\":{\"139\":1}}],[\"即用户主动触发协程切换\",{\"1\":{\"92\":1}}],[\"即如果它是个变量\",{\"1\":{\"139\":1}}],[\"即并不是多个字符共同构成标记\",{\"1\":{\"135\":1}}],[\"即前几篇中提到的\",{\"1\":{\"134\":1}}],[\"即与代码的上下文是有关系的\",{\"1\":{\"134\":1}}],[\"即标记本身和标记的值\",{\"1\":{\"132\":1}}],[\"即一连串的标记\",{\"1\":{\"132\":1}}],[\"即有两个参数\",{\"1\":{\"127\":1}}],[\"即保存当前的栈指针\",{\"1\":{\"123\":1}}],[\"即结果\",{\"1\":{\"121\":1}}],[\"即能自己编译自己\",{\"1\":{\"106\":1}}],[\"即构造一个工具\",{\"1\":{\"105\":1}}],[\"即python3\",{\"1\":{\"92\":1}}],[\"即不会触发系统的全局解释器锁\",{\"1\":{\"91\":1}}],[\"即所谓的\",{\"1\":{\"91\":1}}],[\"即使多个线程跑在8核处理上\",{\"1\":{\"90\":1}}],[\"即证明了乘法消去的保序性\",{\"1\":{\"75\":1}}],[\"即乘法结合律成立\",{\"1\":{\"71\":1}}],[\"即乘法分配律成立\",{\"1\":{\"70\":1}}],[\"即乘法交换律成立\",{\"1\":{\"69\":1}}],[\"即先证明乘法的两条运算规则符合交换律\",{\"1\":{\"69\":1}}],[\"即先证明加法的两条运算规则符合交换律\",{\"1\":{\"53\":1}}],[\"即任意两个自然数都可以进行乘法运算\",{\"1\":{\"68\":1}}],[\"即任意两个自然数都可以进行加法运算\",{\"1\":{\"52\":1}}],[\"即对于正自然数\",{\"1\":{\"59\":1}}],[\"即对于任意自然数\",{\"1\":{\"53\":1,\"54\":1,\"55\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1}}],[\"即加法结合律成立\",{\"1\":{\"54\":1}}],[\"即加法交换律成立\",{\"1\":{\"53\":1}}],[\"即由\",{\"1\":{\"50\":1,\"51\":1,\"66\":1,\"67\":1}}],[\"即\",{\"1\":{\"49\":1,\"50\":3,\"51\":3,\"55\":2,\"65\":1,\"66\":3,\"67\":3,\"72\":2,\"76\":5,\"120\":1,\"132\":1,\"136\":1,\"151\":1,\"191\":1,\"194\":1,\"199\":1}}],[\"即假定\",{\"1\":{\"46\":1}}],[\"即写成\",{\"1\":{\"40\":1}}],[\"公理系统\",{\"2\":{\"83\":1}}],[\"公理系统内出发\",{\"1\":{\"73\":1}}],[\"公理自然不能从\",{\"1\":{\"73\":1}}],[\"公理自身任有待研究\",{\"1\":{\"73\":1}}],[\"公理每一条公理都被使用过\",{\"1\":{\"73\":1}}],[\"公理构建出了一个自然数代数系统\",{\"1\":{\"73\":1}}],[\"公理的合理性\",{\"0\":{\"73\":1}}],[\"公理相容\",{\"1\":{\"46\":1}}],[\"公理\",{\"0\":{\"77\":1,\"78\":1,\"79\":1,\"80\":1,\"81\":1},\"1\":{\"46\":1,\"47\":1,\"50\":2,\"51\":2,\"53\":3,\"54\":1,\"55\":2,\"59\":2,\"62\":1,\"66\":1,\"67\":1,\"69\":3,\"70\":1,\"71\":1,\"72\":4}}],[\"导致插件无法正常退出\",{\"1\":{\"45\":1}}],[\"若在此通过\",{\"1\":{\"168\":1}}],[\"若是\",{\"1\":{\"142\":1}}],[\"若得到的是单个字符\",{\"1\":{\"141\":1}}],[\"若碰到了一个我们不认识的字符该怎么处理\",{\"1\":{\"136\":1}}],[\"若去除\",{\"1\":{\"77\":1,\"78\":1,\"79\":1,\"80\":1,\"81\":1}}],[\"若有\",{\"1\":{\"72\":1}}],[\"若\",{\"1\":{\"49\":2,\"50\":1,\"51\":1,\"60\":1,\"61\":1,\"62\":3,\"63\":1,\"65\":2,\"66\":1,\"67\":1,\"74\":1,\"75\":1}}],[\"若deactivate\",{\"1\":{\"45\":1}}],[\"若activate\",{\"1\":{\"45\":1}}],[\"会使用到\",{\"1\":{\"160\":1}}],[\"会增加许多的成本\",{\"1\":{\"130\":1}}],[\"会出现\",{\"1\":{\"129\":1}}],[\"会生成如下的\",{\"1\":{\"122\":1}}],[\"会有许多相似的代码\",{\"1\":{\"107\":1}}],[\"会分两种情况\",{\"1\":{\"93\":1}}],[\"会被顺序执行\",{\"1\":{\"92\":1}}],[\"会被强行终止\",{\"1\":{\"45\":1}}],[\"会和adb冲突\",{\"1\":{\"87\":1}}],[\"会导致activating\",{\"1\":{\"45\":1}}],[\"会给你创建两个\",{\"1\":{\"31\":1}}],[\"=<=\",{\"1\":{\"198\":1}}],[\"=左边的就称作\",{\"1\":{\"149\":1}}],[\"=>\",{\"1\":{\"132\":1,\"150\":11}}],[\"===>\",{\"1\":{\"175\":1}}],[\"==\",{\"1\":{\"118\":5,\"119\":1,\"120\":1,\"121\":2,\"122\":2,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":17,\"128\":8,\"135\":2,\"137\":1,\"138\":1,\"139\":3,\"140\":2,\"141\":6,\"142\":2,\"143\":33,\"153\":7,\"159\":8,\"160\":2,\"161\":1,\"166\":1,\"168\":1,\"169\":5,\"170\":6,\"175\":2,\"176\":1,\"177\":1,\"178\":2,\"184\":3,\"185\":5,\"186\":9,\"187\":5,\"188\":2,\"189\":3,\"190\":2,\"191\":1,\"192\":3,\"193\":6,\"195\":4,\"196\":2,\"197\":2,\"198\":3,\"199\":5,\"200\":2}}],[\"=\",{\"1\":{\"44\":7,\"86\":1,\"90\":7,\"91\":5,\"92\":21,\"111\":8,\"115\":6,\"116\":3,\"118\":6,\"119\":1,\"120\":1,\"121\":2,\"122\":4,\"123\":3,\"124\":1,\"125\":3,\"126\":1,\"127\":17,\"128\":8,\"129\":11,\"135\":3,\"136\":1,\"138\":2,\"139\":11,\"140\":8,\"141\":9,\"142\":3,\"143\":29,\"144\":9,\"149\":4,\"151\":3,\"152\":5,\"153\":19,\"156\":13,\"159\":23,\"160\":10,\"165\":8,\"166\":2,\"168\":5,\"169\":14,\"170\":16,\"175\":6,\"176\":6,\"177\":2,\"178\":2,\"184\":9,\"185\":6,\"186\":19,\"187\":3,\"188\":2,\"189\":1,\"190\":5,\"191\":6,\"192\":8,\"193\":10,\"194\":1,\"195\":7,\"196\":6,\"197\":8,\"198\":10,\"199\":14,\"200\":8,\"201\":7}}],[\"=404\",{\"1\":{\"16\":3,\"22\":5}}],[\"安装路径打开\",{\"1\":{\"102\":1}}],[\"安装目录下\",{\"1\":{\"102\":1}}],[\"安装了\",{\"1\":{\"97\":1}}],[\"安装\",{\"0\":{\"85\":1}}],[\"安装editorconfig插件\",{\"1\":{\"44\":1}}],[\"安装证书\",{\"0\":{\"21\":1}}],[\"唯一特殊的地方是\",{\"1\":{\"177\":1}}],[\"唯一\",{\"1\":{\"51\":4,\"67\":4}}],[\"唯一的缺点就是类型名难写\",{\"1\":{\"40\":1}}],[\"唯独你没懂\",{\"0\":{\"29\":1},\"1\":{\"28\":1}}],[\"将参数出栈\",{\"1\":{\"182\":2}}],[\"将运算符\",{\"1\":{\"182\":1}}],[\"将它改成\",{\"1\":{\"158\":1}}],[\"将它们加入符号表\",{\"1\":{\"144\":1}}],[\"将对应地址中的整数载入\",{\"1\":{\"118\":1}}],[\"将对应地址中的字符载入\",{\"1\":{\"118\":1}}],[\"将\",{\"1\":{\"118\":3,\"135\":2,\"182\":1}}],[\"将语法树转化成目标代码\",{\"1\":{\"110\":1}}],[\"将词法分析得到的标记流\",{\"1\":{\"110\":1}}],[\"将下载的工具解压后得到的两个\",{\"1\":{\"102\":1}}],[\"将其称为新的乘法运算规则\",{\"1\":{\"69\":1}}],[\"将其称为新的加法运算规则\",{\"1\":{\"53\":1}}],[\"将模数直接包含在类型中\",{\"1\":{\"40\":1}}],[\"将卷的挂载目录改为由命令输入\",{\"1\":{\"24\":1}}],[\"泛型编程\",{\"0\":{\"40\":1}}],[\"泛型与\",{\"0\":{\"35\":1}}],[\"显得代码冗长\",{\"1\":{\"39\":1}}],[\"并执行\",{\"1\":{\"201\":1}}],[\"并根据它们类型使用\",{\"1\":{\"189\":1}}],[\"并直接修改\",{\"1\":{\"187\":1}}],[\"并将之前的\",{\"1\":{\"182\":1}}],[\"并将保存在\",{\"1\":{\"168\":1}}],[\"并实现其中解析变量定义部分\",{\"1\":{\"155\":1}}],[\"并用它来实现了四则运算的语法分析器\",{\"1\":{\"154\":1}}],[\"并用它完成一个基本的四则运算的语法分析器\",{\"1\":{\"147\":1}}],[\"并提前为它们赋予必要的信息\",{\"1\":{\"144\":1}}],[\"并不作为语法的一部分\",{\"1\":{\"136\":1}}],[\"并不是直接处理\",{\"1\":{\"115\":1}}],[\"并不是说是没写过编译器就不是好程序员\",{\"1\":{\"104\":1}}],[\"并退出整个程序\",{\"1\":{\"136\":1}}],[\"并仿照\",{\"1\":{\"130\":1}}],[\"并输出\",{\"1\":{\"111\":1}}],[\"并点击激活\",{\"1\":{\"102\":1}}],[\"并回车\",{\"1\":{\"102\":2}}],[\"并没有保证\",{\"1\":{\"92\":1}}],[\"并且它的结果是\",{\"1\":{\"185\":1}}],[\"并且它用很少的代码就完成了一个功能相当完善的\",{\"1\":{\"106\":1}}],[\"并且三条指令写来比较麻烦且浪费空间\",{\"1\":{\"125\":1}}],[\"并且我们也只有一个寄存器\",{\"1\":{\"119\":1}}],[\"并且最重要的是\",{\"1\":{\"105\":1}}],[\"并且协程切换并不是系统态抢占式\",{\"1\":{\"92\":1}}],[\"并且会非常频繁地进行切换\",{\"1\":{\"91\":1}}],[\"并且如果要对多个模数取模\",{\"1\":{\"39\":1}}],[\"并且如果编译器没有任何优化\",{\"1\":{\"39\":1}}],[\"并发异步编程之争\",{\"0\":{\"89\":1}}],[\"并添加以下内容\",{\"1\":{\"44\":1}}],[\"并自动重载docker\",{\"1\":{\"25\":1}}],[\"zero\",{\"1\":{\"121\":1}}],[\"zeroelse\",{\"1\":{\"121\":1}}],[\"z\",{\"1\":{\"39\":1,\"40\":1,\"139\":4}}],[\"zip\",{\"1\":{\"8\":1}}],[\"第二个参数放在\",{\"1\":{\"127\":1}}],[\"第二种\",{\"0\":{\"39\":1}}],[\"第一个参数放在栈顶\",{\"1\":{\"127\":1}}],[\"第一篇完全没有正题相关的内容也是希望你能有所心理准备再开始学习\",{\"1\":{\"107\":1}}],[\"第一种\",{\"0\":{\"38\":1}}],[\"不知道你是否有同感\",{\"1\":{\"204\":1}}],[\"不指定的话一般认为是第一个出现的非终结符\",{\"1\":{\"150\":1}}],[\"不断地对非终结符进行分解\",{\"1\":{\"148\":1}}],[\"不同的只是赋值的信息\",{\"1\":{\"144\":1}}],[\"不同的自然数后继不同\",{\"1\":{\"47\":1}}],[\"不识别\",{\"1\":{\"136\":1}}],[\"不会出现强制转换后的问题\",{\"1\":{\"129\":1}}],[\"不会触发ondidclosetextdocument事件\",{\"1\":{\"45\":1}}],[\"不仅要考虑函数的地址\",{\"1\":{\"122\":1}}],[\"不过据说c\",{\"1\":{\"108\":1}}],[\"不过\",{\"1\":{\"108\":1}}],[\"不用外部工具\",{\"1\":{\"106\":1}}],[\"不用类也能封装数据和方法\",{\"1\":{\"98\":1}}],[\"不用操心运算时忘记取模\",{\"1\":{\"40\":1}}],[\"不支持\",{\"1\":{\"142\":1}}],[\"不支持动画\",{\"1\":{\"97\":1}}],[\"不支持导出pptx\",{\"1\":{\"96\":1}}],[\"不易写出错的代码\",{\"1\":{\"91\":1}}],[\"不易检验\",{\"1\":{\"38\":1,\"39\":1}}],[\"不加锁的话\",{\"1\":{\"90\":1}}],[\"不妨试试这些自动生成工具\",{\"1\":{\"205\":1}}],[\"不妨记作\",{\"1\":{\"72\":1}}],[\"不妨设\",{\"1\":{\"72\":1}}],[\"不是任何自然数的后继\",{\"1\":{\"47\":1}}],[\"不推荐运用这种方法\",{\"1\":{\"38\":1}}],[\"不方便输出结果\",{\"1\":{\"36\":1}}],[\"忘记取模\",{\"1\":{\"38\":1}}],[\"清晰明了\",{\"1\":{\"38\":1}}],[\"例如在编写表达式的解析时\",{\"1\":{\"207\":1}}],[\"例如需要考虑许多细节\",{\"1\":{\"207\":1}}],[\"例如对变量\",{\"1\":{\"189\":1}}],[\"例如参数的位置\",{\"1\":{\"172\":1}}],[\"例如只要遇到\",{\"1\":{\"159\":1}}],[\"例如用\",{\"1\":{\"141\":1}}],[\"例如添加新插件\",{\"1\":{\"86\":1}}],[\"例如\",{\"1\":{\"86\":1,\"115\":1,\"122\":1,\"128\":1,\"132\":1,\"135\":1,\"139\":1,\"144\":1,\"149\":1,\"150\":1,\"181\":1}}],[\"例如很多期望概率题\",{\"1\":{\"36\":1}}],[\"例如许多计数\",{\"1\":{\"36\":1}}],[\"要容易\",{\"1\":{\"206\":1}}],[\"要根据它的类型放大\",{\"1\":{\"198\":1}}],[\"要理解函数定义的解析过程\",{\"1\":{\"172\":1}}],[\"要理解这些寄存器的作用\",{\"1\":{\"116\":1}}],[\"要是深入词法分析器\",{\"1\":{\"133\":1}}],[\"要引入的命令有\",{\"1\":{\"122\":1}}],[\"要求栈顶存放地址\",{\"1\":{\"118\":2}}],[\"要求\",{\"1\":{\"118\":2}}],[\"要执行的计算机指令\",{\"1\":{\"116\":1}}],[\"要么就是借助了自动生成的工具\",{\"1\":{\"106\":1}}],[\"要么是因为这道题目直接考察了模的性质和运用\",{\"1\":{\"36\":1}}],[\"要么是因为答案是浮点数\",{\"1\":{\"36\":1}}],[\"要同时进行多件事情本来就需要正在运行的让出处理器\",{\"1\":{\"89\":1}}],[\"要部署的\",{\"1\":{\"14\":1}}],[\"背景介绍\",{\"0\":{\"36\":1}}],[\"中我们介绍过内置函数的支持\",{\"1\":{\"186\":1}}],[\"中即可\",{\"1\":{\"184\":1}}],[\"中的值执行减\",{\"1\":{\"199\":1}}],[\"中的信息还原\",{\"1\":{\"168\":1}}],[\"中的全局变量不同\",{\"1\":{\"167\":1}}],[\"中的位置\",{\"1\":{\"166\":1}}],[\"中的一种\",{\"1\":{\"149\":1}}],[\"中的\",{\"1\":{\"118\":1,\"142\":1}}],[\"中的数据作为整数存放入地址中\",{\"1\":{\"118\":1}}],[\"中的数据作为字符存放入地址中\",{\"1\":{\"118\":1}}],[\"中的内存\",{\"1\":{\"115\":1}}],[\"中存放的是参数的位置\",{\"1\":{\"169\":1}}],[\"中存放地址\",{\"1\":{\"118\":2}}],[\"中存放如指针\",{\"1\":{\"115\":1}}],[\"中间代码的表示\",{\"1\":{\"105\":1}}],[\"中文官网\",{\"1\":{\"102\":1}}],[\"中\",{\"1\":{\"35\":1,\"118\":6,\"119\":1,\"122\":1,\"127\":2,\"169\":1,\"188\":1,\"195\":1}}],[\"技术分享等内容\",{\"1\":{\"34\":1}}],[\"技术\",{\"0\":{\"34\":1}}],[\"工具下载\",{\"1\":{\"102\":1}}],[\"工具使用\",{\"1\":{\"34\":1}}],[\"工具等资源\",{\"1\":{\"4\":1}}],[\"工作流程\",{\"0\":{\"33\":1}}],[\"去手动异步执行另一个协程\",{\"1\":{\"92\":1}}],[\"去\",{\"1\":{\"32\":1}}],[\"打开\",{\"1\":{\"32\":1}}],[\"里的\",{\"0\":{\"32\":1}}],[\"在后期解析语句和表达式时\",{\"1\":{\"204\":1}}],[\"在学习\",{\"1\":{\"200\":1}}],[\"在执行自增自减后\",{\"1\":{\"199\":1}}],[\"在作指针减法时\",{\"1\":{\"198\":1}}],[\"在解析\",{\"1\":{\"195\":1}}],[\"在解析的过程中\",{\"1\":{\"167\":1}}],[\"在前文的一元运算符处理中也用到了这一点\",{\"1\":{\"194\":1}}],[\"在计算一个运算符\",{\"1\":{\"182\":1}}],[\"在函数体内局部变量就会覆盖全局变量\",{\"1\":{\"168\":1}}],[\"在函数内访问它们是通过\",{\"1\":{\"167\":1}}],[\"在思考这个问题之前\",{\"1\":{\"167\":1}}],[\"在main函数中进行初始化如下\",{\"1\":{\"144\":1}}],[\"在main函数中加入初始化代码\",{\"1\":{\"115\":1}}],[\"在语法分析前将关键字提前加入符号表\",{\"1\":{\"144\":1}}],[\"在我们的编译器中共识别\",{\"1\":{\"174\":1}}],[\"在我们的\",{\"1\":{\"142\":1}}],[\"在我看来\",{\"1\":{\"104\":1}}],[\"在分析时\",{\"1\":{\"141\":2}}],[\"在全局中添加如下定义\",{\"1\":{\"135\":1}}],[\"在全局中加入如下定义\",{\"1\":{\"116\":1}}],[\"在这个前提下\",{\"1\":{\"133\":1}}],[\"在这种要求之下\",{\"1\":{\"37\":1}}],[\"在代码的开头\",{\"1\":{\"129\":1}}],[\"在将调用子函数时压入栈中的数据清除\",{\"1\":{\"124\":1}}],[\"在实际调用函数时\",{\"1\":{\"122\":1}}],[\"在调用函数时会使用到它\",{\"1\":{\"116\":1}}],[\"在写编译器的时候会遇到两个主要问题\",{\"1\":{\"107\":1}}],[\"在开始进入正题之前\",{\"1\":{\"103\":1}}],[\"在所有线程相互独立且不会操作同一资源的模式下\",{\"1\":{\"90\":1}}],[\"在python编程领域\",{\"1\":{\"89\":1}}],[\"在明确证明了自然数乘法运算的良好性质\",{\"1\":{\"68\":1}}],[\"在明确证明了自然数加法运算的良好性质\",{\"1\":{\"52\":1}}],[\"在考察序的性质之前\",{\"1\":{\"58\":1}}],[\"在此承认次假设的基础之上\",{\"1\":{\"46\":1}}],[\"在项目根目录下创建\",{\"1\":{\"44\":1}}],[\"在\",{\"1\":{\"31\":1,\"35\":1,\"116\":1,\"118\":1,\"119\":1,\"129\":1,\"169\":1,\"198\":1}}],[\"在准备好前端项目及安装相应环境后\",{\"1\":{\"15\":1}}],[\"的表示方法\",{\"1\":{\"206\":1}}],[\"的表达式\",{\"1\":{\"195\":1}}],[\"的地址两次\",{\"1\":{\"193\":1}}],[\"的优先级最高\",{\"1\":{\"194\":1}}],[\"的优先级最低\",{\"1\":{\"194\":1}}],[\"的优先级高于\",{\"1\":{\"193\":1}}],[\"的优先级就要高于\",{\"1\":{\"135\":1}}],[\"的类型\",{\"1\":{\"188\":1}}],[\"的指针取值\",{\"1\":{\"188\":1}}],[\"的指令集\",{\"1\":{\"117\":1}}],[\"的形式\",{\"1\":{\"186\":1}}],[\"的形式返回\",{\"1\":{\"141\":1}}],[\"的实质就是两个运算符在抢参数\",{\"1\":{\"182\":1}}],[\"的实际运行顺序是\",{\"1\":{\"182\":1}}],[\"的运算符\",{\"1\":{\"182\":1}}],[\"的运算结果为\",{\"1\":{\"49\":1,\"65\":1}}],[\"的结果\",{\"1\":{\"182\":1}}],[\"的结果是否唯一\",{\"1\":{\"51\":1,\"67\":1}}],[\"的位置\",{\"1\":{\"169\":1,\"175\":1}}],[\"的产生式转换成函数的过程\",{\"1\":{\"163\":1}}],[\"的具体表示方法后就不难理解了\",{\"1\":{\"163\":1}}],[\"的扩展\",{\"1\":{\"156\":1}}],[\"的概念了\",{\"1\":{\"151\":1}}],[\"的概念\",{\"1\":{\"142\":1,\"146\":1}}],[\"的注释\",{\"1\":{\"142\":1}}],[\"的语法\",{\"1\":{\"141\":1}}],[\"的转义符\",{\"1\":{\"141\":1}}],[\"的源代码的\",{\"1\":{\"140\":1}}],[\"的字符个数\",{\"1\":{\"142\":1}}],[\"的字符\",{\"1\":{\"136\":1}}],[\"的一个问题\",{\"1\":{\"136\":1}}],[\"的一个命题\",{\"1\":{\"47\":1}}],[\"的功能包含了\",{\"1\":{\"125\":1}}],[\"的功能\",{\"1\":{\"123\":1}}],[\"的子函数\",{\"1\":{\"122\":1}}],[\"的作用是跳转到地址为\",{\"1\":{\"122\":1}}],[\"的作用是将值或寄存器\",{\"1\":{\"119\":1}}],[\"的作用是退栈\",{\"1\":{\"118\":1}}],[\"的值\",{\"1\":{\"120\":1,\"187\":1,\"198\":1}}],[\"的值放入栈中\",{\"1\":{\"119\":1}}],[\"的值放到栈上\",{\"1\":{\"118\":1}}],[\"的值减小\",{\"1\":{\"116\":1}}],[\"的内容放在\",{\"1\":{\"118\":1}}],[\"的\",{\"1\":{\"118\":2}}],[\"的函数\",{\"1\":{\"111\":1}}],[\"的代码完全是手工实现的\",{\"1\":{\"106\":1}}],[\"的代码\",{\"1\":{\"105\":1}}],[\"的学生顶多学到语法分析就结束了\",{\"1\":{\"105\":1}}],[\"的课程后\",{\"1\":{\"105\":1}}],[\"的操作等价于\",{\"1\":{\"200\":1}}],[\"的操作\",{\"1\":{\"92\":1,\"193\":1}}],[\"的入度无规定\",{\"1\":{\"79\":1}}],[\"的假设矛盾\",{\"1\":{\"75\":1}}],[\"的和\",{\"1\":{\"59\":1}}],[\"的任意性\",{\"1\":{\"50\":1,\"51\":1,\"66\":1,\"67\":1}}],[\"的性质和\",{\"1\":{\"50\":1,\"51\":1,\"66\":1,\"67\":1}}],[\"的后继\",{\"1\":{\"47\":1,\"72\":1}}],[\"的话\",{\"1\":{\"39\":1}}],[\"的开发过程了\",{\"1\":{\"31\":1}}],[\"的开发环境去\",{\"1\":{\"31\":1}}],[\"的环境下\",{\"1\":{\"31\":1}}],[\"的图形界面\",{\"1\":{\"31\":1}}],[\"发现是\",{\"1\":{\"151\":1}}],[\"发行版\",{\"1\":{\"31\":1}}],[\"发布\",{\"1\":{\"29\":2}}],[\"集成到某个\",{\"1\":{\"31\":1}}],[\"下一条\",{\"1\":{\"116\":1,\"120\":1}}],[\"下一章中我们将讲解语句的解析\",{\"1\":{\"172\":1}}],[\"下一章中我们将介绍如何解析函数的定义\",{\"1\":{\"163\":1}}],[\"下一章中\",{\"1\":{\"111\":1,\"146\":1}}],[\"下一步\",{\"1\":{\"102\":1}}],[\"下面以加法为例\",{\"1\":{\"198\":1}}],[\"下面以式子\",{\"1\":{\"37\":1}}],[\"下面是\",{\"1\":{\"158\":1}}],[\"下面是相应的源代码\",{\"1\":{\"111\":1}}],[\"下面的例子\",{\"1\":{\"122\":1}}],[\"下面我们逐一解释\",{\"1\":{\"174\":1}}],[\"下面我们用我们的汇编写一小段程序\",{\"1\":{\"129\":1}}],[\"下面我们试着通过删除公理的方法来寻找反例\",{\"1\":{\"76\":1}}],[\"下面我们需要证明对于任意两个自然数\",{\"1\":{\"49\":1,\"65\":1}}],[\"下面我将阐述为什么每条公理都是必须的\",{\"1\":{\"73\":1}}],[\"下面证明乘法消去律\",{\"1\":{\"72\":1}}],[\"下面证明乘法结合律\",{\"1\":{\"71\":1}}],[\"下面证明乘法分配律\",{\"1\":{\"70\":1}}],[\"下面证明乘法交换律\",{\"1\":{\"69\":1}}],[\"下面证明加法消去律\",{\"1\":{\"55\":1}}],[\"下面证明加法结合律\",{\"1\":{\"54\":1}}],[\"下面证明加法交换律\",{\"1\":{\"53\":1}}],[\"下文用\",{\"1\":{\"47\":1}}],[\"下的实践是\",{\"1\":{\"31\":1}}],[\"下载错误查看\",{\"1\":{\"8\":1}}],[\"我认为这并无不可\",{\"1\":{\"205\":1}}],[\"我认为这也是初学者实现编译器的一大难点\",{\"1\":{\"180\":1}}],[\"我认为至少占了重要程度的50\",{\"1\":{\"204\":1}}],[\"我认为有几个要点需要强调\",{\"1\":{\"146\":1}}],[\"我知道\",{\"1\":{\"158\":1}}],[\"我是先写程序再总结上面的文法\",{\"1\":{\"156\":1}}],[\"我是抱着满腔热情去上课的\",{\"1\":{\"105\":1}}],[\"我仍然认为通过定义\",{\"1\":{\"108\":1}}],[\"我相信绝大多数\",{\"1\":{\"105\":1}}],[\"我对编译器一直心存敬佩\",{\"1\":{\"105\":1}}],[\"我会说是\",{\"1\":{\"104\":1}}],[\"我得拿到锁才能操作\",{\"1\":{\"90\":1}}],[\"我们才能有所成长吧\",{\"1\":{\"207\":1}}],[\"我们用了专门的一章讲解了\",{\"1\":{\"206\":1}}],[\"我们用了很暴力的手段编写了我们的词法分析器\",{\"1\":{\"205\":1}}],[\"我们用词法分析器将源码转换成标记流\",{\"1\":{\"142\":1}}],[\"我们还需要初始化虚拟机的栈\",{\"1\":{\"201\":1}}],[\"我们还可能返回除号\",{\"1\":{\"142\":1}}],[\"我们其实通过了参数\",{\"1\":{\"194\":1}}],[\"我们要使用变量\",{\"1\":{\"193\":1}}],[\"我们要从整体上讲解如何设计我们的\",{\"1\":{\"109\":1}}],[\"我们没有取负的操作\",{\"1\":{\"192\":1}}],[\"我们没有直接的逻辑取反指令\",{\"1\":{\"190\":1}}],[\"我们会遇到许多的挫折\",{\"1\":{\"207\":1}}],[\"我们会先加载它的地址\",{\"1\":{\"189\":1}}],[\"我们会将\",{\"1\":{\"135\":1}}],[\"我们可能会修改或删除现有的\",{\"1\":{\"186\":1}}],[\"我们可以正确调用\",{\"1\":{\"201\":1}}],[\"我们可以很容易地直接将\",{\"1\":{\"151\":1}}],[\"我们可以这样认为\",{\"1\":{\"133\":1}}],[\"我们可以使用的内存地址为\",{\"1\":{\"115\":1}}],[\"我们主要从它的目标代码入手\",{\"1\":{\"183\":1}}],[\"我们必须先计算优先级高的运算符\",{\"1\":{\"182\":1}}],[\"我们看看下面的伪代码\",{\"1\":{\"175\":1}}],[\"我们在第三章的虚拟机中提到过\",{\"1\":{\"170\":1}}],[\"我们实现的\",{\"1\":{\"170\":1}}],[\"我们实现的词法分析器与传统意义上的词法分析器不太相同\",{\"1\":{\"139\":1}}],[\"我们已经为变量\",{\"1\":{\"195\":1}}],[\"我们已经为当前的标识符\",{\"1\":{\"166\":1}}],[\"我们已经知道了什么时候开始解析函数的定义\",{\"1\":{\"166\":1}}],[\"我们就着手虚拟机的实现\",{\"1\":{\"204\":1}}],[\"我们就来逐一说明\",{\"1\":{\"181\":1}}],[\"我们就将它的类型加上\",{\"1\":{\"159\":1}}],[\"我们就知道是需要解析枚举类型\",{\"1\":{\"159\":1}}],[\"我们就能知道它们是特殊的关键字\",{\"1\":{\"144\":1}}],[\"我们把词法分析器的代码一并贴上\",{\"1\":{\"153\":1}}],[\"我们向前看一个标记\",{\"1\":{\"151\":1}}],[\"我们假设词法分析器已经正确地将其中的数字识别成了标记\",{\"1\":{\"150\":1}}],[\"我们对\",{\"1\":{\"150\":1}}],[\"我们下一章见\",{\"1\":{\"146\":1}}],[\"我们直接贴上代码\",{\"1\":{\"143\":1,\"153\":1}}],[\"我们之前说过\",{\"1\":{\"142\":1}}],[\"我们以异或\",{\"1\":{\"198\":1}}],[\"我们以\",{\"1\":{\"141\":1}}],[\"我们并不关心一个变量具体叫什么名字\",{\"1\":{\"139\":1}}],[\"我们并不会一次性地将所有源码全部转换成标记流\",{\"1\":{\"134\":1}}],[\"我们知道\",{\"1\":{\"136\":1}}],[\"我们同时还用它来处理空白字符\",{\"1\":{\"136\":1}}],[\"我们不另外处理它们的原因是\",{\"1\":{\"135\":1}}],[\"我们不妨通过类的运算符重载来进一步优化\",{\"1\":{\"40\":1}}],[\"我们为\",{\"1\":{\"127\":1}}],[\"我们依旧用上面的例子\",{\"1\":{\"126\":1}}],[\"我们连函数调用都无法实现\",{\"1\":{\"122\":1}}],[\"我们这里的\",{\"1\":{\"118\":1}}],[\"我们这里并不需要了解太多\",{\"1\":{\"115\":1}}],[\"我们需要类似下面的汇编代码\",{\"1\":{\"195\":1}}],[\"我们需要不断地向右扫描\",{\"1\":{\"194\":1}}],[\"我们需要处理多运算符的优先级问题\",{\"1\":{\"194\":1}}],[\"我们需要在栈上为局部变量预留空间\",{\"1\":{\"170\":1}}],[\"我们需要所有的变量定义出现在所有的语句之前\",{\"1\":{\"170\":1}}],[\"我们需要知道后面参数的类型\",{\"1\":{\"185\":1}}],[\"我们需要知道参数的个数\",{\"1\":{\"167\":1}}],[\"我们需要知道这两个\",{\"1\":{\"139\":1}}],[\"我们需要了解当\",{\"1\":{\"167\":1}}],[\"我们需要将它存放到前一篇文章中说的\",{\"1\":{\"141\":1}}],[\"我们需要将当前的行号加一\",{\"1\":{\"137\":1}}],[\"我们需要得到\",{\"1\":{\"126\":1}}],[\"我们需要条件判断相关的指令\",{\"1\":{\"121\":1}}],[\"我们需要首先在全局添加如下代码\",{\"1\":{\"115\":1}}],[\"我们需要证明乘法结果的存在性和唯一性\",{\"1\":{\"65\":1}}],[\"我们需要证明加法结果的存在性和唯一性\",{\"1\":{\"49\":1}}],[\"我们只关心三个内容\",{\"1\":{\"115\":1}}],[\"我们的代码是自举的\",{\"1\":{\"201\":1}}],[\"我们的代码里有一些指针的强制转换\",{\"1\":{\"129\":1}}],[\"我们的电脑上已经有了这些函数的实现\",{\"1\":{\"128\":1}}],[\"我们的\",{\"1\":{\"122\":1,\"126\":1}}],[\"我们的编译器支持指针类型\",{\"1\":{\"159\":1}}],[\"我们的编译器并不支持宏定义\",{\"1\":{\"138\":1}}],[\"我们的编译器是以标记流为输入\",{\"1\":{\"133\":1}}],[\"我们的编译器参数是顺序入栈的\",{\"1\":{\"122\":1}}],[\"我们的编译器主要包括\",{\"1\":{\"111\":1}}],[\"我们的虚拟机还是工作良好的\",{\"1\":{\"129\":1}}],[\"我们的虚拟机只有一个寄存器\",{\"1\":{\"118\":1}}],[\"我们的虚拟机中\",{\"1\":{\"116\":1}}],[\"我们的虚拟机并不打算模拟完整的计算机\",{\"1\":{\"115\":1}}],[\"我们也将构建出一个能用的\",{\"1\":{\"103\":1}}],[\"我们能对编译器的构建有一定的了解\",{\"1\":{\"103\":1}}],[\"我们应该养成具体问题具体分析的辩证唯物思想\",{\"1\":{\"93\":1}}],[\"我们再用多线程试一下同样的逻辑\",{\"1\":{\"92\":1}}],[\"我们将介绍递归下降的语法分析器\",{\"1\":{\"146\":1}}],[\"我们将同时分析单个字符如\",{\"1\":{\"141\":1}}],[\"我们将专门作为一个小节\",{\"1\":{\"116\":1}}],[\"我们将实现其中的eval函数\",{\"1\":{\"111\":1}}],[\"我们将逐个填充每个函数的功能\",{\"1\":{\"111\":1}}],[\"我们将借助另一个公理系统\",{\"1\":{\"73\":1}}],[\"我们将详细讲解环境配置\",{\"1\":{\"12\":1}}],[\"我们成功地由\",{\"1\":{\"73\":1}}],[\"我们终于可以对自然数乘法的性质进行进一步的探索\",{\"1\":{\"68\":1}}],[\"我们终于可以对自然数加法的性质进行进一步的探索\",{\"1\":{\"52\":1}}],[\"我们预先准备以方便证明\",{\"1\":{\"58\":1}}],[\"我们即可建立如今最常用的算术公理系统\",{\"1\":{\"46\":1}}],[\"我们考虑泛型编程\",{\"1\":{\"40\":1}}],[\"我的是\",{\"1\":{\"31\":1}}],[\"我还没有研究透\",{\"1\":{\"31\":1}}],[\"这也是我自己的感慨吧\",{\"1\":{\"207\":1}}],[\"这也意味着一元运算符的优先级总是高于多元运算符\",{\"1\":{\"183\":1}}],[\"这部分对于整个编译器的编写其实是十分重要的\",{\"1\":{\"204\":1}}],[\"这部分也将同时解析参数本身\",{\"1\":{\"183\":1}}],[\"这次是后缀形式的\",{\"1\":{\"199\":1}}],[\"这包括\",{\"1\":{\"197\":1}}],[\"这和第三章\",{\"1\":{\"186\":1}}],[\"这章讲解语句的解析\",{\"1\":{\"173\":1}}],[\"这一章\",{\"1\":{\"172\":1}}],[\"这一系列教程将带你从头编写一个\",{\"1\":{\"103\":1}}],[\"这两行代码起的就是这个作用\",{\"1\":{\"170\":1}}],[\"这段代码线性地遍历所有标识符\",{\"1\":{\"168\":1}}],[\"这么做的原因是\",{\"1\":{\"168\":1}}],[\"这么做的理由有两点\",{\"1\":{\"109\":1}}],[\"这相当于是整个函数定义的语法解析的框架\",{\"1\":{\"168\":1}}],[\"这点在后面的语法分析器我们就能体会\",{\"1\":{\"132\":1}}],[\"这点复杂度还是不算什么的\",{\"1\":{\"105\":1}}],[\"这就意味着表达式\",{\"1\":{\"182\":1}}],[\"这就用到了上一章中提到的\",{\"1\":{\"151\":1}}],[\"这就涉及到编译器\",{\"1\":{\"136\":1}}],[\"这就需要事先将这个位置信息存储起来\",{\"1\":{\"122\":1}}],[\"这就是主动让出\",{\"1\":{\"92\":1}}],[\"这后生成的目标代码便是我们的指令集\",{\"1\":{\"110\":1}}],[\"这意味着我们可以像运行脚本一样去运行\",{\"1\":{\"109\":1}}],[\"这是整个编译器的最后一部分\",{\"1\":{\"181\":1}}],[\"这是因为\",{\"1\":{\"168\":1}}],[\"这是上一章的\",{\"1\":{\"165\":1}}],[\"这是正常的\",{\"1\":{\"145\":1}}],[\"这是汇编中最难理解的部分\",{\"1\":{\"122\":1}}],[\"这是我们要支持的全部指令\",{\"1\":{\"117\":1}}],[\"这是\",{\"1\":{\"109\":1,\"113\":1,\"196\":1}}],[\"这篇博客并没有使用诸如\",{\"1\":{\"108\":1}}],[\"这篇文章将带你走进闭包的奇妙世界\",{\"1\":{\"98\":1}}],[\"这些就是我们要支持的标记符\",{\"1\":{\"135\":1}}],[\"这些工具允许我们通过正则表达式来识别标记\",{\"1\":{\"134\":1}}],[\"这些函数就是可用的\",{\"1\":{\"128\":1}}],[\"这些函数的二进制代码就被编译进了我们的编译器\",{\"1\":{\"128\":1}}],[\"这些指令只接受一个参数\",{\"1\":{\"118\":1}}],[\"这些指令的顺序安排是有意的\",{\"1\":{\"117\":1}}],[\"这些理论试图教会我们如何用通用的方法来自动解决问题\",{\"1\":{\"105\":1}}],[\"这些题目要么是因为答案太大\",{\"1\":{\"36\":1}}],[\"这其中最主要的原因是\",{\"1\":{\"105\":1}}],[\"这可能吗\",{\"1\":{\"92\":1}}],[\"这并不是事情的全貌\",{\"1\":{\"90\":1}}],[\"这并不是什么缺陷\",{\"1\":{\"89\":1}}],[\"这个\",{\"1\":{\"136\":2}}],[\"这个顺序要特别注意\",{\"1\":{\"127\":1}}],[\"这个gil全局解释器锁实际上把所有线程的执行代码都给上了锁\",{\"1\":{\"90\":1}}],[\"这个图满足如下性质\",{\"1\":{\"76\":1}}],[\"这实际上是符合客观逻辑的\",{\"1\":{\"89\":1}}],[\"这与\",{\"1\":{\"75\":1}}],[\"这究竟是为什么呢\",{\"1\":{\"73\":1}}],[\"这违背了\",{\"1\":{\"72\":1}}],[\"这样你就不需要重复造轮子\",{\"1\":{\"206\":1}}],[\"这样你就能用\",{\"1\":{\"31\":1}}],[\"这样它就成了全局的常量了\",{\"1\":{\"160\":1}}],[\"这样当源代码中出现关键字时\",{\"1\":{\"144\":1}}],[\"这样做的主要原因是为了简化虚拟机的实现\",{\"1\":{\"119\":1}}],[\"这样我们就有了一个最简单的编译器\",{\"1\":{\"111\":1}}],[\"这样就定义了自然数\",{\"1\":{\"47\":1}}],[\"这样就解决了类型名长的缺点\",{\"1\":{\"40\":1}}],[\"这样使用的时候\",{\"1\":{\"40\":1}}],[\"这种顺序的唯一作用就是在打印调试信息时更加方便\",{\"1\":{\"117\":1}}],[\"这种主动让出型的调度方式更为高效\",{\"1\":{\"91\":1}}],[\"这种处理方式是在画蛇添足\",{\"1\":{\"90\":1}}],[\"这种异步编程方式被广大开发者所认可\",{\"1\":{\"90\":1}}],[\"这种写法的式子依旧太长\",{\"1\":{\"39\":1}}],[\"这种方法有效地解决了直接取模的忘记取模的漏洞\",{\"1\":{\"39\":1}}],[\"这种方法是直接取模\",{\"1\":{\"38\":1}}],[\"这便是本文写作的背景\",{\"1\":{\"35\":1}}],[\"这中间就会导致\",{\"1\":{\"31\":1}}],[\"这里就不多作解释\",{\"1\":{\"196\":1}}],[\"这里\",{\"1\":{\"175\":1,\"194\":1}}],[\"这里最为重要的一点是\",{\"1\":{\"167\":1}}],[\"这里不再多说\",{\"1\":{\"152\":1}}],[\"这里会有一个疑问\",{\"1\":{\"151\":1}}],[\"这里我简单介绍一下\",{\"1\":{\"149\":1}}],[\"这里我们解析的就是类似\",{\"1\":{\"193\":1}}],[\"这里我们就能看到\",{\"1\":{\"189\":1}}],[\"这里我们就采用第二种方法\",{\"1\":{\"144\":1}}],[\"这里我们讲解其中的一些细节\",{\"1\":{\"159\":1}}],[\"这里我们要额外介绍\",{\"1\":{\"142\":1}}],[\"这里我们要为我们的虚拟机构建自己的指令集\",{\"1\":{\"117\":1}}],[\"这里我们首先要了解的是当参数调用时\",{\"1\":{\"126\":1}}],[\"这里我们约定\",{\"1\":{\"122\":1}}],[\"这里我们把\",{\"1\":{\"122\":1}}],[\"这里我们只实现两个最简单的条件判断\",{\"1\":{\"121\":1}}],[\"这里这样写的目的是装b\",{\"1\":{\"140\":1}}],[\"这里要说明这样一个观点\",{\"1\":{\"204\":1}}],[\"这里要注意的是在ascii码中\",{\"1\":{\"140\":1}}],[\"这里要解释的一点是\",{\"1\":{\"118\":1}}],[\"这里解释一下具体的含义\",{\"1\":{\"139\":1}}],[\"这里注意的是\",{\"1\":{\"134\":1}}],[\"这里的一个问题是\",{\"1\":{\"136\":1}}],[\"这里的原理是\",{\"1\":{\"128\":1}}],[\"这里的数据可以是代码\",{\"1\":{\"115\":1}}],[\"这里的finally\",{\"1\":{\"90\":1}}],[\"这里需要的是注意每个函数的作用\",{\"1\":{\"111\":1}}],[\"这里有一个单独用于解析\",{\"1\":{\"111\":1}}],[\"这里将目录修改为目标目录\",{\"1\":{\"21\":1}}],[\"这里是所有详细的教程和指南\",{\"1\":{\"101\":1}}],[\"这里是所有与技术相关的文章\",{\"1\":{\"34\":1}}],[\"这里是所有个人感想\",{\"1\":{\"2\":1}}],[\"这里是推荐的书籍\",{\"1\":{\"4\":1}}],[\"这里是你参与或开发的项目介绍和进展\",{\"1\":{\"3\":1}}],[\"等工具\",{\"1\":{\"206\":1}}],[\"等工具来编写\",{\"1\":{\"108\":1}}],[\"等指令\",{\"1\":{\"118\":1}}],[\"等等知识\",{\"1\":{\"205\":1}}],[\"等等\",{\"1\":{\"105\":1,\"135\":1,\"186\":1}}],[\"等待显示序列号\",{\"1\":{\"102\":1}}],[\"等待提示\",{\"1\":{\"102\":1}}],[\"等函数\",{\"1\":{\"40\":1}}],[\"等\",{\"1\":{\"31\":1,\"108\":1,\"135\":1,\"139\":1,\"141\":1,\"144\":1}}],[\"服务本体\",{\"1\":{\"31\":1}}],[\"一节提到的\",{\"1\":{\"194\":1}}],[\"一节中所说的修改或删除\",{\"1\":{\"189\":1}}],[\"一是运算符的优先级问题\",{\"1\":{\"181\":1}}],[\"一是容易忘记大括号\",{\"1\":{\"38\":1}}],[\"一元运算符\",{\"0\":{\"183\":1},\"1\":{\"181\":1}}],[\"一旦遇到了\",{\"1\":{\"177\":1}}],[\"一旦同名\",{\"1\":{\"168\":1}}],[\"一些非终结符如<expr>被递归地使用了\",{\"1\":{\"150\":1}}],[\"一种是自底向上\",{\"1\":{\"148\":1}}],[\"一种是自顶向下\",{\"1\":{\"148\":1}}],[\"一般终结符对应于词法分析器输出的标记\",{\"1\":{\"149\":1}}],[\"一般有两种处理方法\",{\"1\":{\"144\":1}}],[\"一般处理的方法有两种\",{\"1\":{\"136\":1}}],[\"一般而言\",{\"1\":{\"110\":1}}],[\"一般的编译器相关的教程要么就十分简单\",{\"1\":{\"106\":1}}],[\"一般编译原理的课程会说一些\",{\"1\":{\"105\":1}}],[\"一路点击\",{\"1\":{\"102\":1}}],[\"一方面没有很好的测试用例\",{\"1\":{\"107\":1}}],[\"一方面想了解它的工作原理\",{\"1\":{\"104\":1}}],[\"一方面\",{\"1\":{\"91\":1,\"118\":1}}],[\"一方面减少了心智负担\",{\"1\":{\"40\":1}}],[\"一个标记\",{\"1\":{\"135\":1}}],[\"一个语法分析器生成器\",{\"1\":{\"108\":1}}],[\"一个用于存储附属的数据\",{\"1\":{\"31\":1}}],[\"一个包含\",{\"1\":{\"31\":1}}],[\"一位热衷于探索全栈开发领域的技术爱好者\",{\"1\":{\"1\":1}}],[\"版权协议\",{\"1\":{\"29\":1}}],[\"版权声明\",{\"1\":{\"29\":1}}],[\"0xffff\",{\"1\":{\"191\":1}}],[\"0x123\",{\"1\":{\"140\":1}}],[\"017\",{\"1\":{\"140\":1}}],[\"0<=x\",{\"1\":{\"40\":1}}],[\"0\",{\"0\":{\"103\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1},\"1\":{\"29\":1,\"90\":1,\"91\":1,\"92\":17,\"103\":2,\"109\":1,\"111\":7,\"113\":1,\"115\":3,\"116\":2,\"118\":1,\"128\":1,\"129\":2,\"131\":1,\"138\":1,\"139\":1,\"140\":11,\"141\":1,\"142\":1,\"147\":1,\"153\":8,\"155\":1,\"158\":1,\"160\":1,\"164\":1,\"169\":1,\"173\":1,\"181\":1,\"184\":2,\"186\":2,\"190\":4,\"192\":1,\"203\":1}}],[\"06\",{\"1\":{\"29\":2}}],[\"遵循\",{\"1\":{\"29\":1}}],[\"2|\",{\"1\":{\"182\":1}}],[\"2+3\",{\"1\":{\"182\":1}}],[\"2+3的值\",{\"1\":{\"182\":1}}],[\"2+\",{\"1\":{\"126\":2,\"167\":2}}],[\"2^32\",{\"1\":{\"115\":1}}],[\"256\",{\"1\":{\"111\":1,\"115\":1}}],[\"28\",{\"1\":{\"92\":1}}],[\"2014\",{\"1\":{\"181\":1}}],[\"2016\",{\"1\":{\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"203\":1}}],[\"2015\",{\"1\":{\"109\":1,\"113\":1,\"131\":1}}],[\"20\",{\"1\":{\"129\":1,\"159\":1,\"182\":2}}],[\"208\",{\"1\":{\"89\":1,\"93\":1}}],[\"2024\",{\"1\":{\"29\":2}}],[\"2\",{\"1\":{\"31\":1,\"44\":1,\"91\":1,\"92\":3,\"103\":1,\"109\":2,\"113\":16,\"122\":2,\"126\":2,\"128\":4,\"131\":3,\"132\":2,\"145\":1,\"147\":2,\"150\":2,\"155\":7,\"164\":7,\"167\":2,\"170\":1,\"173\":3,\"181\":14,\"182\":7,\"186\":1,\"203\":2}}],[\"23\",{\"1\":{\"29\":2}}],[\"居然把路径藏在这里\",{\"0\":{\"29\":1},\"1\":{\"28\":1}}],[\"|add\",{\"1\":{\"198\":1}}],[\"|10\",{\"1\":{\"150\":1}}],[\"|9\",{\"1\":{\"150\":1}}],[\"|8\",{\"1\":{\"150\":1}}],[\"|5\",{\"1\":{\"150\":1}}],[\"|4\",{\"1\":{\"150\":1}}],[\"|<\",{\"1\":{\"139\":1,\"170\":1}}],[\"|token|hash|name|type|class|value|btype|bclass|bvalue|\",{\"1\":{\"139\":1}}],[\"|+\",{\"1\":{\"115\":3,\"182\":9}}],[\"||\",{\"1\":{\"115\":6,\"139\":5,\"140\":3,\"141\":1,\"143\":9,\"153\":1,\"170\":1,\"187\":1,\"189\":1,\"193\":1,\"195\":1,\"197\":2}}],[\"|\",{\"0\":{\"29\":1},\"1\":{\"28\":1,\"115\":4,\"126\":10,\"127\":1,\"133\":4,\"143\":3,\"149\":6,\"152\":5,\"156\":7,\"159\":2,\"165\":5,\"167\":9,\"168\":1,\"182\":12,\"198\":4}}],[\"踩坑记录\",{\"0\":{\"29\":1,\"30\":1},\"1\":{\"28\":1}}],[\"续订泛域名证书\",{\"1\":{\"25\":1}}],[\"省时又省力\",{\"1\":{\"25\":1}}],[\"使我们能直接使用编译器\",{\"1\":{\"115\":1}}],[\"使得函数\",{\"1\":{\"91\":1}}],[\"使得一段时间内只有一个线程可以操作这个资源\",{\"1\":{\"90\":1}}],[\"使flask支持\",{\"0\":{\"24\":1}}],[\"使用await关键字让出使用权\",{\"1\":{\"92\":1}}],[\"使用权\",{\"1\":{\"92\":1}}],[\"使用capacitor和ionic将vue项目迁移到mobile端\",{\"0\":{\"84\":1}}],[\"使用docker\",{\"1\":{\"25\":1}}],[\"使用\",{\"1\":{\"16\":1,\"22\":2,\"31\":1,\"86\":1,\"87\":1,\"92\":1}}],[\"重写的代码历时一周\",{\"1\":{\"106\":1}}],[\"重要的是去理解如何将这些语句编译成汇编代码\",{\"1\":{\"174\":1}}],[\"重要\",{\"1\":{\"87\":1,\"94\":1}}],[\"重启container\",{\"0\":{\"23\":1}}],[\"重定向到automaton\",{\"1\":{\"16\":1,\"22\":2}}],[\"3+\",{\"1\":{\"126\":1,\"167\":1}}],[\"32位系统\",{\"1\":{\"198\":1}}],[\"32\",{\"1\":{\"115\":1,\"129\":1}}],[\"32k\",{\"1\":{\"16\":1}}],[\"3\",{\"1\":{\"92\":1,\"103\":1,\"109\":1,\"110\":1,\"113\":3,\"122\":2,\"126\":1,\"128\":1,\"131\":14,\"132\":2,\"147\":2,\"150\":2,\"155\":4,\"160\":1,\"162\":1,\"164\":4,\"173\":3,\"175\":1,\"181\":10,\"182\":9,\"186\":1,\"196\":1,\"203\":2}}],[\"39\",{\"1\":{\"29\":2}}],[\"3001\",{\"1\":{\"181\":1}}],[\"30\",{\"1\":{\"29\":2,\"129\":1}}],[\"301\",{\"1\":{\"22\":2}}],[\"进程的内存会被分成几个段\",{\"1\":{\"115\":1}}],[\"进而当\",{\"1\":{\"53\":3,\"54\":1,\"55\":2,\"59\":1,\"69\":3,\"70\":1,\"71\":1,\"72\":1}}],[\"进而\",{\"1\":{\"51\":1,\"59\":1,\"61\":1,\"63\":1,\"67\":1,\"74\":1}}],[\"进而有\",{\"1\":{\"50\":1,\"66\":1}}],[\"进有\",{\"1\":{\"50\":1,\"51\":1,\"66\":1,\"67\":1}}],[\"进入acme\",{\"1\":{\"20\":1}}],[\"进行编译\",{\"1\":{\"201\":1}}],[\"进行解析的时候\",{\"1\":{\"194\":1}}],[\"进行语法分析\",{\"1\":{\"150\":1}}],[\"进行安装\",{\"1\":{\"102\":1}}],[\"进行包含\",{\"1\":{\"31\":1}}],[\"进行修改\",{\"1\":{\"15\":1}}],[\"进行如下操作\",{\"1\":{\"15\":1}}],[\"申请证书\",{\"0\":{\"20\":1}}],[\"升级为https\",{\"0\":{\"19\":1}}],[\"及函数定义\",{\"1\":{\"159\":1}}],[\"及\",{\"1\":{\"18\":1,\"122\":1,\"128\":1,\"166\":1,\"171\":1,\"185\":1}}],[\"失败\",{\"1\":{\"16\":1,\"22\":2}}],[\"或波浪号\",{\"1\":{\"135\":1}}],[\"或是调试起来十分困难\",{\"1\":{\"207\":1}}],[\"或是重新学习学习汇编相关的知识\",{\"1\":{\"172\":1}}],[\"或是函数的局部变量等\",{\"1\":{\"115\":1}}],[\"或是\",{\"1\":{\"97\":1}}],[\"或者执行过程中要根据变量状态进行一些下游操作\",{\"1\":{\"93\":1}}],[\"或者说的更简单一点\",{\"1\":{\"92\":1}}],[\"或\",{\"1\":{\"16\":1,\"22\":2,\"72\":1,\"105\":1,\"159\":1,\"186\":1,\"199\":1}}],[\"404\",{\"1\":{\"209\":1}}],[\"4096\",{\"1\":{\"16\":1}}],[\"4|\",{\"1\":{\"182\":1}}],[\"4+\",{\"1\":{\"126\":1}}],[\"4g\",{\"1\":{\"115\":1}}],[\"4版本的yield\",{\"1\":{\"92\":1}}],[\"443\",{\"1\":{\"17\":2,\"22\":3}}],[\"4\",{\"1\":{\"16\":1,\"29\":1,\"103\":1,\"106\":1,\"109\":1,\"111\":1,\"113\":3,\"116\":1,\"126\":1,\"128\":1,\"131\":3,\"132\":2,\"147\":3,\"150\":2,\"155\":3,\"164\":3,\"171\":1,\"173\":2,\"181\":4,\"182\":6,\"198\":1,\"203\":2}}],[\"kinds\",{\"1\":{\"140\":1}}],[\"kingsonfu\",{\"1\":{\"32\":1}}],[\"k\",{\"1\":{\"105\":1,\"108\":1,\"142\":2,\"146\":2,\"151\":1}}],[\"kcodetime\",{\"1\":{\"45\":1}}],[\"keep\",{\"1\":{\"144\":1}}],[\"keepalive\",{\"1\":{\"16\":1}}],[\"keywords\",{\"1\":{\"144\":1}}],[\"key\",{\"1\":{\"21\":2,\"22\":6}}],[\"kts\",{\"1\":{\"8\":1}}],[\"null\",{\"1\":{\"153\":2}}],[\"num\",{\"1\":{\"135\":1,\"140\":1,\"141\":3,\"149\":1,\"150\":4,\"152\":1,\"153\":3,\"156\":2,\"159\":2,\"160\":3,\"184\":2,\"186\":1,\"192\":2,\"194\":1}}],[\"number\",{\"1\":{\"132\":5,\"139\":1,\"140\":2,\"186\":1}}],[\"numbervoid\",{\"1\":{\"111\":1}}],[\"normal\",{\"1\":{\"187\":1}}],[\"now\",{\"1\":{\"185\":1,\"198\":2}}],[\"non\",{\"1\":{\"156\":3,\"165\":3}}],[\"note\",{\"1\":{\"159\":1}}],[\"not\",{\"1\":{\"111\":2,\"115\":3,\"121\":1,\"138\":1,\"190\":1,\"191\":1,\"198\":1,\"209\":1}}],[\"nothing\",{\"1\":{\"111\":2,\"192\":1}}],[\"node\",{\"1\":{\"102\":2}}],[\"nopush\",{\"1\":{\"16\":1}}],[\"n\",{\"1\":{\"90\":6,\"91\":3,\"92\":12,\"111\":4,\"115\":3,\"128\":1,\"137\":1,\"138\":1,\"141\":5,\"142\":1,\"153\":2,\"159\":2,\"160\":2,\"161\":1,\"169\":2,\"170\":2,\"186\":2,\"188\":1,\"189\":1,\"193\":1,\"195\":1,\"196\":1,\"200\":1}}],[\"net\",{\"1\":{\"181\":1}}],[\"networks\",{\"1\":{\"17\":2}}],[\"new\",{\"1\":{\"122\":1,\"123\":3,\"126\":8,\"139\":1,\"167\":7,\"169\":1}}],[\"newline\",{\"1\":{\"44\":1}}],[\"ne\",{\"1\":{\"117\":1,\"127\":1,\"135\":2,\"143\":1,\"194\":1}}],[\"next\",{\"1\":{\"111\":5,\"134\":1,\"136\":2,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1,\"144\":4,\"153\":3,\"158\":2,\"159\":1,\"160\":4,\"161\":2}}],[\"name\",{\"1\":{\"16\":2,\"22\":5,\"139\":5,\"168\":1,\"169\":2,\"170\":1}}],[\"nginx\",{\"0\":{\"12\":1},\"1\":{\"12\":2,\"13\":1,\"14\":2,\"16\":17,\"17\":10,\"20\":4,\"21\":4,\"22\":15,\"25\":2},\"2\":{\"26\":1}}],[\"xx\",{\"1\":{\"200\":1}}],[\"xxx\",{\"1\":{\"159\":1,\"174\":1}}],[\"xzp740813\",{\"1\":{\"181\":1}}],[\"xc\",{\"1\":{\"129\":2,\"201\":5}}],[\"xor\",{\"1\":{\"117\":1,\"127\":1,\"135\":1,\"143\":1,\"191\":2,\"194\":1,\"198\":4}}],[\"x86\",{\"1\":{\"117\":1,\"118\":2,\"119\":1,\"122\":1,\"130\":1}}],[\"x<p\",{\"1\":{\"40\":1}}],[\"x+y+z\",{\"1\":{\"40\":1}}],[\"x+y\",{\"1\":{\"38\":1}}],[\"x\",{\"1\":{\"16\":1,\"39\":1,\"40\":2,\"140\":2,\"159\":1,\"182\":3,\"192\":2}}],[\"$host$request\",{\"1\":{\"22\":2}}],[\"$http\",{\"1\":{\"16\":3}}],[\"$uri\",{\"1\":{\"16\":6,\"22\":10}}],[\"$body\",{\"1\":{\"16\":1}}],[\"$status\",{\"1\":{\"16\":1}}],[\"$request\",{\"1\":{\"16\":1}}],[\"$remote\",{\"1\":{\"16\":2}}],[\"$time\",{\"1\":{\"16\":1}}],[\"right\",{\"1\":{\"132\":1}}],[\"r\",{\"1\":{\"92\":1,\"141\":1}}],[\"range\",{\"1\":{\"90\":2,\"92\":1}}],[\"root\",{\"1\":{\"16\":2,\"20\":2,\"21\":1,\"22\":3,\"44\":1}}],[\"run\",{\"1\":{\"16\":1,\"91\":1,\"92\":3}}],[\"remove\",{\"1\":{\"122\":1,\"124\":2}}],[\"remote\",{\"1\":{\"31\":1}}],[\"ret\",{\"1\":{\"122\":9,\"125\":2}}],[\"returns\",{\"1\":{\"201\":1}}],[\"returnret\",{\"1\":{\"125\":1}}],[\"returned\",{\"1\":{\"111\":1}}],[\"return\",{\"0\":{\"177\":1},\"1\":{\"22\":2,\"39\":3,\"40\":4,\"111\":6,\"115\":3,\"118\":1,\"122\":3,\"128\":2,\"135\":1,\"136\":1,\"139\":3,\"140\":1,\"141\":2,\"142\":1,\"143\":15,\"144\":2,\"153\":11,\"156\":1,\"159\":1,\"165\":1,\"173\":1,\"174\":1,\"177\":6,\"194\":1}}],[\"registers\",{\"1\":{\"116\":1}}],[\"regex\",{\"1\":{\"108\":1}}],[\"read\",{\"1\":{\"111\":3,\"117\":1,\"128\":3,\"144\":1,\"186\":1}}],[\"rest\",{\"1\":{\"184\":1}}],[\"restore\",{\"1\":{\"122\":1,\"125\":2}}],[\"result\",{\"1\":{\"122\":1,\"198\":1}}],[\"res\",{\"1\":{\"91\":1,\"92\":3}}],[\"resolver\",{\"1\":{\"16\":2}}],[\"reverse\",{\"1\":{\"25\":1}}],[\"release\",{\"1\":{\"90\":1}}],[\"releases\",{\"1\":{\"8\":2}}],[\"reloadcmd\",{\"1\":{\"21\":1}}],[\"rewrite\",{\"1\":{\"16\":1,\"22\":2}}],[\"referer\",{\"1\":{\"16\":1}}],[\"repos\",{\"1\":{\"8\":1}}],[\"repository\",{\"1\":{\"8\":12}}],[\"repositoriesmode\",{\"1\":{\"8\":2}}],[\"repositories\",{\"1\":{\"8\":2}}],[\"142961332\",{\"1\":{\"181\":1}}],[\"147\",{\"1\":{\"139\":1}}],[\"15\",{\"1\":{\"140\":3,\"182\":2}}],[\"16\",{\"1\":{\"140\":2}}],[\"16k\",{\"1\":{\"16\":1}}],[\"1+\",{\"1\":{\"126\":2,\"167\":2}}],[\"123\",{\"1\":{\"140\":1}}],[\"128\",{\"1\":{\"135\":1,\"194\":1}}],[\"12\",{\"1\":{\"122\":2,\"124\":1}}],[\"18\",{\"1\":{\"92\":1}}],[\"10+20\",{\"1\":{\"129\":1}}],[\"1000\",{\"1\":{\"115\":1}}],[\"1000000\",{\"1\":{\"90\":2,\"92\":1}}],[\"1024\",{\"1\":{\"111\":1}}],[\"10\",{\"1\":{\"90\":1,\"91\":1,\"92\":6,\"113\":1,\"115\":1,\"129\":1,\"131\":1,\"139\":1,\"140\":1,\"153\":1,\"159\":1,\"181\":1,\"186\":1,\"200\":2}}],[\"10s\",{\"1\":{\"16\":1}}],[\"1ll\",{\"1\":{\"39\":1,\"40\":1}}],[\"11\",{\"1\":{\"113\":1}}],[\"1190000040806239\",{\"1\":{\"97\":1}}],[\"11578073\",{\"1\":{\"32\":1}}],[\"114\",{\"1\":{\"16\":4}}],[\"17\",{\"1\":{\"29\":2,\"92\":1}}],[\"1\",{\"0\":{\"46\":1,\"109\":1},\"1\":{\"16\":1,\"92\":3,\"103\":1,\"109\":3,\"111\":5,\"113\":6,\"115\":3,\"118\":1,\"121\":2,\"122\":3,\"123\":1,\"126\":2,\"128\":7,\"130\":1,\"131\":3,\"139\":1,\"140\":1,\"147\":2,\"150\":1,\"153\":1,\"155\":3,\"159\":3,\"160\":3,\"161\":1,\"164\":3,\"166\":1,\"167\":3,\"169\":2,\"170\":3,\"173\":7,\"175\":1,\"176\":2,\"181\":4,\"182\":1,\"186\":3,\"188\":1,\"189\":1,\"191\":2,\"192\":1,\"193\":1,\"195\":1,\"196\":2,\"197\":2,\"198\":1,\"200\":1,\"203\":2}}],[\"we\",{\"1\":{\"138\":1}}],[\"web\",{\"1\":{\"86\":1}}],[\"web服务器添加https功能\",{\"1\":{\"25\":1}}],[\"webnet\",{\"1\":{\"17\":2}}],[\"write\",{\"1\":{\"106\":1,\"109\":1,\"111\":1,\"113\":1,\"130\":1,\"131\":1,\"145\":1,\"147\":1,\"155\":1,\"162\":1,\"164\":1,\"171\":1,\"173\":1,\"179\":1,\"201\":1,\"203\":1}}],[\"wrapper\",{\"1\":{\"8\":1}}],[\"wodfan\",{\"1\":{\"92\":2}}],[\"work\",{\"1\":{\"92\":2}}],[\"worker\",{\"1\":{\"16\":2}}],[\"world\",{\"1\":{\"92\":2}}],[\"when\",{\"1\":{\"186\":1}}],[\"which\",{\"1\":{\"186\":1}}],[\"white\",{\"1\":{\"153\":1}}],[\"whitespace\",{\"1\":{\"44\":1}}],[\"while\",{\"0\":{\"176\":1},\"1\":{\"111\":1,\"118\":1,\"135\":1,\"136\":4,\"138\":1,\"139\":3,\"140\":3,\"141\":1,\"142\":1,\"144\":5,\"153\":3,\"156\":3,\"158\":1,\"159\":2,\"160\":1,\"165\":3,\"168\":3,\"169\":2,\"170\":4,\"173\":1,\"174\":1,\"176\":4,\"178\":1,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"194\":2}}],[\"what\",{\"1\":{\"31\":1}}],[\"will\",{\"1\":{\"138\":1}}],[\"with\",{\"1\":{\"90\":3,\"92\":6,\"140\":2,\"174\":1}}],[\"without\",{\"1\":{\"90\":1,\"91\":5,\"92\":15}}],[\"width\",{\"1\":{\"44\":1}}],[\"windows\",{\"1\":{\"32\":2}}],[\"win10\",{\"1\":{\"31\":3,\"32\":1}}],[\"wsl$\",{\"1\":{\"32\":3}}],[\"wsl2\",{\"0\":{\"29\":1,\"30\":1},\"1\":{\"28\":1,\"32\":1}}],[\"wsl\",{\"0\":{\"28\":1,\"32\":1},\"1\":{\"31\":4}}],[\"www\",{\"1\":{\"16\":1,\"22\":4,\"32\":1}}],[\"warn\",{\"1\":{\"16\":5,\"22\":5}}],[\"部分\",{\"1\":{\"157\":1}}],[\"部分ide默认直接支持\",{\"1\":{\"44\":1}}],[\"部分路径以实际为准\",{\"1\":{\"15\":1}}],[\"部署一个\",{\"1\":{\"12\":1}}],[\"部署\",{\"0\":{\"12\":1},\"2\":{\"27\":1}}],[\"emit\",{\"1\":{\"170\":1,\"175\":1,\"177\":1,\"184\":2,\"185\":1,\"186\":2,\"190\":1,\"191\":1}}],[\"empty\",{\"1\":{\"156\":5,\"165\":5,\"178\":1}}],[\"ebnf\",{\"0\":{\"156\":1,\"165\":1},\"1\":{\"155\":2,\"156\":1,\"163\":3,\"164\":1,\"165\":1}}],[\"ebppop\",{\"1\":{\"125\":1}}],[\"ebpmov\",{\"1\":{\"123\":1}}],[\"ebp\",{\"1\":{\"122\":6,\"123\":1,\"125\":1}}],[\"escape\",{\"1\":{\"141\":2}}],[\"esp\",{\"1\":{\"122\":6,\"123\":2,\"124\":2,\"125\":1}}],[\"eax\",{\"1\":{\"122\":1}}],[\"else\",{\"1\":{\"118\":4,\"119\":1,\"120\":1,\"121\":1,\"122\":2,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":16,\"128\":9,\"135\":1,\"138\":1,\"139\":1,\"140\":3,\"141\":2,\"142\":2,\"143\":23,\"144\":1,\"153\":5,\"156\":1,\"159\":2,\"161\":1,\"165\":1,\"166\":1,\"169\":1,\"174\":1,\"175\":7,\"176\":1,\"177\":1,\"178\":3,\"184\":1,\"185\":2,\"186\":7,\"187\":2,\"188\":2,\"189\":2,\"190\":1,\"191\":1,\"192\":3,\"193\":3,\"194\":1,\"195\":1,\"196\":2,\"197\":2,\"198\":2,\"200\":2}}],[\"eq\",{\"1\":{\"117\":1,\"127\":1,\"135\":2,\"143\":1,\"190\":1,\"194\":1}}],[\"eof\",{\"1\":{\"111\":1}}],[\"eval\",{\"1\":{\"111\":3,\"118\":2}}],[\"event\",{\"1\":{\"91\":1,\"92\":3}}],[\"events\",{\"1\":{\"16\":1}}],[\"expession\",{\"1\":{\"195\":1}}],[\"expected\",{\"1\":{\"153\":1,\"161\":1,\"200\":1}}],[\"expr\",{\"1\":{\"153\":8,\"159\":1,\"184\":2,\"185\":6,\"186\":4,\"187\":3,\"188\":5,\"189\":2,\"190\":1,\"191\":1,\"192\":2,\"193\":2,\"195\":4,\"196\":1,\"197\":2,\"198\":3,\"199\":5,\"200\":2}}],[\"expressionvoid\",{\"1\":{\"159\":1}}],[\"expression\",{\"1\":{\"111\":3,\"156\":5,\"160\":1,\"165\":4,\"171\":1,\"174\":3,\"175\":1,\"176\":1,\"177\":2,\"178\":1,\"179\":1,\"186\":1,\"187\":2,\"188\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":2,\"193\":1,\"194\":1,\"195\":1,\"196\":2,\"197\":2,\"198\":2,\"200\":1,\"202\":1}}],[\"exists\",{\"1\":{\"159\":1,\"170\":1}}],[\"exist\",{\"1\":{\"159\":1}}],[\"existing\",{\"1\":{\"139\":1}}],[\"exit\",{\"1\":{\"117\":1,\"128\":3,\"129\":2,\"144\":2,\"153\":1,\"159\":2,\"160\":2,\"161\":1,\"169\":2,\"170\":2,\"186\":2,\"188\":1,\"189\":1,\"193\":1,\"195\":1,\"196\":1,\"200\":1,\"201\":2}}],[\"exe\",{\"1\":{\"102\":5}}],[\"extension\",{\"1\":{\"45\":2}}],[\"enum\",{\"0\":{\"160\":1},\"1\":{\"135\":2,\"144\":1,\"155\":1,\"156\":2,\"157\":1,\"159\":9,\"160\":4,\"186\":2,\"194\":2}}],[\"enter\",{\"1\":{\"123\":1}}],[\"ent\",{\"0\":{\"123\":1},\"1\":{\"113\":1,\"117\":1,\"122\":1,\"123\":2,\"170\":1}}],[\"enhanced\",{\"1\":{\"97\":1}}],[\"enabled\",{\"1\":{\"86\":1}}],[\"end\",{\"1\":{\"44\":1,\"174\":1,\"184\":1}}],[\"environment\",{\"1\":{\"17\":1}}],[\"env\",{\"1\":{\"9\":2}}],[\"editorconfig文件\",{\"1\":{\"44\":1}}],[\"editorconfig\",{\"1\":{\"44\":1}}],[\"etc\",{\"1\":{\"16\":2,\"17\":4,\"22\":6}}],[\"error\",{\"1\":{\"14\":1,\"16\":10,\"22\":10}}],[\"└──\",{\"1\":{\"14\":2}}],[\"lvalue\",{\"1\":{\"153\":12,\"193\":1,\"195\":2}}],[\"lt\",{\"1\":{\"117\":1,\"127\":1,\"135\":1,\"143\":1,\"194\":1}}],[\"lc\",{\"1\":{\"117\":1,\"118\":5,\"186\":4,\"188\":1,\"189\":4,\"193\":2,\"195\":1,\"200\":1}}],[\"left\",{\"1\":{\"132\":1}}],[\"le\",{\"1\":{\"117\":1,\"127\":1,\"135\":1,\"143\":1,\"194\":1}}],[\"leaving\",{\"1\":{\"170\":1}}],[\"lea\",{\"0\":{\"126\":1},\"1\":{\"113\":1,\"117\":1,\"126\":2,\"186\":1}}],[\"lev\",{\"0\":{\"125\":1},\"1\":{\"113\":1,\"117\":1,\"122\":2,\"125\":2,\"170\":1,\"177\":2}}],[\"level\",{\"1\":{\"111\":2,\"194\":3}}],[\"lemon\",{\"1\":{\"108\":1}}],[\"let\",{\"1\":{\"108\":1}}],[\"letsencrypt\",{\"1\":{\"17\":1,\"22\":6}}],[\"lexer\",{\"1\":{\"133\":1}}],[\"lex\",{\"1\":{\"105\":2,\"134\":1}}],[\"ll\",{\"1\":{\"105\":1,\"108\":1,\"142\":1}}],[\"lf\",{\"1\":{\"44\":1}}],[\"literal\",{\"1\":{\"141\":2}}],[\"li\",{\"1\":{\"117\":1,\"118\":5,\"186\":4,\"188\":1,\"189\":4,\"193\":2,\"195\":2,\"200\":1}}],[\"license\",{\"1\":{\"102\":2}}],[\"liuyue$\",{\"1\":{\"92\":4}}],[\"liuyue\",{\"1\":{\"92\":6}}],[\"linesecond\",{\"1\":{\"184\":1}}],[\"linelen\",{\"1\":{\"153\":2}}],[\"linecap\",{\"1\":{\"153\":2}}],[\"linear\",{\"1\":{\"139\":1}}],[\"line\",{\"1\":{\"44\":1,\"111\":3,\"153\":3,\"159\":2,\"160\":2,\"161\":1,\"169\":2,\"170\":2,\"184\":3,\"186\":2,\"188\":1,\"189\":1,\"193\":1,\"195\":1,\"196\":1,\"200\":1}}],[\"linux\",{\"1\":{\"31\":2}}],[\"library\",{\"1\":{\"144\":1}}],[\"lib\",{\"1\":{\"32\":2}}],[\"like\",{\"1\":{\"21\":1,\"160\":1,\"170\":1}}],[\"live\",{\"1\":{\"17\":1,\"22\":6}}],[\"listen\",{\"1\":{\"16\":2,\"22\":5}}],[\"list\",{\"1\":{\"7\":1}}],[\"lan\",{\"1\":{\"135\":1,\"143\":1,\"194\":1,\"197\":3}}],[\"last\",{\"1\":{\"135\":1,\"136\":1,\"139\":4,\"141\":2}}],[\"lalr\",{\"1\":{\"105\":1}}],[\"latest\",{\"1\":{\"17\":1}}],[\"large\",{\"1\":{\"16\":1}}],[\"lookahead\",{\"1\":{\"142\":1,\"146\":1}}],[\"look\",{\"1\":{\"139\":1}}],[\"loop\",{\"1\":{\"91\":3,\"92\":9}}],[\"lor\",{\"1\":{\"135\":1,\"143\":1,\"194\":1,\"197\":2}}],[\"long\",{\"1\":{\"129\":4}}],[\"load\",{\"1\":{\"118\":3,\"126\":1,\"186\":1}}],[\"low\",{\"1\":{\"115\":1,\"126\":1,\"167\":1}}],[\"lotabout\",{\"1\":{\"109\":1,\"111\":1,\"113\":1,\"130\":1,\"131\":1,\"145\":1,\"147\":1,\"155\":1,\"162\":1,\"164\":1,\"171\":1,\"173\":1,\"179\":1,\"201\":1,\"203\":1}}],[\"loc\",{\"1\":{\"135\":1,\"168\":1,\"169\":2,\"170\":2,\"186\":1,\"194\":1}}],[\"lock\",{\"1\":{\"90\":8,\"91\":5,\"92\":23}}],[\"locating\",{\"1\":{\"32\":1}}],[\"location\",{\"1\":{\"16\":3,\"22\":6}}],[\"local\",{\"1\":{\"16\":1,\"126\":2,\"167\":5,\"168\":2,\"169\":1,\"170\":11,\"186\":1}}],[\"logic\",{\"1\":{\"197\":2}}],[\"log\",{\"1\":{\"14\":2,\"16\":29,\"17\":1,\"22\":30}}],[\"logs\",{\"1\":{\"14\":1,\"17\":1}}],[\"yet\",{\"1\":{\"111\":1}}],[\"yacc\",{\"1\":{\"105\":2,\"206\":1}}],[\"y\",{\"1\":{\"39\":1,\"40\":1}}],[\"yml\",{\"1\":{\"14\":1,\"17\":1}}],[\"your\",{\"1\":{\"45\":1}}],[\"you\",{\"1\":{\"7\":1}}],[\"bsion\",{\"1\":{\"206\":1}}],[\"bss\",{\"1\":{\"115\":2}}],[\"binary\",{\"1\":{\"194\":1}}],[\"bitwise\",{\"1\":{\"191\":1,\"198\":1}}],[\"bison\",{\"1\":{\"105\":1,\"106\":1,\"108\":1,\"110\":1}}],[\"bxxx\",{\"1\":{\"168\":1,\"169\":1}}],[\"bxxxx\",{\"1\":{\"139\":1}}],[\"body\",{\"1\":{\"156\":2,\"159\":1,\"165\":2,\"166\":1,\"168\":1,\"170\":1}}],[\"bnf\",{\"1\":{\"149\":1,\"151\":3,\"154\":1,\"156\":1,\"206\":2}}],[\"bnf什么的\",{\"1\":{\"105\":1}}],[\"bvalue\",{\"1\":{\"139\":2,\"168\":1,\"169\":1,\"170\":1}}],[\"btype\",{\"1\":{\"139\":2,\"168\":1,\"169\":1,\"170\":1}}],[\"bclass\",{\"1\":{\"139\":2,\"168\":1,\"169\":1,\"170\":1}}],[\"brak\",{\"1\":{\"135\":1,\"143\":1,\"194\":2,\"200\":2}}],[\"bracket\",{\"1\":{\"132\":2}}],[\"bp+\",{\"1\":{\"126\":1,\"167\":1}}],[\"bp\",{\"1\":{\"116\":3,\"123\":2,\"125\":2,\"126\":9,\"167\":7,\"169\":5,\"170\":2,\"186\":2}}],[\"ba\",{\"1\":{\"175\":1}}],[\"bad\",{\"1\":{\"159\":1,\"160\":2,\"169\":1,\"170\":1,\"186\":1,\"188\":1,\"189\":1,\"193\":1,\"195\":1}}],[\"basetype\",{\"1\":{\"159\":4,\"170\":2}}],[\"balance\",{\"1\":{\"90\":12,\"91\":7,\"92\":32}}],[\"backend\",{\"1\":{\"31\":1}}],[\"behaviour\",{\"1\":{\"186\":1}}],[\"be\",{\"1\":{\"159\":1,\"186\":1}}],[\"because\",{\"1\":{\"138\":1}}],[\"bepinex\",{\"1\":{\"43\":1}}],[\"below\",{\"1\":{\"21\":1}}],[\"b+p\",{\"1\":{\"39\":1}}],[\"b\",{\"1\":{\"39\":5,\"111\":1,\"130\":1,\"145\":1,\"159\":1,\"160\":1,\"162\":1,\"167\":2,\"171\":1,\"175\":8,\"176\":4,\"178\":1,\"179\":1,\"196\":1,\"197\":4,\"201\":1}}],[\"by\",{\"1\":{\"29\":1}}],[\"bytes\",{\"1\":{\"16\":1}}],[\"blog\",{\"1\":{\"14\":3,\"16\":4,\"17\":2,\"22\":7,\"181\":1}}],[\"but\",{\"1\":{\"186\":1}}],[\"button\",{\"1\":{\"7\":1}}],[\"bug\",{\"0\":{\"87\":1}}],[\"build\",{\"1\":{\"17\":1,\"18\":1,\"21\":1,\"23\":1,\"86\":2,\"108\":1}}],[\"buffers\",{\"1\":{\"16\":1}}],[\"buffer\",{\"1\":{\"16\":1}}],[\"bupt\",{\"1\":{\"12\":1,\"16\":4,\"18\":3,\"20\":2,\"21\":4,\"22\":14}}],[\"│\",{\"1\":{\"14\":6}}],[\"├──\",{\"1\":{\"14\":12}}],[\"unit\",{\"1\":{\"186\":1}}],[\"unityexplorer\",{\"1\":{\"43\":1}}],[\"unary\",{\"1\":{\"185\":1}}],[\"unwind\",{\"1\":{\"168\":1}}],[\"unknown\",{\"1\":{\"128\":1}}],[\"until\",{\"1\":{\"91\":1,\"92\":3}}],[\"undefined\",{\"1\":{\"45\":1,\"186\":1}}],[\"utf\",{\"1\":{\"44\":1}}],[\"u\",{\"1\":{\"38\":1,\"39\":1,\"40\":2}}],[\"uri\",{\"1\":{\"22\":2}}],[\"url\",{\"1\":{\"8\":2}}],[\"url=uri\",{\"1\":{\"8\":12}}],[\"up\",{\"1\":{\"18\":1,\"21\":1,\"23\":1}}],[\"use\",{\"1\":{\"21\":1,\"122\":1,\"190\":1,\"191\":1}}],[\"users\",{\"1\":{\"92\":2}}],[\"user\",{\"1\":{\"16\":3}}],[\"usr\",{\"1\":{\"16\":3,\"17\":2,\"22\":5}}],[\"ubuntu\",{\"1\":{\"13\":1,\"21\":4,\"31\":2}}],[\"环境\",{\"0\":{\"13\":1}}],[\"需要两个字符\",{\"1\":{\"135\":1}}],[\"需要注意的是\",{\"1\":{\"120\":1}}],[\"需要有参数\",{\"1\":{\"118\":1}}],[\"需要去理解程序运行中会有哪些状态\",{\"1\":{\"116\":1}}],[\"需要先将这个插件\",{\"1\":{\"97\":1}}],[\"需要先申请一个域名\",{\"1\":{\"12\":1}}],[\"需要创建配置文件\",{\"1\":{\"9\":1}}],[\"配置docker\",{\"0\":{\"17\":1}}],[\"配置nginx反向代理\",{\"0\":{\"24\":1}}],[\"配置nginx\",{\"0\":{\"16\":1}}],[\"配置http服务\",{\"0\":{\"15\":1}}],[\"配置以及如何升级到\",{\"1\":{\"12\":1}}],[\"配置\",{\"1\":{\"12\":1}}],[\"和字符串如\",{\"1\":{\"141\":1}}],[\"和文法并编写解析算法\",{\"1\":{\"108\":1}}],[\"和文法的定义\",{\"1\":{\"108\":1}}],[\"和开源作者们使用同一套流程\",{\"1\":{\"33\":1}}],[\"和\",{\"1\":{\"12\":2,\"50\":2,\"66\":1,\"72\":1,\"102\":1,\"104\":1,\"118\":1,\"157\":1,\"174\":1,\"175\":1,\"182\":1,\"197\":1}}],[\"本节中我们专注语法分析器部分的实现\",{\"1\":{\"153\":1}}],[\"本节的代码可以在\",{\"1\":{\"111\":1}}],[\"本例中是\",{\"1\":{\"150\":1}}],[\"本章有两个难点\",{\"1\":{\"202\":1}}],[\"本章讲解了如何将语句编译成汇编代码\",{\"1\":{\"180\":1}}],[\"本章讲解函数定义相关的内容\",{\"1\":{\"164\":1}}],[\"本章的内容应该不难\",{\"1\":{\"163\":1}}],[\"本章的代码依旧无法运行\",{\"1\":{\"171\":1,\"179\":1}}],[\"本章的代码还无法正常运行\",{\"1\":{\"162\":1}}],[\"本章的代码可以在\",{\"1\":{\"130\":1,\"145\":1,\"162\":1,\"171\":1,\"179\":1,\"201\":1}}],[\"本章要讲解的就是上节文法中的\",{\"1\":{\"157\":1}}],[\"本章中我们发一发牢骚\",{\"1\":{\"203\":1}}],[\"本章中我们用了不多的代码完成了函数定义的解析\",{\"1\":{\"172\":1}}],[\"本章中我们用\",{\"1\":{\"155\":1}}],[\"本章中我们介绍了递归下降的方法\",{\"1\":{\"154\":1}}],[\"本章中我们回顾了计算机的内部运行原理\",{\"1\":{\"130\":1}}],[\"本章我们进行了最后的解析\",{\"1\":{\"202\":1}}],[\"本章我们将讲解递归下降的方法\",{\"1\":{\"147\":1}}],[\"本章我们为我们的编译器构建了词法分析器\",{\"1\":{\"146\":1}}],[\"本章我们要讲解如何构建词法分析器\",{\"1\":{\"131\":1}}],[\"本章我们要构建一台虚拟的电脑\",{\"1\":{\"113\":1}}],[\"本质上这个指令并不是必需的\",{\"1\":{\"125\":1}}],[\"本质上是因为我们的\",{\"1\":{\"124\":1}}],[\"本项目中的代码逻辑绝大多数取自\",{\"1\":{\"106\":1}}],[\"本篇是一些闲聊\",{\"1\":{\"103\":1}}],[\"本来就没有两全其美的解决方案\",{\"1\":{\"92\":1}}],[\"本来就只能一个人打电话\",{\"1\":{\"90\":1}}],[\"本文转自\",{\"1\":{\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1}}],[\"本文转载自\",{\"1\":{\"103\":1}}],[\"本文为博主原创文章\",{\"1\":{\"29\":1}}],[\"本文是\",{\"1\":{\"12\":1}}],[\"本文将介绍如何使用\",{\"1\":{\"12\":1}}],[\"本地调试工具\",{\"1\":{\"9\":1}}],[\"+var\",{\"1\":{\"192\":1}}],[\"+global\",{\"1\":{\"156\":1}}],[\"++p时\",{\"1\":{\"193\":1}}],[\"++p\",{\"1\":{\"193\":2}}],[\"++pos\",{\"1\":{\"170\":1}}],[\"++text\",{\"1\":{\"170\":3,\"175\":4,\"176\":4,\"177\":1,\"184\":4,\"185\":2,\"186\":13,\"188\":1,\"190\":4,\"191\":4,\"192\":6,\"193\":7,\"195\":1,\"196\":4,\"197\":4,\"198\":8,\"199\":14,\"200\":7}}],[\"++\",{\"1\":{\"143\":10,\"153\":2,\"186\":1,\"187\":1,\"188\":1}}],[\"++line\",{\"1\":{\"137\":1}}],[\"++src\",{\"1\":{\"136\":1,\"140\":2,\"142\":1}}],[\"+=\",{\"1\":{\"122\":1}}],[\"+|return\",{\"1\":{\"126\":1,\"167\":1}}],[\"+|\",{\"1\":{\"115\":4,\"126\":7,\"167\":6,\"182\":6}}],[\"+\",{\"0\":{\"12\":2},\"1\":{\"90\":2,\"91\":1,\"92\":4,\"115\":2,\"116\":1,\"121\":2,\"124\":1,\"126\":6,\"127\":1,\"128\":1,\"132\":1,\"133\":8,\"135\":1,\"139\":22,\"140\":6,\"143\":3,\"149\":2,\"150\":2,\"152\":1,\"153\":4,\"159\":4,\"166\":1,\"167\":3,\"168\":1,\"169\":1,\"170\":1,\"175\":2,\"176\":2,\"182\":27,\"184\":1,\"185\":1,\"187\":1,\"189\":1,\"196\":2,\"197\":2,\"198\":3,\"200\":1,\"201\":1}}],[\"virtual\",{\"1\":{\"115\":1,\"116\":1}}],[\"visualstudio\",{\"1\":{\"45\":1}}],[\"vs\",{\"1\":{\"97\":2}}],[\"vscode中可以使用\",{\"1\":{\"86\":1}}],[\"vscode\",{\"0\":{\"45\":1},\"1\":{\"87\":1}}],[\"v3u\",{\"1\":{\"89\":1,\"93\":1}}],[\"void\",{\"1\":{\"40\":1,\"111\":2,\"118\":1,\"122\":1,\"136\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1,\"144\":2,\"153\":2,\"158\":1,\"160\":1,\"161\":1,\"168\":1,\"170\":1}}],[\"volumes\",{\"1\":{\"17\":1,\"32\":2}}],[\"v+p\",{\"1\":{\"40\":1}}],[\"v+a\",{\"1\":{\"40\":3}}],[\"v<a\",{\"1\":{\"40\":1}}],[\"v>=p\",{\"1\":{\"40\":1}}],[\"v=x\",{\"1\":{\"40\":1}}],[\"v\",{\"1\":{\"40\":10,\"115\":1}}],[\"val\",{\"1\":{\"139\":1,\"140\":10,\"141\":7,\"153\":5,\"160\":1,\"184\":2,\"192\":1}}],[\"value\",{\"1\":{\"118\":3,\"119\":1,\"132\":1,\"139\":4,\"144\":1,\"153\":12,\"159\":2,\"160\":1,\"166\":1,\"168\":1,\"169\":3,\"170\":2,\"186\":6,\"198\":1}}],[\"valid=300s\",{\"1\":{\"16\":1}}],[\"variables\",{\"1\":{\"168\":1,\"170\":2}}],[\"variable\",{\"1\":{\"122\":1,\"123\":1,\"144\":1,\"156\":3,\"157\":1,\"159\":7,\"165\":2,\"168\":3,\"169\":1,\"170\":2,\"186\":5}}],[\"vars\",{\"1\":{\"9\":1}}],[\"var\",{\"1\":{\"9\":1,\"16\":10,\"17\":1,\"22\":10,\"32\":2,\"126\":2,\"192\":1,\"195\":1,\"200\":1}}],[\"vue\",{\"0\":{\"12\":1},\"1\":{\"12\":1}}],[\"version\",{\"1\":{\"8\":1,\"32\":2}}],[\"7章函数定义\",{\"1\":{\"186\":1}}],[\"7|\",{\"1\":{\"182\":1}}],[\"7\",{\"1\":{\"8\":1,\"91\":1,\"92\":4,\"103\":1,\"109\":1,\"113\":2,\"131\":2,\"140\":1,\"147\":2,\"155\":1,\"164\":1,\"173\":2,\"181\":2,\"203\":1}}],[\"80\",{\"1\":{\"16\":2,\"17\":2,\"22\":2}}],[\"8\",{\"1\":{\"8\":1,\"16\":4,\"44\":1,\"90\":1,\"91\":1,\"92\":6,\"103\":1,\"109\":1,\"113\":2,\"131\":2,\"140\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":2,\"203\":1}}],[\"m32\",{\"1\":{\"129\":2}}],[\"mcmp\",{\"1\":{\"117\":1,\"128\":1}}],[\"mset\",{\"1\":{\"117\":1,\"128\":1}}],[\"m\",{\"1\":{\"115\":1}}],[\"memcmp\",{\"1\":{\"128\":2,\"139\":1,\"144\":1}}],[\"memset\",{\"1\":{\"115\":3,\"116\":1,\"128\":2,\"144\":1}}],[\"memory\",{\"1\":{\"115\":1,\"159\":2,\"166\":1}}],[\"me\",{\"1\":{\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"203\":1}}],[\"mytornado\",{\"1\":{\"92\":5}}],[\"multiply\",{\"1\":{\"132\":1}}],[\"mul\",{\"1\":{\"39\":1,\"117\":1,\"127\":1,\"135\":2,\"143\":1,\"159\":2,\"169\":2,\"170\":2,\"185\":2,\"187\":2,\"188\":2,\"192\":1,\"194\":1,\"198\":3,\"200\":1}}],[\"mod\",{\"1\":{\"117\":1,\"127\":1,\"135\":1,\"143\":1,\"194\":1}}],[\"modint1\",{\"1\":{\"40\":1}}],[\"modint<int\",{\"1\":{\"40\":3}}],[\"modint\",{\"0\":{\"35\":1},\"1\":{\"40\":9},\"2\":{\"42\":1,\"100\":1}}],[\"move\",{\"1\":{\"184\":1}}],[\"movw\",{\"1\":{\"118\":1}}],[\"movb\",{\"1\":{\"118\":1}}],[\"mov\",{\"0\":{\"118\":1},\"1\":{\"113\":1,\"118\":6,\"122\":4,\"125\":1}}],[\"mobile\",{\"2\":{\"88\":1}}],[\"more\",{\"1\":{\"32\":1}}],[\"missing\",{\"1\":{\"196\":1}}],[\"mime\",{\"1\":{\"16\":1}}],[\"mirrors\",{\"1\":{\"8\":1}}],[\"may\",{\"1\":{\"159\":1}}],[\"match\",{\"1\":{\"153\":8,\"159\":10,\"161\":2,\"168\":5,\"169\":5,\"170\":5,\"175\":4,\"176\":3,\"177\":2,\"178\":4,\"184\":3,\"185\":6,\"186\":4,\"187\":5,\"188\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":3,\"193\":1,\"195\":1,\"196\":2,\"197\":2,\"198\":2,\"200\":2}}],[\"macro\",{\"1\":{\"138\":1}}],[\"machine\",{\"1\":{\"115\":1,\"116\":1}}],[\"make\",{\"1\":{\"122\":1,\"123\":3,\"159\":1}}],[\"malc\",{\"1\":{\"117\":1,\"128\":1}}],[\"malloc\",{\"1\":{\"111\":2,\"115\":6,\"128\":2,\"144\":1,\"186\":1}}],[\"markdown\",{\"1\":{\"97\":3,\"102\":1}}],[\"master\",{\"1\":{\"92\":1}}],[\"maps\",{\"1\":{\"32\":1}}],[\"mainly\",{\"1\":{\"139\":1}}],[\"main\",{\"1\":{\"16\":2,\"111\":1,\"115\":1,\"116\":1,\"129\":2,\"144\":3,\"153\":1,\"201\":3}}],[\"maintenance\",{\"0\":{\"7\":1},\"1\":{\"7\":1}}],[\"mavencentral\",{\"1\":{\"8\":2}}],[\"maven\",{\"1\":{\"8\":26}}],[\"duplicate\",{\"1\":{\"159\":1,\"169\":1,\"170\":1,\"193\":1}}],[\"dump\",{\"1\":{\"115\":1}}],[\"directly\",{\"1\":{\"143\":1}}],[\"divide\",{\"1\":{\"142\":1}}],[\"div\",{\"1\":{\"117\":1,\"127\":1,\"135\":1,\"142\":2,\"194\":1}}],[\"distro\",{\"1\":{\"31\":3}}],[\"distributionurl=https\",{\"1\":{\"8\":1}}],[\"do\",{\"1\":{\"111\":2,\"192\":1}}],[\"done\",{\"1\":{\"102\":1}}],[\"documentation\",{\"1\":{\"25\":2}}],[\"docker部署certbot与nginx来获取ssl证书添加https及自动更新\",{\"1\":{\"25\":1}}],[\"dockerfile\",{\"1\":{\"14\":1,\"17\":3}}],[\"docker\",{\"0\":{\"12\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1},\"1\":{\"12\":2,\"13\":2,\"14\":1,\"17\":1,\"18\":1,\"21\":1,\"23\":1,\"28\":1,\"31\":10,\"32\":10}}],[\"dcqe\",{\"1\":{\"102\":1}}],[\"dnspy\",{\"1\":{\"43\":1}}],[\"dp\",{\"1\":{\"36\":1}}],[\"data++\",{\"1\":{\"141\":1}}],[\"data\",{\"1\":{\"31\":1,\"32\":7,\"111\":1,\"115\":8,\"141\":4,\"159\":5,\"184\":4}}],[\"dereference\",{\"1\":{\"188\":3}}],[\"details\",{\"1\":{\"181\":1}}],[\"demo函数被调用时\",{\"1\":{\"167\":1}}],[\"demo\",{\"1\":{\"167\":1}}],[\"declenum\",{\"1\":{\"156\":1}}],[\"decl\",{\"1\":{\"156\":10,\"157\":2,\"159\":8,\"165\":7,\"166\":2,\"168\":4,\"169\":1}}],[\"declarations\",{\"1\":{\"168\":1,\"170\":1}}],[\"declaration\",{\"0\":{\"159\":1,\"160\":1},\"1\":{\"155\":2,\"156\":2,\"158\":3,\"159\":10,\"160\":1,\"161\":1,\"166\":1,\"168\":1,\"169\":2,\"170\":4}}],[\"dec\",{\"1\":{\"135\":1,\"140\":2,\"143\":1,\"193\":1,\"194\":1}}],[\"design\",{\"0\":{\"210\":1}}],[\"dest\",{\"1\":{\"118\":2}}],[\"desktop\",{\"0\":{\"31\":1},\"1\":{\"31\":5,\"32\":4}}],[\"devtool\",{\"1\":{\"103\":1}}],[\"dev\",{\"1\":{\"96\":1}}],[\"define\",{\"1\":{\"129\":1}}],[\"def\",{\"1\":{\"90\":2,\"91\":1,\"92\":5}}],[\"default\",{\"1\":{\"16\":1,\"111\":1,\"184\":1,\"186\":1}}],[\"deploy\",{\"1\":{\"86\":1}}],[\"dependencyresolutionmanagement\",{\"1\":{\"8\":1}}],[\"d\",{\"1\":{\"14\":1,\"16\":1,\"17\":4,\"18\":1,\"20\":2,\"21\":2,\"23\":1,\"111\":2,\"115\":3,\"128\":2,\"153\":3,\"159\":2,\"160\":3,\"161\":2,\"169\":2,\"170\":2,\"186\":2,\"188\":1,\"189\":1,\"193\":1,\"195\":1,\"196\":1,\"200\":1}}],[\"o\",{\"1\":{\"201\":1}}],[\"occurs\",{\"1\":{\"186\":1}}],[\"oct\",{\"1\":{\"140\":2}}],[\"octet\",{\"1\":{\"16\":1}}],[\"out\",{\"1\":{\"129\":1}}],[\"op\",{\"1\":{\"118\":6,\"119\":1,\"120\":1,\"121\":2,\"122\":2,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":16,\"128\":9}}],[\"operators\",{\"1\":{\"135\":1}}],[\"operator\",{\"1\":{\"40\":3,\"142\":1,\"185\":1,\"194\":2}}],[\"operator+\",{\"1\":{\"40\":1}}],[\"open\",{\"1\":{\"7\":1,\"111\":2,\"117\":1,\"128\":3,\"144\":2}}],[\"order\",{\"1\":{\"135\":1}}],[\"or\",{\"1\":{\"117\":1,\"127\":1,\"135\":1,\"143\":4,\"178\":1,\"187\":1,\"194\":1,\"197\":2}}],[\"old\",{\"1\":{\"111\":2,\"115\":2,\"122\":1,\"125\":1,\"126\":1,\"167\":1}}],[\"of\",{\"1\":{\"43\":1,\"44\":1,\"109\":1,\"111\":1,\"113\":1,\"119\":1,\"131\":1,\"139\":2,\"144\":2,\"147\":1,\"155\":1,\"159\":4,\"164\":1,\"166\":1,\"169\":5,\"170\":4,\"173\":1,\"181\":1,\"184\":1,\"186\":3,\"189\":3,\"193\":1,\"198\":1,\"203\":1}}],[\"off\",{\"1\":{\"16\":1}}],[\"oi\",{\"0\":{\"35\":1},\"1\":{\"35\":1},\"2\":{\"41\":1,\"99\":1}}],[\"other\",{\"1\":{\"9\":1}}],[\"only\",{\"1\":{\"141\":1,\"185\":1,\"186\":1}}],[\"online\",{\"1\":{\"12\":1,\"16\":4,\"18\":3,\"20\":2,\"21\":4,\"22\":14}}],[\"ones\",{\"1\":{\"170\":1}}],[\"one\",{\"1\":{\"139\":2,\"184\":1}}],[\"onto\",{\"1\":{\"119\":1}}],[\"on\",{\"1\":{\"8\":1,\"16\":2,\"32\":1,\"118\":2,\"169\":1,\"170\":1,\"198\":2}}],[\"f\",{\"1\":{\"140\":2}}],[\"found\",{\"1\":{\"139\":1,\"209\":1}}],[\"forward\",{\"1\":{\"184\":1}}],[\"forwarded\",{\"1\":{\"16\":1}}],[\"for\",{\"1\":{\"16\":1,\"90\":4,\"92\":3,\"111\":1,\"115\":5,\"122\":1,\"123\":1,\"126\":1,\"139\":2,\"159\":2,\"168\":1,\"170\":2,\"175\":1,\"177\":1,\"186\":1,\"194\":1}}],[\"format\",{\"1\":{\"16\":1}}],[\"false\",{\"1\":{\"175\":1,\"190\":1}}],[\"falt\",{\"1\":{\"145\":1}}],[\"factor\",{\"1\":{\"153\":4}}],[\"fault\",{\"1\":{\"129\":1}}],[\"failed\",{\"1\":{\"45\":1}}],[\"fail\",{\"1\":{\"8\":1}}],[\"frameadd\",{\"1\":{\"124\":1}}],[\"framepush\",{\"1\":{\"123\":1}}],[\"frame\",{\"1\":{\"115\":1,\"122\":3,\"123\":2,\"124\":1,\"125\":2}}],[\"from\",{\"1\":{\"17\":1,\"92\":1,\"122\":2,\"124\":2}}],[\"fd\",{\"1\":{\"111\":4,\"115\":1}}],[\"flex\",{\"1\":{\"105\":1,\"106\":1,\"108\":1,\"110\":1,\"134\":1}}],[\"flask\",{\"0\":{\"12\":1},\"1\":{\"12\":1,\"25\":3}}],[\"func\",{\"1\":{\"168\":1,\"170\":1}}],[\"functions\",{\"1\":{\"186\":1}}],[\"functionvoid\",{\"1\":{\"144\":1}}],[\"functionenum\",{\"1\":{\"144\":1,\"159\":1}}],[\"function\",{\"1\":{\"126\":1,\"156\":2,\"159\":4,\"161\":1,\"165\":1,\"166\":2,\"168\":5,\"169\":1,\"170\":2,\"178\":1,\"186\":4}}],[\"function执行时间超过5s\",{\"1\":{\"45\":1}}],[\"function执行时间过长\",{\"1\":{\"45\":1}}],[\"fun\",{\"1\":{\"135\":1,\"159\":1,\"166\":2,\"186\":1,\"194\":1}}],[\"fullchain\",{\"1\":{\"21\":2,\"22\":3}}],[\"fields\",{\"1\":{\"139\":1}}],[\"first\",{\"1\":{\"45\":1,\"184\":2}}],[\"finally\",{\"1\":{\"90\":1}}],[\"final\",{\"1\":{\"44\":1}}],[\"files\",{\"1\":{\"16\":3,\"22\":5,\"102\":1}}],[\"file\",{\"1\":{\"9\":3,\"21\":3,\"111\":1}}],[\"filter\",{\"1\":{\"7\":1}}],[\"peg\",{\"1\":{\"206\":1}}],[\"peano\",{\"0\":{\"73\":1,\"76\":1,\"77\":1,\"78\":1,\"79\":1,\"80\":1,\"81\":1},\"1\":{\"46\":2,\"47\":1,\"50\":2,\"51\":2,\"53\":3,\"54\":1,\"55\":2,\"59\":2,\"62\":1,\"66\":1,\"67\":1,\"69\":3,\"70\":1,\"71\":1,\"72\":4,\"73\":5}}],[\"p++\",{\"1\":{\"193\":1,\"199\":1}}],[\"p+z\",{\"1\":{\"38\":1}}],[\"ptr\",{\"1\":{\"144\":1,\"159\":5,\"169\":1,\"170\":1,\"184\":1,\"185\":1,\"187\":1,\"188\":2,\"189\":1,\"193\":1,\"198\":1,\"199\":3,\"200\":3}}],[\"pc+1\",{\"1\":{\"122\":1}}],[\"pc++\",{\"1\":{\"118\":1,\"123\":1,\"124\":1,\"126\":1}}],[\"pc\",{\"1\":{\"116\":2,\"120\":4,\"121\":6,\"122\":4,\"125\":2,\"128\":1,\"129\":1}}],[\"push<expr2>\",{\"1\":{\"198\":1}}],[\"push\",{\"0\":{\"119\":1},\"1\":{\"113\":1,\"117\":1,\"118\":1,\"119\":3,\"122\":7,\"129\":2,\"186\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":4,\"195\":1,\"198\":4,\"199\":3,\"200\":2,\"201\":1}}],[\"publisher\",{\"1\":{\"45\":1}}],[\"public\",{\"1\":{\"8\":2,\"40\":1}}],[\"ps\",{\"1\":{\"107\":1}}],[\"ppt\",{\"1\":{\"97\":1}}],[\"py\",{\"1\":{\"92\":2}}],[\"python3\",{\"0\":{\"89\":1},\"1\":{\"92\":2}}],[\"python\",{\"1\":{\"13\":1,\"92\":1}}],[\"position\",{\"1\":{\"170\":1,\"184\":1}}],[\"pos\",{\"1\":{\"136\":1,\"139\":4,\"141\":2,\"170\":3}}],[\"postfix\",{\"1\":{\"194\":1}}],[\"post\",{\"1\":{\"43\":1,\"97\":1}}],[\"pop\",{\"1\":{\"118\":1,\"122\":1,\"125\":1}}],[\"poolsize\",{\"1\":{\"111\":5,\"115\":9,\"116\":2,\"201\":1}}],[\"pointer<expr1>\",{\"1\":{\"198\":1}}],[\"pointer\",{\"1\":{\"111\":1,\"159\":1,\"169\":2,\"185\":1,\"195\":1,\"198\":1,\"200\":2}}],[\"powershell\",{\"1\":{\"102\":1}}],[\"ports\",{\"1\":{\"17\":1}}],[\"p>\",{\"1\":{\"40\":1}}],[\"p=998244353\",{\"1\":{\"38\":1,\"39\":1}}],[\"p\",{\"1\":{\"32\":1,\"38\":2,\"39\":2,\"40\":2,\"156\":1,\"184\":4,\"193\":1,\"199\":1,\"207\":1}}],[\"parenthesis\",{\"1\":{\"187\":2}}],[\"params+1\",{\"1\":{\"169\":1}}],[\"params++\",{\"1\":{\"169\":1}}],[\"params\",{\"1\":{\"169\":2}}],[\"param\",{\"1\":{\"167\":5}}],[\"parameter\",{\"1\":{\"156\":2,\"159\":1,\"165\":2,\"166\":1,\"168\":1,\"169\":6,\"170\":1}}],[\"part\",{\"1\":{\"159\":2,\"168\":1}}],[\"parsed\",{\"1\":{\"139\":1}}],[\"parse\",{\"1\":{\"136\":1,\"137\":1,\"139\":1,\"140\":1,\"141\":1,\"143\":8,\"159\":5,\"160\":1,\"175\":3,\"194\":1}}],[\"parser\",{\"1\":{\"108\":1,\"133\":1}}],[\"pack\",{\"1\":{\"32\":2}}],[\"pass\",{\"1\":{\"16\":1,\"22\":2,\"186\":1}}],[\"pre\",{\"1\":{\"193\":1}}],[\"precedence\",{\"1\":{\"135\":1,\"187\":1,\"188\":1}}],[\"preview\",{\"1\":{\"97\":1}}],[\"prtf\",{\"1\":{\"117\":1,\"128\":1}}],[\"printf\",{\"1\":{\"111\":4,\"115\":3,\"128\":7,\"144\":1,\"153\":2,\"159\":2,\"160\":2,\"161\":1,\"169\":2,\"170\":2,\"186\":3,\"188\":1,\"189\":1,\"193\":1,\"195\":1,\"196\":1,\"200\":1}}],[\"print\",{\"1\":{\"90\":1,\"91\":1,\"92\":10}}],[\"private\",{\"1\":{\"40\":1}}],[\"privkey\",{\"1\":{\"21\":1,\"22\":3}}],[\"program\",{\"0\":{\"158\":1},\"1\":{\"102\":1,\"111\":3,\"115\":1,\"116\":1,\"129\":1,\"144\":1,\"155\":1,\"156\":1,\"158\":2}}],[\"proxy\",{\"1\":{\"16\":1,\"22\":2,\"25\":1}}],[\"processes\",{\"1\":{\"16\":1}}],[\"properties\",{\"1\":{\"8\":1}}],[\"project\",{\"1\":{\"8\":1,\"14\":1,\"17\":2}}],[\"pid\",{\"1\":{\"16\":2}}],[\"plugins\",{\"1\":{\"86\":1}}],[\"pluginmanagement\",{\"1\":{\"8\":1}}],[\"plugin\",{\"0\":{\"43\":1,\"45\":1},\"1\":{\"8\":3,\"43\":1}}],[\"got\",{\"1\":{\"153\":1}}],[\"google\",{\"1\":{\"8\":4}}],[\"glo\",{\"1\":{\"135\":1,\"159\":1,\"160\":1,\"186\":1,\"194\":1}}],[\"global\",{\"0\":{\"159\":1},\"1\":{\"90\":2,\"91\":1,\"92\":4,\"155\":1,\"156\":1,\"158\":3,\"159\":6,\"170\":1,\"186\":1}}],[\"gcc\",{\"1\":{\"129\":2,\"201\":1}}],[\"gt\",{\"1\":{\"117\":1,\"127\":1,\"135\":1,\"143\":1,\"194\":1}}],[\"git\",{\"1\":{\"111\":1,\"130\":1,\"145\":1,\"162\":1,\"171\":1,\"179\":1,\"201\":1}}],[\"github\",{\"0\":{\"33\":1},\"1\":{\"106\":1,\"111\":2,\"130\":2,\"145\":2,\"162\":2,\"171\":2,\"179\":2,\"201\":2}}],[\"gil\",{\"1\":{\"91\":1}}],[\"gather\",{\"1\":{\"91\":1,\"92\":3}}],[\"game\",{\"0\":{\"43\":1},\"1\":{\"43\":1}}],[\"ge\",{\"1\":{\"117\":1,\"127\":1,\"135\":1,\"143\":1,\"194\":1}}],[\"generator\",{\"1\":{\"108\":1}}],[\"generally\",{\"1\":{\"32\":1}}],[\"gen\",{\"1\":{\"102\":2}}],[\"getline\",{\"1\":{\"153\":1}}],[\"get\",{\"1\":{\"45\":1,\"91\":1,\"92\":3,\"111\":1,\"158\":1,\"189\":2}}],[\"guide\",{\"1\":{\"25\":1,\"96\":1}}],[\"gradlepluginportal\",{\"1\":{\"8\":1}}],[\"gradle\",{\"1\":{\"8\":6}}],[\"just\",{\"1\":{\"170\":1,\"184\":1}}],[\"jump\",{\"1\":{\"120\":1,\"121\":2}}],[\"judge\",{\"1\":{\"36\":1}}],[\"jnz\",{\"0\":{\"121\":1},\"1\":{\"113\":1,\"117\":1,\"121\":1,\"197\":2}}],[\"jz\",{\"0\":{\"121\":1},\"1\":{\"113\":1,\"117\":1,\"121\":1,\"175\":2,\"176\":2,\"196\":1,\"197\":2}}],[\"jmp\",{\"0\":{\"120\":1},\"1\":{\"113\":1,\"117\":1,\"120\":3,\"122\":1,\"175\":4,\"176\":2,\"196\":1}}],[\"java这些成熟的语言都是手动实现的\",{\"1\":{\"108\":1}}],[\"join\",{\"1\":{\"90\":1,\"92\":1}}],[\"jcenter\",{\"1\":{\"8\":2}}],[\"jitpack\",{\"1\":{\"8\":2}}],[\"has\",{\"1\":{\"187\":1,\"188\":1}}],[\"hash\",{\"1\":{\"136\":1,\"139\":10}}],[\"handle\",{\"1\":{\"144\":1}}],[\"harmony\",{\"1\":{\"43\":1}}],[\"high\",{\"1\":{\"115\":1,\"126\":1,\"167\":1}}],[\"h>enum\",{\"1\":{\"153\":1}}],[\"h>int\",{\"1\":{\"111\":1}}],[\"h>\",{\"1\":{\"111\":3,\"138\":1,\"153\":1}}],[\"hex\",{\"1\":{\"140\":2}}],[\"here\",{\"1\":{\"136\":1,\"137\":1}}],[\"heap\",{\"1\":{\"115\":2}}],[\"header\",{\"1\":{\"16\":2}}],[\"helloworld\",{\"1\":{\"103\":1}}],[\"hello\",{\"1\":{\"92\":5,\"129\":1,\"201\":2}}],[\"html\",{\"1\":{\"16\":3,\"17\":2,\"22\":5,\"32\":1}}],[\"http\",{\"1\":{\"16\":1,\"18\":3}}],[\"https\",{\"0\":{\"24\":1},\"1\":{\"8\":14,\"12\":1,\"22\":2,\"32\":1,\"45\":1,\"89\":1,\"93\":1,\"96\":1,\"97\":2,\"109\":1,\"111\":1,\"113\":1,\"130\":1,\"131\":1,\"145\":1,\"147\":1,\"155\":1,\"162\":1,\"164\":1,\"171\":1,\"173\":1,\"179\":1,\"181\":1,\"201\":1,\"203\":1}}],[\"home\",{\"0\":{\"0\":1},\"1\":{\"21\":4}}],[\"修改配置\",{\"0\":{\"22\":1}}],[\"修改\",{\"1\":{\"8\":1}}],[\"国内镜像\",{\"1\":{\"8\":1}}],[\"csdn\",{\"1\":{\"181\":1}}],[\"cycle\",{\"1\":{\"116\":1}}],[\"cpu\",{\"1\":{\"114\":2,\"116\":1,\"117\":2}}],[\"cpp\",{\"1\":{\"108\":1}}],[\"currently\",{\"1\":{\"141\":1}}],[\"current\",{\"1\":{\"111\":1,\"139\":13,\"144\":6,\"159\":6,\"160\":3,\"166\":2,\"168\":11,\"169\":11,\"170\":11,\"186\":1}}],[\"c4\",{\"1\":{\"106\":4,\"140\":1}}],[\"c\",{\"0\":{\"103\":1,\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1},\"1\":{\"102\":1,\"103\":15,\"106\":4,\"109\":16,\"111\":4,\"113\":13,\"118\":1,\"122\":2,\"127\":1,\"128\":1,\"129\":3,\"130\":2,\"131\":12,\"135\":1,\"136\":1,\"138\":1,\"139\":1,\"142\":1,\"145\":1,\"147\":12,\"153\":2,\"155\":13,\"162\":1,\"164\":12,\"170\":2,\"171\":1,\"173\":12,\"174\":1,\"175\":1,\"176\":1,\"179\":1,\"181\":11,\"182\":2,\"184\":1,\"186\":1,\"196\":1,\"198\":1,\"200\":1,\"201\":5,\"203\":13}}],[\"character\",{\"1\":{\"111\":1,\"118\":2,\"141\":3,\"143\":1,\"184\":1}}],[\"char\",{\"1\":{\"111\":1,\"115\":1,\"118\":2,\"128\":6,\"129\":1,\"135\":1,\"136\":1,\"139\":3,\"144\":4,\"153\":3,\"159\":5,\"167\":1,\"169\":3,\"170\":2,\"184\":3,\"185\":7,\"186\":1,\"187\":3,\"188\":1,\"193\":2,\"194\":1,\"195\":1,\"198\":1,\"199\":5,\"200\":2}}],[\"charset\",{\"1\":{\"44\":1}}],[\"change\",{\"1\":{\"90\":2,\"91\":5,\"92\":16}}],[\"cn\",{\"1\":{\"89\":1,\"93\":1,\"96\":1}}],[\"cnblogs\",{\"1\":{\"32\":1}}],[\"cast\",{\"1\":{\"187\":3}}],[\"caller\",{\"1\":{\"122\":2}}],[\"callee\",{\"1\":{\"122\":4}}],[\"call\",{\"1\":{\"117\":1,\"122\":10,\"123\":2,\"125\":2,\"178\":1,\"186\":6,\"201\":1}}],[\"calling\",{\"1\":{\"115\":1}}],[\"cap\",{\"1\":{\"86\":2}}],[\"capacitorhttp\",{\"1\":{\"86\":1}}],[\"capacitorconfig\",{\"1\":{\"86\":1}}],[\"capacitor\",{\"1\":{\"85\":1}}],[\"can\",{\"1\":{\"7\":1,\"186\":1}}],[\"ccompiler\",{\"0\":{\"210\":1}}],[\"cc\",{\"1\":{\"29\":1}}],[\"cer\",{\"1\":{\"21\":2,\"22\":3}}],[\"certificates\",{\"1\":{\"25\":1}}],[\"certificate\",{\"1\":{\"22\":6}}],[\"cert\",{\"1\":{\"21\":3}}],[\"central\",{\"1\":{\"8\":2}}],[\"colon\",{\"1\":{\"196\":1}}],[\"could\",{\"1\":{\"111\":2,\"115\":3}}],[\"code\",{\"1\":{\"45\":1,\"97\":2,\"111\":1,\"133\":1,\"170\":1,\"175\":1,\"177\":1,\"184\":2,\"185\":1,\"186\":2,\"190\":1,\"191\":1}}],[\"copy\",{\"1\":{\"17\":2,\"86\":1}}],[\"convenienceint\",{\"1\":{\"159\":1}}],[\"conditional\",{\"1\":{\"196\":1}}],[\"condition\",{\"1\":{\"175\":1}}],[\"cond\",{\"1\":{\"135\":1,\"143\":1,\"194\":1,\"196\":3}}],[\"const\",{\"1\":{\"40\":9,\"86\":1}}],[\"constexpr\",{\"1\":{\"38\":1,\"39\":1}}],[\"contents\",{\"1\":{\"109\":1,\"113\":1,\"131\":1,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1}}],[\"content\",{\"1\":{\"43\":1}}],[\"context\",{\"1\":{\"17\":1}}],[\"containers\",{\"1\":{\"32\":1}}],[\"connections\",{\"1\":{\"16\":1}}],[\"config\",{\"1\":{\"86\":1}}],[\"conf\",{\"1\":{\"14\":4,\"16\":5,\"17\":6,\"22\":2}}],[\"comma\",{\"1\":{\"159\":1}}],[\"comments\",{\"1\":{\"142\":2}}],[\"community\",{\"1\":{\"32\":2}}],[\"compiler\",{\"1\":{\"108\":1}}],[\"complete\",{\"1\":{\"91\":1,\"92\":3}}],[\"compose\",{\"1\":{\"13\":1,\"14\":1,\"17\":1,\"18\":1,\"21\":1,\"23\":1}}],[\"component\",{\"1\":{\"7\":1}}],[\"com\",{\"1\":{\"8\":13,\"32\":1,\"45\":1,\"97\":2,\"111\":1,\"130\":1,\"145\":1,\"162\":1,\"171\":1,\"179\":1,\"201\":1}}],[\"cd\",{\"0\":{\"9\":1},\"1\":{\"21\":2},\"2\":{\"10\":1,\"11\":1}}],[\"ci\",{\"0\":{\"9\":1},\"2\":{\"10\":1,\"11\":1}}],[\"clean\",{\"1\":{\"186\":1}}],[\"clos\",{\"1\":{\"117\":1,\"128\":1}}],[\"close\",{\"1\":{\"111\":1,\"115\":1,\"128\":2,\"144\":1}}],[\"clone\",{\"1\":{\"111\":2,\"130\":2,\"145\":2,\"162\":2,\"171\":2,\"179\":2,\"201\":2}}],[\"cloud\",{\"1\":{\"8\":1}}],[\"classes\",{\"1\":{\"135\":1}}],[\"class\",{\"1\":{\"40\":1,\"139\":3,\"144\":1,\"159\":3,\"160\":1,\"166\":1,\"168\":2,\"169\":3,\"170\":3,\"186\":5}}],[\"client\",{\"1\":{\"16\":2}}],[\"click\",{\"1\":{\"7\":2}}],[\"skip\",{\"1\":{\"138\":1,\"142\":1,\"153\":1,\"159\":1}}],[\"symbols\",{\"1\":{\"139\":3,\"168\":1}}],[\"symbol\",{\"1\":{\"139\":2,\"144\":2}}],[\"system\",{\"1\":{\"186\":1}}],[\"sys\",{\"1\":{\"135\":1,\"144\":1,\"186\":1,\"194\":1}}],[\"sync\",{\"1\":{\"86\":2}}],[\"sc\",{\"1\":{\"117\":1,\"118\":4,\"193\":1,\"195\":1,\"199\":2}}],[\"single\",{\"1\":{\"139\":1,\"141\":1}}],[\"si\",{\"1\":{\"117\":1,\"118\":4,\"193\":1,\"195\":2,\"199\":2}}],[\"sizeof\",{\"0\":{\"185\":1},\"1\":{\"135\":1,\"144\":1,\"159\":1,\"181\":1,\"184\":2,\"185\":9,\"193\":2,\"194\":1,\"198\":1,\"199\":6,\"200\":1}}],[\"size\",{\"1\":{\"16\":1,\"111\":2,\"153\":1,\"170\":1}}],[\"src++\",{\"1\":{\"111\":1,\"138\":1,\"139\":1,\"140\":2,\"141\":3,\"143\":1,\"153\":1}}],[\"src\",{\"1\":{\"111\":6,\"136\":1,\"138\":2,\"139\":10,\"140\":6,\"141\":2,\"142\":3,\"143\":19,\"144\":1,\"153\":9}}],[\"s\",{\"1\":{\"108\":1,\"111\":1,\"156\":1,\"195\":1,\"207\":1}}],[\"ssize\",{\"1\":{\"153\":1}}],[\"sspai\",{\"1\":{\"97\":1}}],[\"ssl\",{\"1\":{\"22\":9,\"25\":1}}],[\"sli\",{\"1\":{\"96\":1}}],[\"slidev\",{\"0\":{\"95\":1}}],[\"sleep\",{\"1\":{\"92\":3}}],[\"spm=1001\",{\"1\":{\"181\":1}}],[\"sp++\",{\"1\":{\"118\":3,\"122\":1,\"125\":2,\"127\":16}}],[\"sp\",{\"1\":{\"116\":4,\"119\":1,\"122\":1,\"123\":4,\"124\":2,\"125\":1,\"128\":16,\"201\":6}}],[\"space\",{\"1\":{\"44\":1,\"153\":1}}],[\"special\",{\"1\":{\"36\":1}}],[\"same\",{\"1\":{\"188\":1}}],[\"save\",{\"1\":{\"118\":2,\"122\":1,\"123\":1,\"170\":1,\"195\":1}}],[\"sa\",{\"1\":{\"29\":1}}],[\"supported\",{\"1\":{\"141\":1,\"185\":1}}],[\"support\",{\"1\":{\"138\":1}}],[\"subtract\",{\"1\":{\"132\":1}}],[\"subroutine\",{\"1\":{\"122\":4}}],[\"sub\",{\"1\":{\"39\":1,\"117\":1,\"122\":1,\"123\":1,\"126\":1,\"127\":1,\"135\":1,\"143\":1,\"170\":1,\"192\":2,\"193\":1,\"194\":1,\"199\":3}}],[\"su\",{\"1\":{\"20\":1,\"21\":1}}],[\"sudo\",{\"1\":{\"20\":1,\"21\":1}}],[\"stdin\",{\"1\":{\"153\":1}}],[\"stored\",{\"1\":{\"186\":1}}],[\"store\",{\"1\":{\"139\":1,\"141\":1,\"169\":1,\"170\":1,\"184\":1}}],[\"step\",{\"1\":{\"111\":1,\"130\":1,\"145\":1,\"162\":1,\"171\":1,\"179\":1,\"182\":3,\"201\":1}}],[\"statement>b\",{\"1\":{\"175\":1}}],[\"statement>\",{\"1\":{\"174\":1,\"175\":3}}],[\"statements\",{\"1\":{\"170\":2}}],[\"statementnon\",{\"1\":{\"156\":1,\"165\":1}}],[\"statement\",{\"1\":{\"156\":12,\"165\":12,\"170\":1,\"171\":1,\"174\":1,\"175\":5,\"176\":1,\"178\":2}}],[\"stacksp\",{\"1\":{\"201\":1}}],[\"stackvoid\",{\"1\":{\"169\":1}}],[\"stackchar\",{\"1\":{\"115\":1}}],[\"stack\",{\"1\":{\"115\":6,\"116\":2,\"118\":2,\"119\":1,\"122\":1,\"123\":2,\"170\":2,\"186\":1,\"201\":1}}],[\"stackint\",{\"1\":{\"111\":1}}],[\"starts\",{\"1\":{\"140\":2}}],[\"start\",{\"1\":{\"90\":1,\"92\":1}}],[\"started\",{\"1\":{\"45\":1}}],[\"struct\",{\"1\":{\"139\":2}}],[\"strings\",{\"1\":{\"184\":1}}],[\"string\",{\"1\":{\"111\":1,\"141\":3,\"184\":1}}],[\"stream\",{\"1\":{\"16\":1,\"132\":1,\"133\":1}}],[\"style\",{\"1\":{\"44\":1}}],[\"studio时不能打开360手机助手\",{\"1\":{\"87\":1}}],[\"studio下载gradle太慢可换源\",{\"1\":{\"8\":1}}],[\"studio换源\",{\"0\":{\"8\":1}}],[\"should\",{\"1\":{\"159\":1}}],[\"shr\",{\"1\":{\"117\":1,\"127\":1,\"135\":1,\"143\":1,\"194\":1}}],[\"shl\",{\"1\":{\"117\":1,\"127\":1,\"135\":1,\"143\":1,\"194\":1}}],[\"sh帮你免费且自动更新的https证书\",{\"1\":{\"25\":1}}],[\"sh的安装目录\",{\"1\":{\"20\":1}}],[\"shanghai\",{\"1\":{\"17\":1}}],[\"share\",{\"1\":{\"16\":3,\"17\":2,\"22\":5}}],[\"sh\",{\"0\":{\"12\":1},\"1\":{\"12\":1,\"13\":1,\"20\":3,\"21\":2}}],[\"several\",{\"1\":{\"186\":1}}],[\"semicolon\",{\"1\":{\"174\":1}}],[\"seperated\",{\"1\":{\"159\":1}}],[\"search\",{\"1\":{\"139\":1}}],[\"segmentation\",{\"1\":{\"129\":1,\"145\":1}}],[\"segment\",{\"1\":{\"115\":6,\"166\":1}}],[\"segmentfault\",{\"1\":{\"97\":1}}],[\"services\",{\"1\":{\"17\":1}}],[\"server\",{\"1\":{\"16\":4,\"22\":10}}],[\"sendfile\",{\"1\":{\"16\":1}}],[\"sent\",{\"1\":{\"16\":1}}],[\"second\",{\"1\":{\"184\":1}}],[\"secrets\",{\"1\":{\"9\":1}}],[\"secret\",{\"1\":{\"9\":1}}],[\"section\",{\"1\":{\"7\":1}}],[\"setup\",{\"1\":{\"201\":1}}],[\"set\",{\"1\":{\"8\":1}}],[\"settings\",{\"1\":{\"8\":1}}],[\"see\",{\"1\":{\"7\":1}}],[\"select\",{\"1\":{\"7\":1}}],[\"so\",{\"1\":{\"184\":1,\"186\":1}}],[\"source\",{\"1\":{\"111\":3,\"118\":2,\"133\":1}}],[\"solutions\",{\"0\":{\"6\":1}}],[\"some\",{\"0\":{\"6\":1}}],[\"after\",{\"1\":{\"182\":3}}],[\"ab\",{\"1\":{\"176\":1}}],[\"about\",{\"0\":{\"6\":1}}],[\"a=10\",{\"1\":{\"160\":1}}],[\"a是41\",{\"1\":{\"140\":1}}],[\"ax上需要保留原来的值\",{\"1\":{\"199\":1}}],[\"axxor\",{\"1\":{\"198\":1}}],[\"axpush\",{\"1\":{\"198\":1}}],[\"ax\",{\"1\":{\"116\":3,\"118\":26,\"119\":4,\"121\":5,\"122\":1,\"126\":2,\"127\":34,\"128\":7,\"129\":1,\"184\":1,\"186\":1,\"195\":1,\"199\":1}}],[\"adj\",{\"0\":{\"124\":1},\"1\":{\"113\":1,\"117\":1,\"122\":1,\"124\":2,\"186\":1}}],[\"add\",{\"1\":{\"39\":3,\"40\":1,\"111\":1,\"117\":1,\"122\":3,\"124\":2,\"126\":1,\"127\":1,\"129\":1,\"132\":1,\"135\":2,\"143\":1,\"144\":2,\"192\":2,\"193\":1,\"194\":1,\"198\":5,\"199\":3,\"200\":1}}],[\"address\",{\"1\":{\"118\":6,\"120\":1,\"126\":3,\"159\":2,\"166\":1,\"167\":2,\"186\":1,\"189\":3,\"193\":1}}],[\"address+\",{\"1\":{\"115\":1,\"126\":1,\"167\":1}}],[\"address|\",{\"1\":{\"115\":1}}],[\"addr\",{\"1\":{\"16\":1,\"196\":4,\"197\":4}}],[\"await\",{\"1\":{\"92\":5,\"93\":1}}],[\"array\",{\"1\":{\"200\":1}}],[\"are\",{\"1\":{\"184\":1,\"185\":1,\"186\":1}}],[\"area\",{\"1\":{\"111\":1,\"115\":3}}],[\"article\",{\"1\":{\"181\":1}}],[\"arbitrary\",{\"1\":{\"111\":1}}],[\"arg\",{\"1\":{\"126\":3,\"167\":2}}],[\"arg3\",{\"1\":{\"126\":1}}],[\"arg2\",{\"1\":{\"126\":1}}],[\"arg1\",{\"1\":{\"126\":1}}],[\"arguments\",{\"1\":{\"122\":2,\"124\":2,\"126\":1,\"186\":3}}],[\"argv++\",{\"1\":{\"111\":1}}],[\"argv\",{\"1\":{\"111\":3,\"129\":1,\"153\":1,\"201\":1}}],[\"argc\",{\"1\":{\"111\":2,\"129\":1,\"153\":1,\"201\":1}}],[\"args=\",{\"1\":{\"90\":2,\"92\":4}}],[\"archive\",{\"1\":{\"7\":1}}],[\"asimpile\",{\"0\":{\"210\":1}}],[\"assignment\",{\"1\":{\"195\":1}}],[\"assign\",{\"1\":{\"135\":2,\"143\":1,\"159\":2,\"160\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"186\":1,\"187\":1,\"194\":2,\"195\":3,\"196\":1,\"200\":1}}],[\"assembly\",{\"1\":{\"133\":1}}],[\"assetstudioassetstudio\",{\"1\":{\"43\":1}}],[\"assert\",{\"1\":{\"40\":1}}],[\"as\",{\"1\":{\"92\":1,\"143\":1,\"187\":1,\"188\":1}}],[\"async\",{\"1\":{\"91\":1,\"92\":5}}],[\"asyncio\",{\"0\":{\"89\":1},\"1\":{\"91\":3,\"92\":13}}],[\"again\",{\"1\":{\"92\":2}}],[\"aggregateerror\",{\"1\":{\"45\":1}}],[\"agent\",{\"1\":{\"16\":1}}],[\"append\",{\"1\":{\"184\":1}}],[\"application\",{\"1\":{\"16\":1}}],[\"api\",{\"1\":{\"45\":1}}],[\"a<b\",{\"1\":{\"39\":1}}],[\"a+b\",{\"1\":{\"39\":2}}],[\"a+b>=p\",{\"1\":{\"39\":1}}],[\"a\",{\"1\":{\"39\":6,\"40\":6,\"89\":1,\"93\":1,\"97\":1,\"106\":1,\"108\":1,\"109\":1,\"111\":1,\"113\":1,\"129\":1,\"130\":1,\"131\":1,\"139\":8,\"140\":4,\"141\":5,\"145\":1,\"147\":1,\"155\":1,\"159\":2,\"160\":1,\"162\":1,\"164\":1,\"167\":3,\"171\":1,\"173\":1,\"175\":4,\"176\":4,\"178\":1,\"179\":1,\"186\":1,\"188\":2,\"189\":2,\"191\":1,\"195\":2,\"196\":1,\"198\":3,\"200\":2,\"201\":1,\"203\":1}}],[\"an\",{\"1\":{\"159\":1,\"185\":1}}],[\"ans=\",{\"1\":{\"40\":1}}],[\"ans=mul\",{\"1\":{\"39\":1}}],[\"ans=1ll\",{\"1\":{\"38\":1}}],[\"android\",{\"0\":{\"8\":1},\"1\":{\"8\":2,\"86\":1}}],[\"and\",{\"1\":{\"7\":1,\"117\":1,\"125\":1,\"127\":1,\"135\":3,\"143\":5,\"185\":1,\"189\":2,\"194\":2,\"197\":1,\"198\":2}}],[\"automaton\",{\"1\":{\"14\":3,\"16\":9,\"17\":2,\"18\":2,\"20\":1,\"22\":16}}],[\"acquire\",{\"1\":{\"90\":1}}],[\"access\",{\"1\":{\"14\":1,\"16\":9,\"22\":10,\"200\":1}}],[\"acme申请\",{\"1\":{\"25\":1}}],[\"acme\",{\"0\":{\"12\":1},\"1\":{\"12\":1,\"13\":1,\"14\":1,\"17\":1,\"20\":3,\"21\":5}}],[\"actually\",{\"1\":{\"185\":1}}],[\"actual\",{\"1\":{\"159\":1}}],[\"act\",{\"1\":{\"9\":5}}],[\"alone\",{\"1\":{\"159\":1}}],[\"alt\",{\"1\":{\"98\":1}}],[\"alias\",{\"1\":{\"16\":1,\"22\":2}}],[\"aliyun\",{\"1\":{\"8\":12}}],[\"allocate\",{\"1\":{\"115\":1}}],[\"allowmixedcontent\",{\"1\":{\"86\":1}}],[\"all\",{\"1\":{\"8\":1,\"168\":1,\"184\":1}}],[\"i++\",{\"1\":{\"129\":8,\"144\":2,\"160\":1}}],[\"if\",{\"0\":{\"175\":1},\"1\":{\"90\":1,\"111\":3,\"115\":3,\"118\":5,\"119\":1,\"120\":1,\"121\":5,\"122\":2,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":16,\"128\":8,\"135\":1,\"137\":1,\"138\":1,\"139\":3,\"140\":3,\"141\":6,\"142\":2,\"143\":24,\"144\":2,\"153\":7,\"156\":3,\"159\":10,\"160\":4,\"161\":1,\"165\":3,\"166\":1,\"168\":1,\"169\":5,\"170\":3,\"173\":1,\"174\":1,\"175\":8,\"176\":2,\"177\":2,\"178\":2,\"184\":2,\"185\":3,\"186\":9,\"187\":2,\"188\":2,\"189\":2,\"190\":1,\"191\":1,\"192\":3,\"193\":3,\"194\":1,\"195\":2,\"196\":4,\"197\":2,\"198\":3,\"200\":3,\"201\":1}}],[\"i\",{\"1\":{\"90\":2,\"92\":1,\"111\":4,\"115\":2,\"122\":2,\"123\":1,\"129\":1,\"144\":4,\"159\":1,\"160\":3}}],[\"it\",{\"1\":{\"90\":4,\"91\":5,\"92\":20,\"138\":1,\"141\":1,\"159\":1,\"186\":1}}],[\"immediate\",{\"1\":{\"118\":1}}],[\"imm\",{\"1\":{\"117\":1,\"118\":3,\"129\":2,\"184\":3,\"185\":1,\"186\":4,\"189\":1,\"190\":1,\"191\":1,\"192\":2,\"193\":1,\"195\":2,\"198\":2,\"199\":3,\"200\":1}}],[\"img\",{\"1\":{\"91\":1}}],[\"import\",{\"1\":{\"90\":1,\"91\":1,\"92\":5}}],[\"images\",{\"1\":{\"31\":1}}],[\"idmain\",{\"1\":{\"144\":2}}],[\"idsize\",{\"1\":{\"139\":2,\"168\":1}}],[\"identifierenum\",{\"1\":{\"139\":1}}],[\"identifier\",{\"1\":{\"139\":5,\"159\":3,\"160\":1,\"166\":1,\"170\":1}}],[\"id\",{\"1\":{\"89\":1,\"93\":1,\"135\":1,\"139\":15,\"144\":6,\"156\":8,\"159\":17,\"160\":5,\"165\":5,\"166\":2,\"168\":11,\"169\":14,\"170\":12,\"186\":18,\"194\":1}}],[\"is\",{\"1\":{\"31\":1,\"43\":1,\"111\":1,\"121\":2,\"141\":2,\"185\":1,\"186\":3,\"198\":2}}],[\"issue\",{\"1\":{\"20\":2}}],[\"isn\",{\"0\":{\"7\":1}}],[\"ionic打包后的相对路径不正确\",{\"1\":{\"87\":1}}],[\"ionic\",{\"1\":{\"85\":1,\"86\":4}}],[\"io\",{\"1\":{\"8\":2}}],[\"index\",{\"1\":{\"169\":5,\"170\":3,\"186\":1}}],[\"indent\",{\"1\":{\"44\":1}}],[\"initializer\",{\"1\":{\"160\":1}}],[\"invalid\",{\"1\":{\"159\":1,\"170\":1}}],[\"information\",{\"1\":{\"159\":1}}],[\"increment\",{\"1\":{\"193\":1}}],[\"inc\",{\"1\":{\"135\":1,\"143\":1,\"187\":2,\"188\":2,\"189\":1,\"190\":1,\"191\":1,\"192\":2,\"193\":3,\"194\":1,\"199\":3}}],[\"include\",{\"1\":{\"16\":2,\"111\":4,\"138\":1,\"153\":2}}],[\"inject\",{\"1\":{\"102\":2}}],[\"into\",{\"1\":{\"141\":1}}],[\"integer\",{\"1\":{\"118\":2}}],[\"intel\",{\"1\":{\"118\":1}}],[\"interpreter\",{\"1\":{\"106\":1,\"109\":1,\"111\":1,\"113\":1,\"130\":1,\"131\":1,\"145\":1,\"147\":1,\"155\":1,\"162\":1,\"164\":1,\"171\":1,\"173\":1,\"179\":1,\"201\":1,\"203\":1}}],[\"int\",{\"1\":{\"38\":2,\"39\":11,\"111\":6,\"115\":3,\"116\":3,\"118\":3,\"120\":1,\"121\":2,\"122\":9,\"123\":1,\"125\":2,\"126\":1,\"128\":2,\"129\":3,\"135\":1,\"136\":1,\"139\":13,\"141\":1,\"144\":4,\"153\":20,\"159\":14,\"160\":2,\"161\":1,\"166\":1,\"167\":4,\"169\":7,\"170\":5,\"175\":2,\"176\":2,\"184\":4,\"185\":8,\"186\":1,\"187\":2,\"190\":1,\"191\":1,\"192\":2,\"193\":1,\"194\":1,\"196\":2,\"197\":4,\"198\":3,\"199\":3,\"200\":1,\"201\":5}}],[\"instruction\",{\"1\":{\"128\":1}}],[\"instructionsenum\",{\"1\":{\"117\":1}}],[\"install\",{\"1\":{\"21\":1}}],[\"insert\",{\"1\":{\"44\":1}}],[\"inspect\",{\"1\":{\"32\":1}}],[\"in\",{\"0\":{\"7\":1,\"28\":1},\"1\":{\"7\":2,\"32\":1,\"90\":4,\"92\":3,\"118\":4,\"135\":1,\"186\":2,\"195\":1,\"196\":1}}],[\"5501\",{\"1\":{\"181\":1}}],[\"55718\",{\"1\":{\"97\":1}}],[\"5版本开始引入了新的关键字\",{\"1\":{\"92\":1}}],[\"5\",{\"0\":{\"7\":1},\"1\":{\"7\":1,\"103\":1,\"109\":1,\"113\":2,\"118\":1,\"122\":2,\"128\":1,\"131\":3,\"132\":2,\"147\":2,\"155\":2,\"164\":1,\"173\":1,\"179\":1,\"181\":4,\"182\":7,\"203\":2}}],[\"tk\",{\"1\":{\"153\":4,\"161\":3}}],[\"tutor\",{\"1\":{\"129\":2,\"201\":5}}],[\"tmp\",{\"1\":{\"118\":1,\"128\":7,\"159\":2,\"186\":4,\"187\":4,\"193\":2,\"195\":2,\"198\":1,\"199\":1,\"200\":3,\"201\":3}}],[\"typora\",{\"1\":{\"102\":8}}],[\"typora激活教程\",{\"0\":{\"102\":1}}],[\"typedef\",{\"1\":{\"40\":1}}],[\"type\",{\"1\":{\"16\":1,\"139\":4,\"144\":2,\"156\":4,\"159\":16,\"160\":1,\"165\":4,\"168\":2,\"169\":11,\"170\":8,\"184\":2,\"185\":7,\"186\":7,\"187\":4,\"188\":5,\"189\":2,\"190\":1,\"191\":1,\"192\":2,\"193\":2,\"195\":3,\"197\":2,\"198\":4,\"199\":5,\"200\":3}}],[\"types\",{\"1\":{\"16\":1,\"144\":1,\"159\":1}}],[\"tail\",{\"1\":{\"153\":8}}],[\"tail><term\",{\"1\":{\"152\":1}}],[\"tail><expr\",{\"1\":{\"152\":1}}],[\"tail>\",{\"1\":{\"152\":6}}],[\"target=change\",{\"1\":{\"90\":2,\"92\":4}}],[\"table\",{\"1\":{\"109\":1,\"113\":1,\"131\":1,\"139\":2,\"144\":2,\"147\":1,\"155\":1,\"164\":1,\"173\":1,\"181\":1,\"203\":1}}],[\"tab\",{\"1\":{\"44\":1}}],[\"treated\",{\"1\":{\"159\":1}}],[\"track\",{\"1\":{\"144\":1}}],[\"trailing\",{\"1\":{\"44\":1}}],[\"trim\",{\"1\":{\"44\":1}}],[\"true\",{\"1\":{\"44\":3,\"86\":2,\"175\":1}}],[\"try\",{\"1\":{\"16\":3,\"22\":5,\"90\":1}}],[\"that\",{\"1\":{\"159\":1}}],[\"three\",{\"1\":{\"140\":1}}],[\"thread\",{\"1\":{\"90\":2,\"92\":4}}],[\"threads\",{\"1\":{\"90\":3,\"92\":3}}],[\"threading\",{\"1\":{\"90\":4,\"92\":5}}],[\"this\",{\"1\":{\"43\":1,\"159\":1,\"168\":1,\"186\":1}}],[\"there\",{\"1\":{\"159\":1,\"186\":1}}],[\"the\",{\"0\":{\"7\":1},\"1\":{\"7\":6,\"31\":1,\"43\":2,\"111\":1,\"119\":2,\"120\":1,\"141\":2,\"143\":1,\"144\":1,\"159\":6,\"166\":1,\"169\":1,\"170\":4,\"184\":3,\"186\":3,\"188\":1,\"189\":2,\"193\":1,\"195\":1,\"198\":2}}],[\"term\",{\"1\":{\"153\":8}}],[\"text\",{\"1\":{\"98\":1,\"111\":1,\"115\":11,\"129\":9,\"159\":1,\"166\":2,\"175\":2,\"176\":2,\"189\":3,\"193\":4,\"195\":3,\"196\":2,\"197\":2}}],[\"test\",{\"1\":{\"92\":2}}],[\"template<typename\",{\"1\":{\"40\":1}}],[\"tencent\",{\"1\":{\"8\":1}}],[\"title\",{\"0\":{\"113\":1}}],[\"time\",{\"1\":{\"92\":1}}],[\"timeout\",{\"1\":{\"16\":2}}],[\"tips\",{\"0\":{\"86\":1}}],[\"tieway59\",{\"1\":{\"29\":1}}],[\"tz=asia\",{\"1\":{\"17\":1}}],[\"tcp\",{\"1\":{\"16\":1}}],[\"t\",{\"0\":{\"7\":1},\"1\":{\"40\":5,\"90\":4,\"92\":4,\"141\":1,\"153\":3}}],[\"toc\",{\"1\":{\"147\":1}}],[\"tokens\",{\"1\":{\"135\":1}}],[\"tokenchar\",{\"1\":{\"111\":1}}],[\"token\",{\"1\":{\"108\":2,\"110\":1,\"111\":6,\"132\":3,\"133\":1,\"135\":1,\"136\":2,\"137\":2,\"138\":1,\"139\":16,\"140\":27,\"141\":14,\"142\":2,\"143\":45,\"144\":3,\"153\":20,\"158\":2,\"159\":12,\"160\":7,\"161\":2,\"166\":1,\"168\":1,\"169\":6,\"170\":9,\"175\":2,\"176\":1,\"177\":2,\"178\":3,\"184\":5,\"185\":4,\"186\":4,\"187\":6,\"188\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":4,\"193\":4,\"194\":2,\"195\":1,\"196\":2,\"197\":2,\"198\":2,\"199\":2,\"200\":1}}],[\"todo\",{\"1\":{\"24\":1,\"33\":1,\"43\":1,\"45\":1,\"94\":1,\"108\":1}}],[\"tools\",{\"0\":{\"7\":1},\"1\":{\"7\":1}}],[\"to\",{\"0\":{\"6\":1},\"1\":{\"32\":1,\"111\":1,\"118\":5,\"120\":1,\"144\":2,\"184\":1,\"186\":2,\"193\":1}}],[\"questions\",{\"0\":{\"6\":1}}],[\"qt\",{\"0\":{\"5\":1,\"6\":1,\"7\":2},\"1\":{\"7\":2}}],[\"网站\",{\"1\":{\"4\":1}}],[\"资源\",{\"0\":{\"4\":1}}],[\"项目地址\",{\"1\":{\"106\":1}}],[\"项目的初衷\",{\"0\":{\"106\":1}}],[\"项目结构\",{\"0\":{\"14\":1},\"1\":{\"12\":1}}],[\"项目\",{\"0\":{\"3\":1,\"12\":1},\"1\":{\"12\":1,\"14\":1}}],[\"致力于打造高效\",{\"1\":{\"1\":1}}],[\"擅长将前端与后端技术无缝结合\",{\"1\":{\"1\":1}}],[\"介绍页\",{\"0\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
