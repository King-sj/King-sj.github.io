import{_ as o,c as e,e as r,o as p}from"./app-Bi-vtw0j.js";const n={};function a(c,t){return p(),e("div",null,[...t[0]||(t[0]=[r("<p>functools.wraps 是 Python 中的一个装饰器，用于装饰另一个装饰器，使其保留被装饰函数的元数据，如函数名、文档字符串等。这在编写装饰器时非常有用，因为装饰器会改变被装饰函数的属性，使得调试和文档生成变得困难。</p><p>使用示例</p><p>以下是一个没有使用 functools.wraps 的装饰器示例：</p><p>def my_decorator(func): def wrapper(*args, **kwargs): &quot;&quot;&quot;decorator&quot;&quot;&quot; print(&#39;Calling decorated function...&#39;) return func(*args, **kwargs) return wrapper</p><p>@my_decorator def example(): &quot;&quot;&quot;Docstring&quot;&quot;&quot; print(&#39;Called example function&#39;)</p><p>print(example.<strong>name</strong>, example.<strong>doc</strong>) 输出结果为：</p><p>wrapper decorator 可以看到，函数名和文档字符串都被改变了。</p><p>现在，我们使用 functools.wraps 来修复这个问题：</p><p>import functools</p><p>def my_decorator(func): @functools.wraps(func) def wrapper(*args, **kwargs): &quot;&quot;&quot;decorator&quot;&quot;&quot; print(&#39;Calling decorated function...&#39;) return func(*args, **kwargs) return wrapper</p><p>@my_decorator def example(): &quot;&quot;&quot;Docstring&quot;&quot;&quot; print(&#39;Called example function&#39;)</p><p>print(example.<strong>name</strong>, example.<strong>doc</strong>) 输出结果为：</p><p>example Docstring 可以看到，函数名和文档字符串都被正确保留了。</p><p>重要性</p><p>使用 functools.wraps 可以确保装饰器不会改变被装饰函数的元数据，这对于调试、文档生成和代码可读性非常重要。它通过调用 functools.update_wrapper 函数来实现这一点，该函数会将被装饰函数的属性复制到装饰器函数上。</p><p>结论</p><p>functools.wraps 是编写装饰器时的一个重要工具，它可以帮助我们保留被装饰函数的元数据，从而提高代码的可读性和可维护性。在编写装饰器时，建议始终使用 functools.wraps 来装饰你的装饰器函数。</p>",17)])])}const u=o(n,[["render",a]]),l=JSON.parse(`{"path":"/tech/functools_wraps.html","title":"functools.wraps 使用详解","lang":"en-US","frontmatter":{"category":"functools","tag":["python","decorators"],"title":"functools.wraps 使用详解","description":"functools.wraps 是 Python 中的一个装饰器，用于装饰另一个装饰器，使其保留被装饰函数的元数据，如函数名、文档字符串等。这在编写装饰器时非常有用，因为装饰器会改变被装饰函数的属性，使得调试和文档生成变得困难。 使用示例 以下是一个没有使用 functools.wraps 的装饰器示例： def my_decorator(func):...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"functools.wraps 使用详解\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-31T15:07:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KSJ\\",\\"url\\":\\"https://github.com/King-sj\\"}]}"],["meta",{"property":"og:url","content":"https://github.com/King-sj/tech/functools_wraps.html"}],["meta",{"property":"og:site_name","content":"kblog"}],["meta",{"property":"og:title","content":"functools.wraps 使用详解"}],["meta",{"property":"og:description","content":"functools.wraps 是 Python 中的一个装饰器，用于装饰另一个装饰器，使其保留被装饰函数的元数据，如函数名、文档字符串等。这在编写装饰器时非常有用，因为装饰器会改变被装饰函数的属性，使得调试和文档生成变得困难。 使用示例 以下是一个没有使用 functools.wraps 的装饰器示例： def my_decorator(func):..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-31T15:07:46.000Z"}],["meta",{"property":"article:tag","content":"decorators"}],["meta",{"property":"article:tag","content":"python"}],["meta",{"property":"article:modified_time","content":"2025-12-31T15:07:46.000Z"}]]},"git":{"createdTime":1767193666000,"updatedTime":1767193666000,"contributors":[{"name":"king-sj","username":"king-sj","email":"2175616761@qq.com","commits":1,"url":"https://github.com/king-sj"}]},"readingTime":{"minutes":1.33,"words":398},"filePathRelative":"tech/functools_wraps.md","excerpt":"<p>functools.wraps 是 Python 中的一个装饰器，用于装饰另一个装饰器，使其保留被装饰函数的元数据，如函数名、文档字符串等。这在编写装饰器时非常有用，因为装饰器会改变被装饰函数的属性，使得调试和文档生成变得困难。</p>\\n<p>使用示例</p>\\n<p>以下是一个没有使用 functools.wraps 的装饰器示例：</p>\\n<p>def my_decorator(func):\\ndef wrapper(*args, **kwargs):\\n\\"\\"\\"decorator\\"\\"\\"\\nprint('Calling decorated function...')\\nreturn func(*args, **kwargs)\\nreturn wrapper</p>","autoDesc":true}`);export{u as comp,l as data};
