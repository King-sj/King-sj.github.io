import{_ as e,o as a,c as s,a as o,b as n,e as t,f as p}from"./app-ByUhljzD.js";const c={},l=n("h1",{id:"「泛型与-oi」modint",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#「泛型与-oi」modint"},[n("span",null,"「泛型与 OI」modint")])],-1),i=n("p",null,"在 OI 中，有大量的题目要求对一些数字取模，这便是本文写作的背景。",-1),r=n("h2",{id:"背景介绍",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#背景介绍"},[n("span",null,"背景介绍")])],-1),u=n("p",null,"这些题目要么是因为答案太大，不方便输出结果，例如许多计数 dp；要么是因为答案是浮点数，出题人不愿意写一个确定精度的 Special Judge，例如很多期望概率题；要么是因为这道题目直接考察了模的性质和运用，比如大量的 998244353 类的多项式题目。",-1),d=n("h2",{id:"过去的做法",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#过去的做法"},[n("span",null,"过去的做法")])],-1),k={class:"MathJax",jax:"SVG",style:{position:"relative"}},Q={style:{"vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"21.387ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 9452.9 1000","aria-hidden":"true"},T=p('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><path data-c="1D68A" d="M126 306Q105 306 90 321T74 359Q74 439 211 439Q268 439 276 438Q343 426 383 390T430 306Q431 301 431 190V81Q446 79 465 78T492 76T509 72T521 60T524 38Q524 11 506 3Q502 1 466 1Q426 1 406 5T379 14T355 36L345 30Q284 -6 205 -6Q135 -6 92 39T48 141Q48 182 79 212T158 256T252 278T342 285H347V290Q347 315 325 335T267 362Q258 363 224 363Q189 363 185 362H179L178 358Q178 353 178 352T176 345T174 337T170 330T165 322T158 316T150 311T139 308T126 306ZM132 140Q132 115 157 93T224 70Q269 70 302 87T344 133Q346 139 347 175V211H339Q256 209 194 190T132 140Z"></path><path data-c="1D697" d="M89 431Q94 431 105 431T122 432Q173 432 173 399Q173 394 175 394Q176 394 190 404T233 425T298 436Q343 436 371 423Q411 402 423 365T436 265Q436 257 436 239T435 211V198V76H498Q512 67 516 60T520 38Q520 9 498 1H308Q286 9 286 32V38V45Q286 65 303 73Q309 76 329 76H351V188Q351 204 351 230T352 266Q352 321 341 341T288 361Q253 361 222 341T176 274L174 264L173 170V76H236Q250 67 254 60T258 38Q258 9 236 1H27Q4 8 4 38Q4 53 8 60T27 76H89V355H58L27 356Q4 363 4 393Q4 408 8 415T27 431H89Z" transform="translate(525,0)"></path><path data-c="1D69C" d="M72 317Q72 361 108 396T229 439Q231 439 245 439T268 440Q303 439 324 435T353 427T363 423L372 432Q380 440 397 440Q430 440 430 395Q430 390 430 380T429 366V335Q429 311 422 302T387 293Q364 293 355 300T346 316T343 336T325 353Q306 364 257 364Q209 364 178 351T147 317Q147 284 231 272Q327 256 357 247Q458 210 458 129V121Q458 74 413 34T271 -6Q246 -6 224 -3T189 5T165 14T150 22T144 26Q142 23 139 18T135 11T132 6T128 1T124 -2T119 -4T113 -5T104 -6Q84 -6 78 6T71 43Q71 48 71 60T72 79Q72 132 73 141T81 157Q90 166 115 166Q135 166 142 162T157 140Q168 108 191 90T260 70Q297 70 323 76T361 91T379 110T384 129Q384 157 346 171T247 195T165 212Q119 228 96 256T72 317Z" transform="translate(1050,0)"></path></g><g data-mml-node="mo" transform="translate(1852.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(2908.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(3297.6,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(4091.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(5092,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(5804.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(6804.4,0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g><g data-mml-node="mo" transform="translate(7269.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(7880.7,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(8880.9,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g>',1),m=[T],v=n("mjx-assistive-mml",{unselectable:"on",display:"inline"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("mtext",{mathvariant:"monospace"},"ans"),n("mo",null,"="),n("mo",{stretchy:"false"},"("),n("mi",null,"x"),n("mo",null,"+"),n("mi",null,"y"),n("mo",null,"+"),n("mi",null,"z"),n("mo",{stretchy:"false"},")"),n("mo",null,"×"),n("mi",null,"u")])],-1),h=p(`<h3 id="第一种-直接取模" tabindex="-1"><a class="header-anchor" href="#第一种-直接取模"><span>第一种 直接取模</span></a></h3><p>这种方法是直接取模，简单直接，清晰明了。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">int</span> p<span class="token operator">=</span><span class="token number">998244353</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">1ll</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token operator">%</span>p<span class="token operator">+</span>z<span class="token punctuation">)</span><span class="token operator">%</span>p<span class="token punctuation">)</span><span class="token operator">*</span>u<span class="token operator">%</span>p<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这种方法有着严重的缺陷，一是容易忘记大括号，二是容易中间运算时搞错运算顺序、忘记取模，三是式子太长、括号太多、不易检验。</p><p>因此，不推荐运用这种方法。</p><h3 id="第二种-函数取模" tabindex="-1"><a class="header-anchor" href="#第二种-函数取模"><span>第二种 函数取模</span></a></h3><p>这种方法有效地解决了直接取模的忘记取模的漏洞。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">int</span> p<span class="token operator">=</span><span class="token number">998244353</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token operator">&gt;=</span>p<span class="token operator">?</span>a<span class="token operator">+</span>b<span class="token operator">-</span>p<span class="token operator">:</span>a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> a<span class="token operator">&lt;</span>b<span class="token operator">?</span>a<span class="token operator">-</span>b<span class="token operator">+</span>p<span class="token operator">:</span>a<span class="token operator">-</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token number">1ll</span><span class="token operator">*</span>a<span class="token operator">*</span>b<span class="token operator">%</span>p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token function">mul</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，这种写法的式子依旧太长，不易检验，并且如果编译器没有任何优化（现在不存在这种情况了）的话，大量的函数调用将会耗费不少的时间。并且如果要对多个模数取模，则需要写多个函数，显得代码冗长。</p><h2 id="泛型编程" tabindex="-1"><a class="header-anchor" href="#泛型编程"><span>泛型编程</span></a></h2><p>考虑到函数取模的优点，我们不妨通过类的运算符重载来进一步优化 <code>add</code> 等函数。</p><p>同时为了解决多个模数的问题，我们考虑泛型编程，将模数直接包含在类型中。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">const</span> T p<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">modint</span><span class="token punctuation">{</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		T v<span class="token punctuation">;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">modint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
		<span class="token function">modint</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;=</span>x<span class="token operator">&amp;&amp;</span>x<span class="token operator">&lt;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token operator">=</span>x<span class="token punctuation">;</span><span class="token punctuation">}</span>
		modint <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> modint<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span> v<span class="token operator">+</span>a<span class="token punctuation">.</span>v<span class="token operator">&gt;=</span>p<span class="token operator">?</span>v<span class="token operator">+</span>a<span class="token punctuation">.</span>v<span class="token operator">-</span>p<span class="token operator">:</span>v<span class="token operator">+</span>a<span class="token punctuation">.</span>v<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		modint <span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">const</span> modint<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span> v<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>v<span class="token operator">?</span>v<span class="token operator">-</span>a<span class="token punctuation">.</span>v<span class="token operator">+</span>p<span class="token operator">:</span>v<span class="token operator">-</span>a<span class="token punctuation">.</span>v<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		modint <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> modint<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token number">1ll</span><span class="token operator">*</span>v<span class="token operator">*</span>a<span class="token punctuation">.</span>v<span class="token operator">%</span>p<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		T <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span> v<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

modint<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">998244353</span><span class="token operator">&gt;</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">u</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
modint<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">998244353</span><span class="token operator">&gt;</span> ans<span class="token operator">=</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token operator">+</span>z<span class="token punctuation">)</span><span class="token operator">*</span>u<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样使用的时候，一方面减少了心智负担，不用操心运算时忘记取模；另一方面采取了常数更小的加减法操作，运算更快。</p><p>唯一的缺点就是类型名难写，但是模数个数少的时候可以缩写，即写成：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">typedef</span> modint<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">998244353</span><span class="token operator">&gt;</span> modInt1<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样就解决了类型名长的缺点。</p>`,17);function b(g,y){return a(),s("div",null,[l,i,r,u,o(" more "),d,n("p",null,[t("在这种要求之下，取模运算就成为了编程中不可缺少的一部分。下面以式子 "),n("mjx-container",k,[(a(),s("svg",Q,m)),v]),t(" 为例介绍几种写法。")]),h])}const f=e(c,[["render",b],["__file","modint.html.vue"]]),H=JSON.parse('{"path":"/tech/modint.html","title":"「泛型与 OI」modint","lang":"zh-CN","frontmatter":{"lang":"zh-CN","date":"2023-08-02T00:00:00.000Z","category":["OI"],"tag":["MODInt"],"description":"在 OI 中，有大量的题目要求对一些数字取模，这便是本文写作的背景。 背景介绍 这些题目要么是因为答案太大，不方便输出结果，例如许多计数 dp；要么是因为答案是浮点数，出题人不愿意写一个确定精度的 Special Judge，例如很多期望概率题；要么是因为这道题目直接考察了模的性质和运用，比如大量的 998244353 类的多项式题目。","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://github.com/King-sj/tech/modint.html"}],["meta",{"property":"og:site_name","content":"blog"}],["meta",{"property":"og:title","content":"「泛型与 OI」modint"}],["meta",{"property":"og:description","content":"在 OI 中，有大量的题目要求对一些数字取模，这便是本文写作的背景。 背景介绍 这些题目要么是因为答案太大，不方便输出结果，例如许多计数 dp；要么是因为答案是浮点数，出题人不愿意写一个确定精度的 Special Judge，例如很多期望概率题；要么是因为这道题目直接考察了模的性质和运用，比如大量的 998244353 类的多项式题目。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"KSJ"}],["meta",{"property":"article:tag","content":"MODInt"}],["meta",{"property":"article:published_time","content":"2023-08-02T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"「泛型与 OI」modint\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-02T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KSJ\\",\\"url\\":\\"https://github.com/King-sj\\"}]}"]]},"headers":[{"level":2,"title":"背景介绍","slug":"背景介绍","link":"#背景介绍","children":[]},{"level":2,"title":"过去的做法","slug":"过去的做法","link":"#过去的做法","children":[{"level":3,"title":"第一种 直接取模","slug":"第一种-直接取模","link":"#第一种-直接取模","children":[]},{"level":3,"title":"第二种 函数取模","slug":"第二种-函数取模","link":"#第二种-函数取模","children":[]}]},{"level":2,"title":"泛型编程","slug":"泛型编程","link":"#泛型编程","children":[]}],"readingTime":{"minutes":2.4,"words":721},"filePathRelative":"tech/modint.md","localizedDate":"2023年8月2日","excerpt":"\\n<p>在 OI 中，有大量的题目要求对一些数字取模，这便是本文写作的背景。</p>\\n<h2>背景介绍</h2>\\n<p>这些题目要么是因为答案太大，不方便输出结果，例如许多计数 dp；要么是因为答案是浮点数，出题人不愿意写一个确定精度的 Special Judge，例如很多期望概率题；要么是因为这道题目直接考察了模的性质和运用，比如大量的 998244353 类的多项式题目。</p>\\n","autoDesc":true}');export{f as comp,H as data};
