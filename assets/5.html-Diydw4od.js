import{_ as p,r as t,o as r,c as i,b as a,e as s,d as e,f as l}from"./app-ByUhljzD.js";const c={},o=a("h1",{id:"转载声明",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#转载声明"},[a("span",null,"转载声明")])],-1),b={href:"https://lotabout.me/2016/write-a-C-interpreter-5/",target:"_blank",rel:"noopener noreferrer"},d=l('<h1 id="原文内容" tabindex="-1"><a class="header-anchor" href="#原文内容"><span>原文内容</span></a></h1><h1 id="手把手教你构建-c-语言编译器-5-变量定义" tabindex="-1"><a class="header-anchor" href="#手把手教你构建-c-语言编译器-5-变量定义"><span>手把手教你构建 C 语言编译器（5）- 变量定义</span></a></h1><p>Table of Contents</p><ol><li><a href="about:blank#ebnf-%E8%A1%A8%E7%A4%BA">1. EBNF 表示</a></li><li><a href="about:blank#%E8%A7%A3%E6%9E%90%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89">2. 解析变量的定义</a><ol><li><a href="about:blank#program">2.1. program()</a></li><li><a href="about:blank#global-declaration">2.2. global_declaration()</a></li><li><a href="about:blank#enum-declaration">2.3. enum_declaration()</a></li><li><a href="about:blank#%E5%85%B6%E5%AE%83">2.4. 其它</a></li></ol></li><li><a href="about:blank#%E4%BB%A3%E7%A0%81">3. 代码</a></li><li><a href="about:blank#%E5%B0%8F%E7%BB%93">4. 小结</a></li></ol><p>本章中我们用 EBNF 来大致描述我们实现的 C 语言的文法，并实现其中解析变量定义部分。</p><p>由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定义、函数定义、表达式。</p><p>手把手教你构建 C 语言编译器系列共有10个部分：</p>',7),m={href:"http://lotabout.me/2015/write-a-C-interpreter-0/",target:"_blank",rel:"noopener noreferrer"},h={href:"http://lotabout.me/2015/write-a-C-interpreter-1/",target:"_blank",rel:"noopener noreferrer"},u={href:"http://lotabout.me/2015/write-a-C-interpreter-2/",target:"_blank",rel:"noopener noreferrer"},_={href:"http://lotabout.me/2015/write-a-C-interpreter-3/",target:"_blank",rel:"noopener noreferrer"},f={href:"http://lotabout.me/2016/write-a-C-interpreter-4/",target:"_blank",rel:"noopener noreferrer"},g={href:"http://lotabout.me/2016/write-a-C-interpreter-5/",target:"_blank",rel:"noopener noreferrer"},y={href:"http://lotabout.me/2016/write-a-C-interpreter-6/",target:"_blank",rel:"noopener noreferrer"},k={href:"http://lotabout.me/2016/write-a-C-interpreter-7/",target:"_blank",rel:"noopener noreferrer"},E={href:"http://lotabout.me/2016/write-a-C-interpreter-8/",target:"_blank",rel:"noopener noreferrer"},C={href:"http://lotabout.me/2016/write-a-C-interpreter-9/",target:"_blank",rel:"noopener noreferrer"},w=l('<h2 id="ebnf-表示" tabindex="-1"><a class="header-anchor" href="#ebnf-表示"><span><a href="about:blank#ebnf-%E8%A1%A8%E7%A4%BA"></a>EBNF 表示</span></a></h2><p>EBNF 是对前一章提到的 BNF 的扩展，它的语法更容易理解，实现起来也更直观。但真正看起来还是很烦，如果不想看可以跳过。</p><table><tbody><tr><td class="code"><pre><span class="line">program ::= {global_declaration}+</span><br><span class="line"></span><br><span class="line">global_declaration ::= enum_decl | variable_decl | function_decl</span><br><span class="line"></span><br><span class="line">enum_decl ::= &#39;enum&#39; [id] &#39;{&#39; id [&#39;=&#39; &#39;num&#39;] {&#39;,&#39; id [&#39;=&#39; &#39;num&#39;] &#39;}&#39;</span><br><span class="line"></span><br><span class="line">variable_decl ::= type {&#39;*&#39;} id { &#39;,&#39; {&#39;*&#39;} id } &#39;;&#39;</span><br><span class="line"></span><br><span class="line">function_decl ::= type {&#39;*&#39;} id &#39;(&#39; parameter_decl &#39;)&#39; &#39;{&#39; body_decl &#39;}&#39;</span><br><span class="line"></span><br><span class="line">parameter_decl ::= type {&#39;*&#39;} id {&#39;,&#39; type {&#39;*&#39;} id}</span><br><span class="line"></span><br><span class="line">body_decl ::= {variable_decl}, {statement}</span><br><span class="line"></span><br><span class="line">statement ::= non_empty_statement | empty_statement</span><br><span class="line"></span><br><span class="line">non_empty_statement ::= if_statement | while_statement | &#39;{&#39; statement &#39;}&#39;</span><br><span class="line">                     | &#39;return&#39; expression | expression &#39;;&#39;</span><br><span class="line"></span><br><span class="line">if_statement ::= &#39;if&#39; &#39;(&#39; expression &#39;)&#39; statement [&#39;else&#39; non_empty_statement]</span><br><span class="line"></span><br><span class="line">while_statement ::= &#39;while&#39; &#39;(&#39; expression &#39;)&#39; non_empty_statement</span><br></pre></td></tr></tbody></table><p>其中 <code>expression</code> 相关的内容我们放到后面解释，主要原因是我们的语言不支持跨函数递归，而为了实现自举，实际上我们也不能使用递归（亏我们说了一章的递归下降）。</p><p>P.S. 我是先写程序再总结上面的文法，所以实际上它们间的对应关系并不是特别明显。</p><h2 id="解析变量的定义" tabindex="-1"><a class="header-anchor" href="#解析变量的定义"><span><a href="about:blank#%E8%A7%A3%E6%9E%90%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"></a>解析变量的定义</span></a></h2><p>本章要讲解的就是上节文法中的 <code>enum_decl</code> 和 <code>variable_decl</code> 部分。</p><h3 id="program" tabindex="-1"><a class="header-anchor" href="#program"><span><a href="about:blank#program"></a>program()</span></a></h3><p>首先是之前定义过的 <code>program</code> 函数，将它改成：</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">program</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// get next token</span></span><br><span class="line">    next();</span><br><span class="line">    <span class="keyword">while</span> (token &gt; <span class="number">0</span>) {</span><br><span class="line">        global_declaration();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table><p>我知道 <code>global_declaration</code> 函数还没有出现过，但没有关系，采用自顶向下的编写方法就是要不断地实现我们需要的内容。下面是 <code>global_declaration</code> 函数的内容：</p><h3 id="global-declaration" tabindex="-1"><a class="header-anchor" href="#global-declaration"><span><a href="about:blank#global-declaration"></a>global_declaration()</span></a></h3><p>即全局的定义语句，包括变量定义，类型定义（只支持枚举）及函数定义。代码如下：</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> basetype;    <span class="comment">// the type of a declaration, make it global for convenience</span></span><br><span class="line"><span class="type">int</span> expr_type;   <span class="comment">// the type of an expression</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">global_declaration</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// global_declaration ::= enum_decl | variable_decl | function_decl</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// enum_decl ::= &#39;enum&#39; [id] &#39;{&#39; id [&#39;=&#39; &#39;num&#39;] {&#39;,&#39; id [&#39;=&#39; &#39;num&#39;} &#39;}&#39;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// variable_decl ::= type {&#39;*&#39;} id { &#39;,&#39; {&#39;*&#39;} id } &#39;;&#39;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// function_decl ::= type {&#39;*&#39;} id &#39;(&#39; parameter_decl &#39;)&#39; &#39;{&#39; body_decl &#39;}&#39;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// tmp, actual type for variable</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// tmp</span></span><br><span class="line"></span><br><span class="line">    basetype = INT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse enum, this should be treated alone.</span></span><br><span class="line">    <span class="keyword">if</span> (token == Enum) {</span><br><span class="line">        <span class="comment">// enum [id] { a = 10, b = 20, ... }</span></span><br><span class="line">        match(Enum);</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="string">&#39;{&#39;</span>) {</span><br><span class="line">            match(Id); <span class="comment">// skip the [id] part</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="string">&#39;{&#39;</span>) {</span><br><span class="line">            <span class="comment">// parse the assign part</span></span><br><span class="line">            match(<span class="string">&#39;{&#39;</span>);</span><br><span class="line">            enum_declaration();</span><br><span class="line">            match(<span class="string">&#39;}&#39;</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        match(<span class="string">&#39;;&#39;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse type information</span></span><br><span class="line">    <span class="keyword">if</span> (token == Int) {</span><br><span class="line">        match(Int);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (token == Char) {</span><br><span class="line">        match(Char);</span><br><span class="line">        basetype = CHAR;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse the comma seperated variable declaration.</span></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="string">&#39;;&#39;</span> &amp;&amp; token != <span class="string">&#39;}&#39;</span>) {</span><br><span class="line">        type = basetype;</span><br><span class="line">        <span class="comment">// parse pointer type, note that there may exist `int ****x;`</span></span><br><span class="line">        <span class="keyword">while</span> (token == Mul) {</span><br><span class="line">            match(Mul);</span><br><span class="line">            type = type + PTR;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token != Id) {</span><br><span class="line">            <span class="comment">// invalid declaration</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: bad global declaration\\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (current_id[Class]) {</span><br><span class="line">            <span class="comment">// identifier exists</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: duplicate global declaration\\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        match(Id);</span><br><span class="line">        current_id[Type] = type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="string">&#39;(&#39;</span>) {</span><br><span class="line">            current_id[Class] = Fun;</span><br><span class="line">            current_id[Value] = (<span class="type">int</span>)(text + <span class="number">1</span>); <span class="comment">// the memory address of function</span></span><br><span class="line">            function_declaration();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// variable declaration</span></span><br><span class="line">            current_id[Class] = Glo; <span class="comment">// global variable</span></span><br><span class="line">            current_id[Value] = (<span class="type">int</span>)data; <span class="comment">// assign memory address</span></span><br><span class="line">            data = data + <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="string">&#39;,&#39;</span>) {</span><br><span class="line">            match(<span class="string">&#39;,&#39;</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    next();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table><p>看了上面的代码，能大概理解吗？这里我们讲解其中的一些细节。</p><p><strong>向前看标记</strong> ：其中的 <code>if (token == xxx)</code> 语句就是用来向前查看标记以确定使用哪一个产生式，例如只要遇到 <code>enum</code> 我们就知道是需要解析枚举类型。而如果只解析到类型，如 <code>int identifier</code> 时我们并不能确定 <code>identifier</code> 是一个普通的变量还是一个函数，所以还需要继续查看后续的标记，如果遇到 <code>(</code> 则可以断定是函数了，反之则是变量。</p><p><strong>变量类型的表示</strong> ：我们的编译器支持指针类型，那意味着也支持指针的指针，如 <code>int **data;</code>。那么我们如何表示指针类型呢？前文中我们定义了支持的类型：</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// types of variable/function</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> {</span> CHAR, INT, PTR };</span><br></pre></td></tr></tbody></table><p>所以一个类型首先有基本类型，如 <code>CHAR</code> 或 <code>INT</code>，当它是一个指向基本类型的指针时，如 <code>int *data</code>，我们就将它的类型加上 <code>PTR</code> 即代码中的：<code>type = type + PTR;</code>。同理，如果是指针的指针，则再加上 <code>PTR</code>。</p><h3 id="enum-declaration" tabindex="-1"><a class="header-anchor" href="#enum-declaration"><span><a href="about:blank#enum-declaration"></a>enum_declaration()</span></a></h3><p>用于解析枚举类型的定义。主要的逻辑用于解析用逗号（<code>,</code>）分隔的变量，值得注意的是在编译器中如何保存枚举变量的信息。</p><p>即我们将该变量的类别设置成了 <code>Num</code>，这样它就成了全局的常量了，而注意到上节中，正常的全局变量的类别则是 <code>Glo</code>，类别信息在后面章节中解析 <code>expression</code> 会使用到。</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enum_declaration</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// parse enum [id] { a = 1, b = 3, ...}</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (token != <span class="string">&#39;}&#39;</span>) {</span><br><span class="line">        <span class="keyword">if</span> (token != Id) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: bad enum identifier %d\\n&quot;</span>, line, token);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        next();</span><br><span class="line">        <span class="keyword">if</span> (token == Assign) {</span><br><span class="line">            <span class="comment">// like {a=10}</span></span><br><span class="line">            next();</span><br><span class="line">            <span class="keyword">if</span> (token != Num) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d: bad enum initializer\\n&quot;</span>, line);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            }</span><br><span class="line">            i = token_val;</span><br><span class="line">            next();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        current_id[Class] = Num;</span><br><span class="line">        current_id[Type] = INT;</span><br><span class="line">        current_id[Value] = i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="string">&#39;,&#39;</span>) {</span><br><span class="line">            next();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table><h3 id="其它" tabindex="-1"><a class="header-anchor" href="#其它"><span><a href="about:blank#%E5%85%B6%E5%AE%83"></a>其它</span></a></h3><p>其中的 <code>function_declaration</code> 函数我们将放到下一章中讲解。<code>match</code> 函数是一个辅助函数：</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">match</span><span class="params">(<span class="type">int</span> tk)</span> {</span><br><span class="line">    <span class="keyword">if</span> (token == tk) {</span><br><span class="line">        next();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: expected token: %d\\n&quot;</span>, line, tk);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table><p>它将 <code>next</code> 函数包装起来，如果不是预期的标记则报错并退出。</p><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码"><span><a href="about:blank#%E4%BB%A3%E7%A0%81"></a>代码</span></a></h2>',28),x={href:"https://github.com/lotabout/write-a-C-interpreter/tree/step-3",target:"_blank",rel:"noopener noreferrer"},A=l('<table><tbody><tr><td class="code"><pre><span class="line">git clone -b step-3 https://github.com/lotabout/write-a-C-interpreter</span><br></pre></td></tr></tbody></table><p>本章的代码还无法正常运行，因为还有许多功能没有实现，但如果有兴趣的话，可以自己先试着去实现它。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span><a href="about:blank#%E5%B0%8F%E7%BB%93"></a>小结</span></a></h2><p>本章的内容应该不难，除了开头的 EBNF 表达式可能相对不好理解一些，但如果你查看了 EBNF 的具体表示方法后就不难理解了。</p><p>剩下的内容就是按部就班地将 EBNF 的产生式转换成函数的过程，如果你理解了上一章中的内容，相信这部分也不难理解。</p><p>下一章中我们将介绍如何解析函数的定义，敬请期待。</p>',6);function B(v,N){const n=t("ExternalLinkIcon");return r(),i("div",null,[o,a("p",null,[s("本文转自 "),a("a",b,[s("https://lotabout.me/2016/write-a-C-interpreter-5/"),e(n)]),s("，如有侵权，请联系删除。")]),d,a("ol",null,[a("li",null,[a("a",m,[s("手把手教你构建 C 语言编译器（0）——前言"),e(n)])]),a("li",null,[a("a",h,[s("手把手教你构建 C 语言编译器（1）——设计"),e(n)])]),a("li",null,[a("a",u,[s("手把手教你构建 C 语言编译器（2）——虚拟机"),e(n)])]),a("li",null,[a("a",_,[s("手把手教你构建 C 语言编译器（3）——词法分析器"),e(n)])]),a("li",null,[a("a",f,[s("手把手教你构建 C 语言编译器（4）——递归下降"),e(n)])]),a("li",null,[a("a",g,[s("手把手教你构建 C 语言编译器（5）——变量定义"),e(n)])]),a("li",null,[a("a",y,[s("手把手教你构建 C 语言编译器（6）——函数定义"),e(n)])]),a("li",null,[a("a",k,[s("手把手教你构建 C 语言编译器（7）——语句"),e(n)])]),a("li",null,[a("a",E,[s("手把手教你构建 C 语言编译器（8）——表达式"),e(n)])]),a("li",null,[a("a",C,[s("手把手教你构建 C 语言编译器（9）——总结"),e(n)])])]),w,a("p",null,[s("本章的代码可以在 "),a("a",x,[s("Github"),e(n)]),s(" 上下载，也可以直接 clone")]),A])}const T=p(c,[["render",B],["__file","5.html.vue"]]),I=JSON.parse('{"path":"/tech/designASimpileCCompiler/5.html","title":"手把手教你构建 C 语言编译器（5）——变量定义","lang":"zh-CN","frontmatter":{"title":"手把手教你构建 C 语言编译器（5）——变量定义","category":["编译原理"],"tag":["c","编译器","解释器"],"description":"转载声明 本文转自 https://lotabout.me/2016/write-a-C-interpreter-5/，如有侵权，请联系删除。 原文内容 手把手教你构建 C 语言编译器（5）- 变量定义 Table of Contents 1. EBNF 表示 2. 解析变量的定义 2.1. program() 2.2. global_declarat...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://github.com/King-sj/tech/designASimpileCCompiler/5.html"}],["meta",{"property":"og:site_name","content":"blog"}],["meta",{"property":"og:title","content":"手把手教你构建 C 语言编译器（5）——变量定义"}],["meta",{"property":"og:description","content":"转载声明 本文转自 https://lotabout.me/2016/write-a-C-interpreter-5/，如有侵权，请联系删除。 原文内容 手把手教你构建 C 语言编译器（5）- 变量定义 Table of Contents 1. EBNF 表示 2. 解析变量的定义 2.1. program() 2.2. global_declarat..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"KSJ"}],["meta",{"property":"article:tag","content":"c"}],["meta",{"property":"article:tag","content":"编译器"}],["meta",{"property":"article:tag","content":"解释器"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"手把手教你构建 C 语言编译器（5）——变量定义\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KSJ\\",\\"url\\":\\"https://github.com/King-sj\\"}]}"]]},"headers":[{"level":2,"title":"EBNF 表示","slug":"ebnf-表示","link":"#ebnf-表示","children":[]},{"level":2,"title":"解析变量的定义","slug":"解析变量的定义","link":"#解析变量的定义","children":[{"level":3,"title":"program()","slug":"program","link":"#program","children":[]},{"level":3,"title":"global_declaration()","slug":"global-declaration","link":"#global-declaration","children":[]},{"level":3,"title":"enum_declaration()","slug":"enum-declaration","link":"#enum-declaration","children":[]},{"level":3,"title":"其它","slug":"其它","link":"#其它","children":[]}]},{"level":2,"title":"代码","slug":"代码","link":"#代码","children":[]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"readingTime":{"minutes":10.71,"words":3212},"filePathRelative":"tech/designASimpileCCompiler/5.md","excerpt":"\\n<p>本文转自 <a href=\\"https://lotabout.me/2016/write-a-C-interpreter-5/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://lotabout.me/2016/write-a-C-interpreter-5/</a>，如有侵权，请联系删除。</p>\\n<h1>原文内容</h1>\\n<h1>手把手教你构建 C 语言编译器（5）- 变量定义</h1>\\n<p>Table of Contents</p>\\n<ol>\\n<li><a href=\\"about:blank#ebnf-%E8%A1%A8%E7%A4%BA\\">1. EBNF 表示</a></li>\\n<li><a href=\\"about:blank#%E8%A7%A3%E6%9E%90%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89\\">2. 解析变量的定义</a>\\n<ol>\\n<li><a href=\\"about:blank#program\\">2.1. program()</a></li>\\n<li><a href=\\"about:blank#global-declaration\\">2.2. global_declaration()</a></li>\\n<li><a href=\\"about:blank#enum-declaration\\">2.3. enum_declaration()</a></li>\\n<li><a href=\\"about:blank#%E5%85%B6%E5%AE%83\\">2.4. 其它</a></li>\\n</ol>\\n</li>\\n<li><a href=\\"about:blank#%E4%BB%A3%E7%A0%81\\">3. 代码</a></li>\\n<li><a href=\\"about:blank#%E5%B0%8F%E7%BB%93\\">4. 小结</a></li>\\n</ol>","autoDesc":true}');export{T as comp,I as data};
