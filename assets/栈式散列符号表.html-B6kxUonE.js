import{_ as t,c as a,e as i,o as n}from"./app-B0QNlm-d.js";const l="/assets/image-1-EZbfT7Z2.png",o={};function r(s,e){return n(),a("div",null,[...e[0]||(e[0]=[i('<h1 id="栈式散列符号表" tabindex="-1"><a class="header-anchor" href="#栈式散列符号表"><span>栈式散列符号表</span></a></h1><p>栈式散列符号表（Stacked Hash Symbol Table）是编译原理中常用的符号表实现方式，结合了哈希表的高效查找与栈结构的作用域管理，广泛用于编译器的词法分析和语法分析阶段。</p><h2 id="设计思想" tabindex="-1"><a class="header-anchor" href="#设计思想"><span>设计思想</span></a></h2><ul><li><strong>哈希表</strong>：用于高效存储和查找符号（如变量、函数名等）。</li><li><strong>栈结构</strong>：用于管理作用域（如函数、代码块、循环等的嵌套）。每进入一个新作用域，压入一层新表；离开作用域时弹出。</li></ul><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h2><ol><li>进入新作用域时，创建一个新的哈希表并压入栈顶。</li><li>查找符号时，从栈顶向下依次查找，遇到第一个命中即返回。</li><li>插入符号时，只在当前作用域（栈顶哈希表）插入。</li><li>离开作用域时，弹出栈顶哈希表，自动移除该作用域的所有符号。</li></ol><h2 id="结构示意图" tabindex="-1"><a class="header-anchor" href="#结构示意图"><span>结构示意图</span></a></h2><figure><img src="'+l+'" alt="栈式散列符号表结构" tabindex="0" loading="lazy"><figcaption>栈式散列符号表结构</figcaption></figure><h2 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h2><ul><li>支持嵌套作用域，自动管理变量生命周期。</li><li>查找、插入效率高，适合大多数编译器实现。</li><li>离开作用域时无需逐个删除符号，直接弹栈即可。</li></ul><h2 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h2><ul><li>变量、函数、类型名等符号的作用域管理。</li><li>语法分析、语义分析阶段的符号查找与插入。</li></ul><hr><blockquote><p>栈式散列符号表是现代编译器实现中最常用、最实用的符号表结构之一。</p></blockquote>',14)])])}const p=t(o,[["render",r]]),h=JSON.parse('{"path":"/tech/%E6%A0%88%E5%BC%8F%E6%95%A3%E5%88%97%E7%AC%A6%E5%8F%B7%E8%A1%A8.html","title":"栈式散列符号表","lang":"en-US","frontmatter":{"title":"栈式散列符号表","category":["编译原理"],"description":"栈式散列符号表 栈式散列符号表（Stacked Hash Symbol Table）是编译原理中常用的符号表实现方式，结合了哈希表的高效查找与栈结构的作用域管理，广泛用于编译器的词法分析和语法分析阶段。 设计思想 哈希表：用于高效存储和查找符号（如变量、函数名等）。 栈结构：用于管理作用域（如函数、代码块、循环等的嵌套）。每进入一个新作用域，压入一层新...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"栈式散列符号表\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-31T15:04:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KSJ\\",\\"url\\":\\"https://github.com/King-sj\\"}]}"],["meta",{"property":"og:url","content":"https://github.com/King-sj/tech/%E6%A0%88%E5%BC%8F%E6%95%A3%E5%88%97%E7%AC%A6%E5%8F%B7%E8%A1%A8.html"}],["meta",{"property":"og:site_name","content":"kblog"}],["meta",{"property":"og:title","content":"栈式散列符号表"}],["meta",{"property":"og:description","content":"栈式散列符号表 栈式散列符号表（Stacked Hash Symbol Table）是编译原理中常用的符号表实现方式，结合了哈希表的高效查找与栈结构的作用域管理，广泛用于编译器的词法分析和语法分析阶段。 设计思想 哈希表：用于高效存储和查找符号（如变量、函数名等）。 栈结构：用于管理作用域（如函数、代码块、循环等的嵌套）。每进入一个新作用域，压入一层新..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-31T15:04:47.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-31T15:04:47.000Z"}]]},"git":{"createdTime":1767193487000,"updatedTime":1767193487000,"contributors":[{"name":"king-sj","username":"king-sj","email":"2175616761@qq.com","commits":1,"url":"https://github.com/king-sj"}]},"readingTime":{"minutes":1.32,"words":395},"filePathRelative":"tech/栈式散列符号表.md","excerpt":"\\n<p>栈式散列符号表（Stacked Hash Symbol Table）是编译原理中常用的符号表实现方式，结合了哈希表的高效查找与栈结构的作用域管理，广泛用于编译器的词法分析和语法分析阶段。</p>\\n<h2>设计思想</h2>\\n<ul>\\n<li><strong>哈希表</strong>：用于高效存储和查找符号（如变量、函数名等）。</li>\\n<li><strong>栈结构</strong>：用于管理作用域（如函数、代码块、循环等的嵌套）。每进入一个新作用域，压入一层新表；离开作用域时弹出。</li>\\n</ul>\\n<h2>工作原理</h2>\\n<ol>\\n<li>进入新作用域时，创建一个新的哈希表并压入栈顶。</li>\\n<li>查找符号时，从栈顶向下依次查找，遇到第一个命中即返回。</li>\\n<li>插入符号时，只在当前作用域（栈顶哈希表）插入。</li>\\n<li>离开作用域时，弹出栈顶哈希表，自动移除该作用域的所有符号。</li>\\n</ol>","autoDesc":true}');export{p as comp,h as data};
