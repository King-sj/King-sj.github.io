import{_ as t,r as a,o as i,c as n,b as e,e as r,d as h,f as s}from"./app-ByePDVBg.js";const o={},c=s('<h1 id="贪心算法的正确性" tabindex="-1"><a class="header-anchor" href="#贪心算法的正确性"><span>贪心算法的正确性</span></a></h1><p>贪心算法（Greedy Algorithm）是一类在每一步都做出当前最优选择，期望通过局部最优达到全局最优的算法。</p><h2 id="正确性判定的核心思想" tabindex="-1"><a class="header-anchor" href="#正确性判定的核心思想"><span>正确性判定的核心思想</span></a></h2><p>贪心算法并不总是正确，只有满足特定条件时才可用。判断贪心算法正确性的常用方法有：</p><h3 id="_1-最优子结构" tabindex="-1"><a class="header-anchor" href="#_1-最优子结构"><span>1. 最优子结构</span></a></h3><ul><li>问题的最优解包含其子问题的最优解。</li><li>例：最短路径、区间调度。</li></ul><h3 id="_2-无后效性" tabindex="-1"><a class="header-anchor" href="#_2-无后效性"><span>2. 无后效性</span></a></h3><ul><li>某一步的选择不会影响后续状态，只与当前状态有关。</li><li>例：活动选择问题。</li></ul><h3 id="_3-贪心选择性质" tabindex="-1"><a class="header-anchor" href="#_3-贪心选择性质"><span>3. 贪心选择性质</span></a></h3><ul><li>通过局部最优选择能得到全局最优解。</li><li>例：找零问题、哈夫曼编码。</li></ul><h2 id="常见证明方法" tabindex="-1"><a class="header-anchor" href="#常见证明方法"><span>常见证明方法</span></a></h2><ol><li><strong>反证法</strong>：假设贪心解不是最优解，构造矛盾。</li><li><strong>归纳法</strong>：证明每一步贪心选择后，剩下的子问题仍满足贪心性质。</li><li><strong>交换法</strong>：将最优解中的非贪心选择与贪心选择交换，最终可变为贪心解且不劣于原解。</li></ol><h2 id="典型例题" tabindex="-1"><a class="header-anchor" href="#典型例题"><span>典型例题</span></a></h2><h3 id="_1-区间选点-区间调度" tabindex="-1"><a class="header-anchor" href="#_1-区间选点-区间调度"><span>1. 区间选点/区间调度</span></a></h3><ul><li>每次选择右端点最小的区间，能保证全局最优。</li><li>证明：交换法或反证法。</li></ul><h3 id="_2-找零问题" tabindex="-1"><a class="header-anchor" href="#_2-找零问题"><span>2. 找零问题</span></a></h3><ul><li>每次优先用面值最大的硬币。</li><li>只有当硬币面值满足特定条件（如完全背包、标准币种）时贪心才正确。</li></ul><h3 id="_3-哈夫曼编码" tabindex="-1"><a class="header-anchor" href="#_3-哈夫曼编码"><span>3. 哈夫曼编码</span></a></h3><ul><li>每次合并权值最小的两个节点。</li><li>归纳法证明其最优性。</li></ul><h2 id="反例-贪心不正确的情况" tabindex="-1"><a class="header-anchor" href="#反例-贪心不正确的情况"><span>反例：贪心不正确的情况</span></a></h2><ul><li>有些问题贪心不能保证最优，如背包问题（0-1背包）、部分图最短路等。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>贪心算法正确性需严格证明，不能凭直觉。</li><li>常用最优子结构、无后效性、贪心选择性质三大标准。</li><li>证明方法以反证法、归纳法、交换法为主。</li></ul><hr><p>参考：</p>',25),d={href:"https://oi-wiki.org/basic/greedy/",target:"_blank",rel:"noopener noreferrer"};function p(u,_){const l=a("ExternalLinkIcon");return i(),n("div",null,[c,e("ul",null,[e("li",null,[e("a",d,[r("OI Wiki: 贪心"),h(l)])])])])}const m=t(o,[["render",p],["__file","贪心正确性.html.vue"]]),f=JSON.parse('{"path":"/tech/%E8%B4%AA%E5%BF%83%E6%AD%A3%E7%A1%AE%E6%80%A7.html","title":"贪心算法的正确性","lang":"zh-CN","frontmatter":{"title":"贪心算法的正确性","category":["算法"],"description":"贪心算法的正确性 贪心算法（Greedy Algorithm）是一类在每一步都做出当前最优选择，期望通过局部最优达到全局最优的算法。 正确性判定的核心思想 贪心算法并不总是正确，只有满足特定条件时才可用。判断贪心算法正确性的常用方法有： 1. 最优子结构 问题的最优解包含其子问题的最优解。 例：最短路径、区间调度。 2. 无后效性 某一步的选择不会影响...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://github.com/King-sj/tech/%E8%B4%AA%E5%BF%83%E6%AD%A3%E7%A1%AE%E6%80%A7.html"}],["meta",{"property":"og:site_name","content":"blog"}],["meta",{"property":"og:title","content":"贪心算法的正确性"}],["meta",{"property":"og:description","content":"贪心算法的正确性 贪心算法（Greedy Algorithm）是一类在每一步都做出当前最优选择，期望通过局部最优达到全局最优的算法。 正确性判定的核心思想 贪心算法并不总是正确，只有满足特定条件时才可用。判断贪心算法正确性的常用方法有： 1. 最优子结构 问题的最优解包含其子问题的最优解。 例：最短路径、区间调度。 2. 无后效性 某一步的选择不会影响..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"KSJ"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"贪心算法的正确性\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KSJ\\",\\"url\\":\\"https://github.com/King-sj\\"}]}"]]},"headers":[{"level":2,"title":"正确性判定的核心思想","slug":"正确性判定的核心思想","link":"#正确性判定的核心思想","children":[{"level":3,"title":"1. 最优子结构","slug":"_1-最优子结构","link":"#_1-最优子结构","children":[]},{"level":3,"title":"2. 无后效性","slug":"_2-无后效性","link":"#_2-无后效性","children":[]},{"level":3,"title":"3. 贪心选择性质","slug":"_3-贪心选择性质","link":"#_3-贪心选择性质","children":[]}]},{"level":2,"title":"常见证明方法","slug":"常见证明方法","link":"#常见证明方法","children":[]},{"level":2,"title":"典型例题","slug":"典型例题","link":"#典型例题","children":[{"level":3,"title":"1. 区间选点/区间调度","slug":"_1-区间选点-区间调度","link":"#_1-区间选点-区间调度","children":[]},{"level":3,"title":"2. 找零问题","slug":"_2-找零问题","link":"#_2-找零问题","children":[]},{"level":3,"title":"3. 哈夫曼编码","slug":"_3-哈夫曼编码","link":"#_3-哈夫曼编码","children":[]}]},{"level":2,"title":"反例：贪心不正确的情况","slug":"反例-贪心不正确的情况","link":"#反例-贪心不正确的情况","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":1.7,"words":509},"filePathRelative":"tech/贪心正确性.md","excerpt":"\\n<p>贪心算法（Greedy Algorithm）是一类在每一步都做出当前最优选择，期望通过局部最优达到全局最优的算法。</p>\\n<h2>正确性判定的核心思想</h2>\\n<p>贪心算法并不总是正确，只有满足特定条件时才可用。判断贪心算法正确性的常用方法有：</p>\\n<h3>1. 最优子结构</h3>\\n<ul>\\n<li>问题的最优解包含其子问题的最优解。</li>\\n<li>例：最短路径、区间调度。</li>\\n</ul>\\n<h3>2. 无后效性</h3>\\n<ul>\\n<li>某一步的选择不会影响后续状态，只与当前状态有关。</li>\\n<li>例：活动选择问题。</li>\\n</ul>\\n<h3>3. 贪心选择性质</h3>","autoDesc":true}');export{m as comp,f as data};
