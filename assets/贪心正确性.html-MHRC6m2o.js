import{_ as a,c as t,e as i,o as n}from"./app-C0NYnE53.js";const l={};function r(h,e){return n(),t("div",null,[...e[0]||(e[0]=[i('<h1 id="贪心算法的正确性" tabindex="-1"><a class="header-anchor" href="#贪心算法的正确性"><span>贪心算法的正确性</span></a></h1><p>贪心算法（Greedy Algorithm）是一类在每一步都做出当前最优选择，期望通过局部最优达到全局最优的算法。</p><h2 id="正确性判定的核心思想" tabindex="-1"><a class="header-anchor" href="#正确性判定的核心思想"><span>正确性判定的核心思想</span></a></h2><p>贪心算法并不总是正确，只有满足特定条件时才可用。判断贪心算法正确性的常用方法有：</p><h3 id="_1-最优子结构" tabindex="-1"><a class="header-anchor" href="#_1-最优子结构"><span>1. 最优子结构</span></a></h3><ul><li>问题的最优解包含其子问题的最优解。</li><li>例：最短路径、区间调度。</li></ul><h3 id="_2-无后效性" tabindex="-1"><a class="header-anchor" href="#_2-无后效性"><span>2. 无后效性</span></a></h3><ul><li>某一步的选择不会影响后续状态，只与当前状态有关。</li><li>例：活动选择问题。</li></ul><h3 id="_3-贪心选择性质" tabindex="-1"><a class="header-anchor" href="#_3-贪心选择性质"><span>3. 贪心选择性质</span></a></h3><ul><li>通过局部最优选择能得到全局最优解。</li><li>例：找零问题、哈夫曼编码。</li></ul><h2 id="常见证明方法" tabindex="-1"><a class="header-anchor" href="#常见证明方法"><span>常见证明方法</span></a></h2><ol><li><strong>反证法</strong>：假设贪心解不是最优解，构造矛盾。</li><li><strong>归纳法</strong>：证明每一步贪心选择后，剩下的子问题仍满足贪心性质。</li><li><strong>交换法</strong>：将最优解中的非贪心选择与贪心选择交换，最终可变为贪心解且不劣于原解。</li></ol><h2 id="典型例题" tabindex="-1"><a class="header-anchor" href="#典型例题"><span>典型例题</span></a></h2><h3 id="_1-区间选点-区间调度" tabindex="-1"><a class="header-anchor" href="#_1-区间选点-区间调度"><span>1. 区间选点/区间调度</span></a></h3><ul><li>每次选择右端点最小的区间，能保证全局最优。</li><li>证明：交换法或反证法。</li></ul><h3 id="_2-找零问题" tabindex="-1"><a class="header-anchor" href="#_2-找零问题"><span>2. 找零问题</span></a></h3><ul><li>每次优先用面值最大的硬币。</li><li>只有当硬币面值满足特定条件（如完全背包、标准币种）时贪心才正确。</li></ul><h3 id="_3-哈夫曼编码" tabindex="-1"><a class="header-anchor" href="#_3-哈夫曼编码"><span>3. 哈夫曼编码</span></a></h3><ul><li>每次合并权值最小的两个节点。</li><li>归纳法证明其最优性。</li></ul><h2 id="反例-贪心不正确的情况" tabindex="-1"><a class="header-anchor" href="#反例-贪心不正确的情况"><span>反例：贪心不正确的情况</span></a></h2><ul><li>有些问题贪心不能保证最优，如背包问题（0-1背包）、部分图最短路等。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>贪心算法正确性需严格证明，不能凭直觉。</li><li>常用最优子结构、无后效性、贪心选择性质三大标准。</li><li>证明方法以反证法、归纳法、交换法为主。</li></ul><hr><p>参考：</p><ul><li><a href="https://oi-wiki.org/basic/greedy/" target="_blank" rel="noopener noreferrer">OI Wiki: 贪心</a></li></ul>',26)])])}const o=a(l,[["render",r]]),p=JSON.parse('{"path":"/tech/%E8%B4%AA%E5%BF%83%E6%AD%A3%E7%A1%AE%E6%80%A7.html","title":"贪心算法的正确性","lang":"en-US","frontmatter":{"title":"贪心算法的正确性","category":["算法"],"description":"贪心算法的正确性 贪心算法（Greedy Algorithm）是一类在每一步都做出当前最优选择，期望通过局部最优达到全局最优的算法。 正确性判定的核心思想 贪心算法并不总是正确，只有满足特定条件时才可用。判断贪心算法正确性的常用方法有： 1. 最优子结构 问题的最优解包含其子问题的最优解。 例：最短路径、区间调度。 2. 无后效性 某一步的选择不会影响...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"贪心算法的正确性\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-31T15:12:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KSJ\\",\\"url\\":\\"https://github.com/King-sj\\"}]}"],["meta",{"property":"og:url","content":"https://github.com/King-sj/tech/%E8%B4%AA%E5%BF%83%E6%AD%A3%E7%A1%AE%E6%80%A7.html"}],["meta",{"property":"og:site_name","content":"kblog"}],["meta",{"property":"og:title","content":"贪心算法的正确性"}],["meta",{"property":"og:description","content":"贪心算法的正确性 贪心算法（Greedy Algorithm）是一类在每一步都做出当前最优选择，期望通过局部最优达到全局最优的算法。 正确性判定的核心思想 贪心算法并不总是正确，只有满足特定条件时才可用。判断贪心算法正确性的常用方法有： 1. 最优子结构 问题的最优解包含其子问题的最优解。 例：最短路径、区间调度。 2. 无后效性 某一步的选择不会影响..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-31T15:12:39.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-31T15:12:39.000Z"}]]},"git":{"createdTime":1767193959000,"updatedTime":1767193959000,"contributors":[{"name":"king-sj","username":"king-sj","email":"2175616761@qq.com","commits":1,"url":"https://github.com/king-sj"}]},"readingTime":{"minutes":1.7,"words":509},"filePathRelative":"tech/贪心正确性.md","excerpt":"\\n<p>贪心算法（Greedy Algorithm）是一类在每一步都做出当前最优选择，期望通过局部最优达到全局最优的算法。</p>\\n<h2>正确性判定的核心思想</h2>\\n<p>贪心算法并不总是正确，只有满足特定条件时才可用。判断贪心算法正确性的常用方法有：</p>\\n<h3>1. 最优子结构</h3>\\n<ul>\\n<li>问题的最优解包含其子问题的最优解。</li>\\n<li>例：最短路径、区间调度。</li>\\n</ul>\\n<h3>2. 无后效性</h3>\\n<ul>\\n<li>某一步的选择不会影响后续状态，只与当前状态有关。</li>\\n<li>例：活动选择问题。</li>\\n</ul>\\n<h3>3. 贪心选择性质</h3>","autoDesc":true}');export{o as comp,p as data};
