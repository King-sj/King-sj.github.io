import{_ as s,r as l,o,c as r,b as n,e as t,d as e,f as c}from"./app-DkfD2H4x.js";const i={},p=c(`<h1 id="actor-并发模型" tabindex="-1"><a class="header-anchor" href="#actor-并发模型"><span>actor 并发模型</span></a></h1><p>Actor 模型是一种高度面向对象、无锁、异步、天生支持分布式和容错的并发编程范式。它将系统中的每个实体抽象为 Actor，彼此通过消息传递进行通信。</p><h2 id="主要特性" tabindex="-1"><a class="header-anchor" href="#主要特性"><span>主要特性</span></a></h2><ul><li>更加面向对象：每个 Actor 封装状态和行为，彼此独立。</li><li>无锁：避免传统多线程的锁竞争问题。</li><li>异步消息传递：Actor 之间通过异步消息通信，天然适合分布式场景。</li><li>天生分布式：Actor 可以分布在不同节点，透明通信。</li><li>容错（Let it crash）：Actor 崩溃后可由监控者自动重启，提升系统健壮性。</li></ul><h2 id="劣势" tabindex="-1"><a class="header-anchor" href="#劣势"><span>劣势</span></a></h2><ul><li>调试和追踪较为复杂，难以全局把控。</li><li>消息顺序和一致性需额外关注。</li><li>性能受限于消息传递和调度开销。</li></ul><h2 id="常见并发模型对比" tabindex="-1"><a class="header-anchor" href="#常见并发模型对比"><span>常见并发模型对比</span></a></h2><ul><li>多线程：共享内存，需加锁，易出错。</li><li>协程/异步：轻量级线程，适合 IO 密集型。</li><li>Actor：消息驱动，天然分布式，适合高并发和容错需求。</li></ul><h2 id="典型实现" tabindex="-1"><a class="header-anchor" href="#典型实现"><span>典型实现</span></a></h2><ul><li>Smalltalk：最早提出面向对象消息传递思想。</li><li>Objective-C：借鉴 Smalltalk 的消息机制。</li><li>Erlang：工业级 Actor 模型代表，广泛应用于电信、分布式系统。</li><li>Rust：如 Actix、riker 等库实现 Actor 并发。</li></ul><h2 id="代码示例-erlang" tabindex="-1"><a class="header-anchor" href="#代码示例-erlang"><span>代码示例（Erlang）</span></a></h2><div class="language-erlang line-numbers-mode" data-ext="erlang" data-title="erlang"><pre class="language-erlang"><code><span class="token comment">% 简单的 echo actor</span>
<span class="token function">echo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token keyword">receive</span>
        <span class="token punctuation">{</span><span class="token variable">From</span><span class="token punctuation">,</span> <span class="token variable">Msg</span><span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
            <span class="token atom">io</span><span class="token punctuation">:</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;Received: ~p~n&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token variable">Msg</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token variable">From</span> <span class="token operator">!</span> <span class="token punctuation">{</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">Msg</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token function">echo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">end</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="rust-中-actor-并发模型的实践" tabindex="-1"><a class="header-anchor" href="#rust-中-actor-并发模型的实践"><span>Rust 中 Actor 并发模型的实践</span></a></h2><p>Rust 生态中有如 Actix、riker 等高性能 Actor 框架，适合构建高并发、分布式服务。</p>`,14),u={href:"https://blog.csdn.net/smilejiasmile/article/details/138037188",target:"_blank",rel:"noopener noreferrer"},h=n("h2",{id:"理论与资料",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#理论与资料"},[n("span",null,"理论与资料")])],-1),d={href:"https://zhuanlan.zhihu.com/p/86460724",target:"_blank",rel:"noopener noreferrer"},g={href:"https://www.erlang.org/doc/",target:"_blank",rel:"noopener noreferrer"},k={href:"https://actix.rs/docs/",target:"_blank",rel:"noopener noreferrer"},m=n("hr",null,null,-1),v=n("p",null,"Actor 模型已成为现代分布式系统和高并发服务的重要基础，适合对高可用、可扩展性有极高要求的场景。",-1);function _(b,A){const a=l("ExternalLinkIcon");return o(),r("div",null,[p,n("ul",null,[n("li",null,[n("a",u,[t("Rust 中 Actor 并发模型的实践与使用"),e(a)])])]),h,n("ul",null,[n("li",null,[n("a",d,[t("Actor 模型原理与 Erlang 实践"),e(a)])]),n("li",null,[n("a",g,[t("Erlang 官方文档"),e(a)])]),n("li",null,[n("a",k,[t("Actix 官方文档"),e(a)])])]),m,v])}const x=s(i,[["render",_],["__file","actor.html.vue"]]),y=JSON.parse('{"path":"/tech/actor.html","title":"actor 并发模型简介与实践","lang":"zh-CN","frontmatter":{"category":"并发","tags":["actor","并发模型","erlang","rust","分布式","容错"],"title":"actor 并发模型简介与实践","summary":"介绍 actor 并发模型的基本思想、优势与劣势、典型实现（如 Erlang、Rust），并给出相关理论与实践资料。","description":"actor 并发模型 Actor 模型是一种高度面向对象、无锁、异步、天生支持分布式和容错的并发编程范式。它将系统中的每个实体抽象为 Actor，彼此通过消息传递进行通信。 主要特性 更加面向对象：每个 Actor 封装状态和行为，彼此独立。 无锁：避免传统多线程的锁竞争问题。 异步消息传递：Actor 之间通过异步消息通信，天然适合分布式场景。 天生...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://github.com/King-sj/tech/actor.html"}],["meta",{"property":"og:site_name","content":"blog"}],["meta",{"property":"og:title","content":"actor 并发模型简介与实践"}],["meta",{"property":"og:description","content":"actor 并发模型 Actor 模型是一种高度面向对象、无锁、异步、天生支持分布式和容错的并发编程范式。它将系统中的每个实体抽象为 Actor，彼此通过消息传递进行通信。 主要特性 更加面向对象：每个 Actor 封装状态和行为，彼此独立。 无锁：避免传统多线程的锁竞争问题。 异步消息传递：Actor 之间通过异步消息通信，天然适合分布式场景。 天生..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"KSJ"}],["meta",{"property":"article:tag","content":"actor"}],["meta",{"property":"article:tag","content":"并发模型"}],["meta",{"property":"article:tag","content":"erlang"}],["meta",{"property":"article:tag","content":"rust"}],["meta",{"property":"article:tag","content":"分布式"}],["meta",{"property":"article:tag","content":"容错"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"actor 并发模型简介与实践\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KSJ\\",\\"url\\":\\"https://github.com/King-sj\\"}]}"]]},"headers":[{"level":2,"title":"主要特性","slug":"主要特性","link":"#主要特性","children":[]},{"level":2,"title":"劣势","slug":"劣势","link":"#劣势","children":[]},{"level":2,"title":"常见并发模型对比","slug":"常见并发模型对比","link":"#常见并发模型对比","children":[]},{"level":2,"title":"典型实现","slug":"典型实现","link":"#典型实现","children":[]},{"level":2,"title":"代码示例（Erlang）","slug":"代码示例-erlang","link":"#代码示例-erlang","children":[]},{"level":2,"title":"Rust 中 Actor 并发模型的实践","slug":"rust-中-actor-并发模型的实践","link":"#rust-中-actor-并发模型的实践","children":[]},{"level":2,"title":"理论与资料","slug":"理论与资料","link":"#理论与资料","children":[]}],"readingTime":{"minutes":1.83,"words":549},"filePathRelative":"tech/actor.md","excerpt":"\\n<p>Actor 模型是一种高度面向对象、无锁、异步、天生支持分布式和容错的并发编程范式。它将系统中的每个实体抽象为 Actor，彼此通过消息传递进行通信。</p>\\n<h2>主要特性</h2>\\n<ul>\\n<li>更加面向对象：每个 Actor 封装状态和行为，彼此独立。</li>\\n<li>无锁：避免传统多线程的锁竞争问题。</li>\\n<li>异步消息传递：Actor 之间通过异步消息通信，天然适合分布式场景。</li>\\n<li>天生分布式：Actor 可以分布在不同节点，透明通信。</li>\\n<li>容错（Let it crash）：Actor 崩溃后可由监控者自动重启，提升系统健壮性。</li>\\n</ul>","autoDesc":true}');export{x as comp,y as data};
