import{_ as i,c as s,e as t,o as e}from"./app-Bi-vtw0j.js";const n={};function r(l,a){return e(),s("div",null,[...a[0]||(a[0]=[t(`<h1 id="actor-并发模型" tabindex="-1"><a class="header-anchor" href="#actor-并发模型"><span>actor 并发模型</span></a></h1><p>Actor 模型是一种高度面向对象、无锁、异步、天生支持分布式和容错的并发编程范式。它将系统中的每个实体抽象为 Actor，彼此通过消息传递进行通信。</p><h2 id="主要特性" tabindex="-1"><a class="header-anchor" href="#主要特性"><span>主要特性</span></a></h2><ul><li>更加面向对象：每个 Actor 封装状态和行为，彼此独立。</li><li>无锁：避免传统多线程的锁竞争问题。</li><li>异步消息传递：Actor 之间通过异步消息通信，天然适合分布式场景。</li><li>天生分布式：Actor 可以分布在不同节点，透明通信。</li><li>容错（Let it crash）：Actor 崩溃后可由监控者自动重启，提升系统健壮性。</li></ul><h2 id="劣势" tabindex="-1"><a class="header-anchor" href="#劣势"><span>劣势</span></a></h2><ul><li>调试和追踪较为复杂，难以全局把控。</li><li>消息顺序和一致性需额外关注。</li><li>性能受限于消息传递和调度开销。</li></ul><h2 id="常见并发模型对比" tabindex="-1"><a class="header-anchor" href="#常见并发模型对比"><span>常见并发模型对比</span></a></h2><ul><li>多线程：共享内存，需加锁，易出错。</li><li>协程/异步：轻量级线程，适合 IO 密集型。</li><li>Actor：消息驱动，天然分布式，适合高并发和容错需求。</li></ul><h2 id="典型实现" tabindex="-1"><a class="header-anchor" href="#典型实现"><span>典型实现</span></a></h2><ul><li>Smalltalk：最早提出面向对象消息传递思想。</li><li>Objective-C：借鉴 Smalltalk 的消息机制。</li><li>Erlang：工业级 Actor 模型代表，广泛应用于电信、分布式系统。</li><li>Rust：如 Actix、riker 等库实现 Actor 并发。</li></ul><h2 id="代码示例-erlang" tabindex="-1"><a class="header-anchor" href="#代码示例-erlang"><span>代码示例（Erlang）</span></a></h2><div class="language-erlang line-numbers-mode" data-highlighter="shiki" data-ext="erlang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-erlang"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% 简单的 echo actor</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">echo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() -&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    receive</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        {</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">From</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Msg</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} -&gt;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">            io</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">format</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Received: </span><span style="--shiki-light:#50A14F;--shiki-dark:#D19A66;">~</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">p</span><span style="--shiki-light:#50A14F;--shiki-dark:#D19A66;">~</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, [</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Msg</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]),</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">            From</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ! {</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Msg</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">},</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            echo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    end</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="rust-中-actor-并发模型的实践" tabindex="-1"><a class="header-anchor" href="#rust-中-actor-并发模型的实践"><span>Rust 中 Actor 并发模型的实践</span></a></h2><p>Rust 生态中有如 Actix、riker 等高性能 Actor 框架，适合构建高并发、分布式服务。</p><ul><li><a href="https://blog.csdn.net/smilejiasmile/article/details/138037188" target="_blank" rel="noopener noreferrer">Rust 中 Actor 并发模型的实践与使用</a></li></ul><h2 id="理论与资料" tabindex="-1"><a class="header-anchor" href="#理论与资料"><span>理论与资料</span></a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/86460724" target="_blank" rel="noopener noreferrer">Actor 模型原理与 Erlang 实践</a></li><li><a href="https://www.erlang.org/doc/" target="_blank" rel="noopener noreferrer">Erlang 官方文档</a></li><li><a href="https://actix.rs/docs/" target="_blank" rel="noopener noreferrer">Actix 官方文档</a></li></ul><hr><p>Actor 模型已成为现代分布式系统和高并发服务的重要基础，适合对高可用、可扩展性有极高要求的场景。</p><h1 id="actor-并发模型-1" tabindex="-1"><a class="header-anchor" href="#actor-并发模型-1"><span>actor 并发模型</span></a></h1><h2 id="并发模型" tabindex="-1"><a class="header-anchor" href="#并发模型"><span>并发模型</span></a></h2><ul><li>多线程</li><li>协程/异步</li><li>actor</li></ul><h2 id="理论" tabindex="-1"><a class="header-anchor" href="#理论"><span>理论</span></a></h2><p>https://zhuanlan.zhihu.com/p/86460724</p><h2 id="rust-中-actor-并发模型的实践与使用" tabindex="-1"><a class="header-anchor" href="#rust-中-actor-并发模型的实践与使用"><span>Rust 中 Actor 并发模型的实践与使用</span></a></h2><p>https://blog.csdn.net/smilejiasmile/article/details/138037188</p>`,26)])])}const p=i(n,[["render",r]]),c=JSON.parse('{"path":"/tech/actor.html","title":"actor 并发模型简介与实践","lang":"en-US","frontmatter":{"category":"并发","tags":["actor","并发模型","erlang","rust","分布式","容错"],"title":"actor 并发模型简介与实践","summary":"介绍 actor 并发模型的基本思想、优势与劣势、典型实现（如 Erlang、Rust），并给出相关理论与实践资料。","description":"actor 并发模型 Actor 模型是一种高度面向对象、无锁、异步、天生支持分布式和容错的并发编程范式。它将系统中的每个实体抽象为 Actor，彼此通过消息传递进行通信。 主要特性 更加面向对象：每个 Actor 封装状态和行为，彼此独立。 无锁：避免传统多线程的锁竞争问题。 异步消息传递：Actor 之间通过异步消息通信，天然适合分布式场景。 天生...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"actor 并发模型简介与实践\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-31T15:07:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KSJ\\",\\"url\\":\\"https://github.com/King-sj\\"}]}"],["meta",{"property":"og:url","content":"https://github.com/King-sj/tech/actor.html"}],["meta",{"property":"og:site_name","content":"kblog"}],["meta",{"property":"og:title","content":"actor 并发模型简介与实践"}],["meta",{"property":"og:description","content":"actor 并发模型 Actor 模型是一种高度面向对象、无锁、异步、天生支持分布式和容错的并发编程范式。它将系统中的每个实体抽象为 Actor，彼此通过消息传递进行通信。 主要特性 更加面向对象：每个 Actor 封装状态和行为，彼此独立。 无锁：避免传统多线程的锁竞争问题。 异步消息传递：Actor 之间通过异步消息通信，天然适合分布式场景。 天生..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-31T15:07:46.000Z"}],["meta",{"property":"article:tag","content":"容错"}],["meta",{"property":"article:tag","content":"分布式"}],["meta",{"property":"article:tag","content":"rust"}],["meta",{"property":"article:tag","content":"erlang"}],["meta",{"property":"article:tag","content":"并发模型"}],["meta",{"property":"article:tag","content":"actor"}],["meta",{"property":"article:modified_time","content":"2025-12-31T15:07:46.000Z"}]]},"git":{"createdTime":1767193666000,"updatedTime":1767193666000,"contributors":[{"name":"king-sj","username":"king-sj","email":"2175616761@qq.com","commits":1,"url":"https://github.com/king-sj"}]},"readingTime":{"minutes":1.95,"words":586},"filePathRelative":"tech/actor.md","excerpt":"\\n<p>Actor 模型是一种高度面向对象、无锁、异步、天生支持分布式和容错的并发编程范式。它将系统中的每个实体抽象为 Actor，彼此通过消息传递进行通信。</p>\\n<h2>主要特性</h2>\\n<ul>\\n<li>更加面向对象：每个 Actor 封装状态和行为，彼此独立。</li>\\n<li>无锁：避免传统多线程的锁竞争问题。</li>\\n<li>异步消息传递：Actor 之间通过异步消息通信，天然适合分布式场景。</li>\\n<li>天生分布式：Actor 可以分布在不同节点，透明通信。</li>\\n<li>容错（Let it crash）：Actor 崩溃后可由监控者自动重启，提升系统健壮性。</li>\\n</ul>","autoDesc":true}');export{p as comp,c as data};
