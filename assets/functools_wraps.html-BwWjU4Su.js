import{_ as t,o,c as r,f as e}from"./app-DFDsyZGc.js";const p={},n=e("<p>functools.wraps 是 Python 中的一个装饰器，用于装饰另一个装饰器，使其保留被装饰函数的元数据，如函数名、文档字符串等。这在编写装饰器时非常有用，因为装饰器会改变被装饰函数的属性，使得调试和文档生成变得困难。</p><p>使用示例</p><p>以下是一个没有使用 functools.wraps 的装饰器示例：</p><p>def my_decorator(func): def wrapper(*args, **kwargs): &quot;&quot;&quot;decorator&quot;&quot;&quot; print(&#39;Calling decorated function...&#39;) return func(*args, **kwargs) return wrapper</p><p>@my_decorator def example(): &quot;&quot;&quot;Docstring&quot;&quot;&quot; print(&#39;Called example function&#39;)</p><p>print(example.<strong>name</strong>, example.<strong>doc</strong>) 输出结果为：</p><p>wrapper decorator 可以看到，函数名和文档字符串都被改变了。</p><p>现在，我们使用 functools.wraps 来修复这个问题：</p><p>import functools</p><p>def my_decorator(func): @functools.wraps(func) def wrapper(*args, **kwargs): &quot;&quot;&quot;decorator&quot;&quot;&quot; print(&#39;Calling decorated function...&#39;) return func(*args, **kwargs) return wrapper</p><p>@my_decorator def example(): &quot;&quot;&quot;Docstring&quot;&quot;&quot; print(&#39;Called example function&#39;)</p><p>print(example.<strong>name</strong>, example.<strong>doc</strong>) 输出结果为：</p><p>example Docstring 可以看到，函数名和文档字符串都被正确保留了。</p><p>重要性</p><p>使用 functools.wraps 可以确保装饰器不会改变被装饰函数的元数据，这对于调试、文档生成和代码可读性非常重要。它通过调用 functools.update_wrapper 函数来实现这一点，该函数会将被装饰函数的属性复制到装饰器函数上。</p><p>结论</p><p>functools.wraps 是编写装饰器时的一个重要工具，它可以帮助我们保留被装饰函数的元数据，从而提高代码的可读性和可维护性。在编写装饰器时，建议始终使用 functools.wraps 来装饰你的装饰器函数。</p>",17),a=[n];function c(s,u){return o(),r("div",null,a)}const f=t(p,[["render",c],["__file","functools_wraps.html.vue"]]),i=JSON.parse(`{"path":"/tech/functools_wraps.html","title":"","lang":"zh-CN","frontmatter":{"description":"functools.wraps 是 Python 中的一个装饰器，用于装饰另一个装饰器，使其保留被装饰函数的元数据，如函数名、文档字符串等。这在编写装饰器时非常有用，因为装饰器会改变被装饰函数的属性，使得调试和文档生成变得困难。 使用示例 以下是一个没有使用 functools.wraps 的装饰器示例： def my_decorator(func):...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://github.com/King-sj/tech/functools_wraps.html"}],["meta",{"property":"og:site_name","content":"blog"}],["meta",{"property":"og:description","content":"functools.wraps 是 Python 中的一个装饰器，用于装饰另一个装饰器，使其保留被装饰函数的元数据，如函数名、文档字符串等。这在编写装饰器时非常有用，因为装饰器会改变被装饰函数的属性，使得调试和文档生成变得困难。 使用示例 以下是一个没有使用 functools.wraps 的装饰器示例： def my_decorator(func):..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"KSJ"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KSJ\\",\\"url\\":\\"https://github.com/King-sj\\"}]}"]]},"headers":[],"readingTime":{"minutes":1.29,"words":387},"filePathRelative":"tech/functools_wraps.md","excerpt":"<p>functools.wraps 是 Python 中的一个装饰器，用于装饰另一个装饰器，使其保留被装饰函数的元数据，如函数名、文档字符串等。这在编写装饰器时非常有用，因为装饰器会改变被装饰函数的属性，使得调试和文档生成变得困难。</p>\\n<p>使用示例</p>\\n<p>以下是一个没有使用 functools.wraps 的装饰器示例：</p>\\n<p>def my_decorator(func):\\ndef wrapper(*args, **kwargs):\\n\\"\\"\\"decorator\\"\\"\\"\\nprint('Calling decorated function...')\\nreturn func(*args, **kwargs)\\nreturn wrapper</p>","autoDesc":true}`);export{f as comp,i as data};
