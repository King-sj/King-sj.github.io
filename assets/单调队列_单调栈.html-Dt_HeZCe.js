import{_ as n,o as s,c as a,f as t}from"./app-DkfD2H4x.js";const p={},e=t(`<h1 id="双指针" tabindex="-1"><a class="header-anchor" href="#双指针"><span>双指针</span></a></h1><p>双指针（Two Pointers）是一种常用的数组、链表遍历技巧，利用两个指针在序列上移动，解决区间、子串、去重等问题。</p><h2 id="常见应用场景" tabindex="-1"><a class="header-anchor" href="#常见应用场景"><span>常见应用场景</span></a></h2><ul><li>有序数组的两数之和/三数之和</li><li>快慢指针判断链表有环</li><li>滑动窗口求子数组/子串问题</li><li>原地去重、反转、合并等</li></ul><h3 id="典型算法1-有序数组的两数之和" tabindex="-1"><a class="header-anchor" href="#典型算法1-有序数组的两数之和"><span>典型算法1：有序数组的两数之和</span></a></h3><p>给定有序数组 nums 和目标值 target，返回两个数的下标使其和为 target。</p><p><strong>代码示例（Python）：</strong></p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>
    left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>
        s <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span>
        <span class="token keyword">if</span> s <span class="token operator">==</span> target<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span>left<span class="token punctuation">,</span> right<span class="token punctuation">]</span>
        <span class="token keyword">elif</span> s <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>
            left <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            right <span class="token operator">-=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="典型算法2-滑动窗口" tabindex="-1"><a class="header-anchor" href="#典型算法2-滑动窗口"><span>典型算法2：滑动窗口</span></a></h3><p>用于求解最长无重复子串、最小覆盖子串等问题。</p><p><strong>代码示例（Python）：</strong></p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    seen <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    left <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> right<span class="token punctuation">,</span> c <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> c <span class="token keyword">in</span> seen <span class="token keyword">and</span> seen<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> left<span class="token punctuation">:</span>
            left <span class="token operator">=</span> seen<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
        seen<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> right
        res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h1 id="单调队列" tabindex="-1"><a class="header-anchor" href="#单调队列"><span>单调队列</span></a></h1><p>单调队列是一种队列，队列中的元素保持单调递增或递减，常用于滑动窗口中的最值问题。</p><h2 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h2><ul><li>滑动窗口最大/最小值</li><li>动态维护区间最值</li></ul><h3 id="典型算法-滑动窗口最大值" tabindex="-1"><a class="header-anchor" href="#典型算法-滑动窗口最大值"><span>典型算法：滑动窗口最大值</span></a></h3><p>给定一个长度为 n 的数组 nums 和窗口大小 k，求每个窗口的最大值。</p><p><strong>思路：</strong></p><ul><li>用一个双端队列维护窗口内可能成为最大值的下标，队列头始终是当前窗口最大值下标。</li><li>每次新元素入队时，弹出队尾所有比它小的元素。</li><li>队头元素如果滑出窗口则弹出。</li></ul><p><strong>代码示例（Python）：</strong></p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque

<span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> x <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> q <span class="token keyword">and</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">:</span>
            q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        <span class="token keyword">if</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> i <span class="token operator">-</span> k<span class="token punctuation">:</span>
            q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> i <span class="token operator">&gt;=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h1 id="单调栈" tabindex="-1"><a class="header-anchor" href="#单调栈"><span>单调栈</span></a></h1><p>单调栈是一种栈结构，栈内元素保持单调递增或递减，常用于解决“下一个更大/小元素”类问题。</p><h2 id="应用场景-1" tabindex="-1"><a class="header-anchor" href="#应用场景-1"><span>应用场景</span></a></h2><ul><li>下一个更大元素/下一个更小元素</li><li>柱状图最大矩形面积</li><li>维护区间单调性</li></ul><h3 id="典型算法-下一个更大元素" tabindex="-1"><a class="header-anchor" href="#典型算法-下一个更大元素"><span>典型算法：下一个更大元素</span></a></h3><p>给定一个数组，输出每个元素右侧第一个比它大的元素，没有则为 -1。</p><p><strong>代码示例（Python）：</strong></p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">nextGreater</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
    stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> stack <span class="token keyword">and</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> stack<span class="token punctuation">:</span>
            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h1 id="三者对比" tabindex="-1"><a class="header-anchor" href="#三者对比"><span>三者对比</span></a></h1><table><thead><tr><th>技巧</th><th>结构</th><th>主要应用场景</th><th>典型问题</th><th>复杂度</th><th>适用数据结构</th></tr></thead><tbody><tr><td>双指针</td><td>指针</td><td>区间、子串、去重等</td><td>两数之和、滑窗等</td><td>O(n)</td><td>数组/链表</td></tr><tr><td>单调队列</td><td>队列</td><td>区间最值、滑动窗口</td><td>滑动窗口最大值</td><td>O(n)</td><td>数组</td></tr><tr><td>单调栈</td><td>栈</td><td>下一个更大/小元素等</td><td>柱状图最大矩形等</td><td>O(n)</td><td>数组</td></tr></tbody></table><ul><li>双指针偏向遍历与区间问题，空间消耗低。</li><li>单调队列适合动态维护区间最值，常用于滑动窗口。</li><li>单调栈适合处理“下一个更大/小元素”及区间单调性问题。</li></ul><h2 id="三者联系" tabindex="-1"><a class="header-anchor" href="#三者联系"><span>三者联系</span></a></h2><ul><li>三者本质上都是线性结构上的高效遍历与维护技巧，常用于数组、链表等顺序结构。</li><li>单调队列和单调栈都可以看作是双指针思想的进阶： <ul><li>单调队列通过队首队尾指针动态维护窗口区间的最值。</li><li>单调栈通过栈顶指针动态维护区间单调性和下一个更大/小元素。</li></ul></li><li>滑动窗口问题常常结合双指针和单调队列一起使用，提升效率。</li><li>三者都能将暴力 O(n^2) 问题优化为 O(n) 线性复杂度，是竞赛和面试中的常用套路。</li></ul><blockquote><p>三者既有区别也有联系，灵活组合能高效解决各类区间、最值、单调性相关问题。</p></blockquote>`,39),o=[e];function l(c,i){return s(),a("div",null,o)}const r=n(p,[["render",l],["__file","单调队列_单调栈.html.vue"]]),k=JSON.parse('{"path":"/tech/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97_%E5%8D%95%E8%B0%83%E6%A0%88.html","title":"单调队列与单调栈","lang":"zh-CN","frontmatter":{"title":"单调队列与单调栈","category":["算法"],"description":"双指针 双指针（Two Pointers）是一种常用的数组、链表遍历技巧，利用两个指针在序列上移动，解决区间、子串、去重等问题。 常见应用场景 有序数组的两数之和/三数之和 快慢指针判断链表有环 滑动窗口求子数组/子串问题 原地去重、反转、合并等 典型算法1：有序数组的两数之和 给定有序数组 nums 和目标值 target，返回两个数的下标使其和为 ...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://github.com/King-sj/tech/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97_%E5%8D%95%E8%B0%83%E6%A0%88.html"}],["meta",{"property":"og:site_name","content":"blog"}],["meta",{"property":"og:title","content":"单调队列与单调栈"}],["meta",{"property":"og:description","content":"双指针 双指针（Two Pointers）是一种常用的数组、链表遍历技巧，利用两个指针在序列上移动，解决区间、子串、去重等问题。 常见应用场景 有序数组的两数之和/三数之和 快慢指针判断链表有环 滑动窗口求子数组/子串问题 原地去重、反转、合并等 典型算法1：有序数组的两数之和 给定有序数组 nums 和目标值 target，返回两个数的下标使其和为 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"KSJ"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"单调队列与单调栈\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KSJ\\",\\"url\\":\\"https://github.com/King-sj\\"}]}"]]},"headers":[{"level":2,"title":"常见应用场景","slug":"常见应用场景","link":"#常见应用场景","children":[{"level":3,"title":"典型算法1：有序数组的两数之和","slug":"典型算法1-有序数组的两数之和","link":"#典型算法1-有序数组的两数之和","children":[]},{"level":3,"title":"典型算法2：滑动窗口","slug":"典型算法2-滑动窗口","link":"#典型算法2-滑动窗口","children":[]}]},{"level":2,"title":"应用场景","slug":"应用场景","link":"#应用场景","children":[{"level":3,"title":"典型算法：滑动窗口最大值","slug":"典型算法-滑动窗口最大值","link":"#典型算法-滑动窗口最大值","children":[]}]},{"level":2,"title":"应用场景","slug":"应用场景-1","link":"#应用场景-1","children":[{"level":3,"title":"典型算法：下一个更大元素","slug":"典型算法-下一个更大元素","link":"#典型算法-下一个更大元素","children":[]}]},{"level":2,"title":"三者联系","slug":"三者联系","link":"#三者联系","children":[]}],"readingTime":{"minutes":3.35,"words":1006},"filePathRelative":"tech/单调队列&单调栈.md","excerpt":"\\n<p>双指针（Two Pointers）是一种常用的数组、链表遍历技巧，利用两个指针在序列上移动，解决区间、子串、去重等问题。</p>\\n<h2>常见应用场景</h2>\\n<ul>\\n<li>有序数组的两数之和/三数之和</li>\\n<li>快慢指针判断链表有环</li>\\n<li>滑动窗口求子数组/子串问题</li>\\n<li>原地去重、反转、合并等</li>\\n</ul>\\n<h3>典型算法1：有序数组的两数之和</h3>\\n<p>给定有序数组 nums 和目标值 target，返回两个数的下标使其和为 target。</p>\\n<p><strong>代码示例（Python）：</strong></p>\\n<div class=\\"language-python\\" data-ext=\\"py\\" data-title=\\"py\\"><pre class=\\"language-python\\"><code><span class=\\"token keyword\\">def</span> <span class=\\"token function\\">twoSum</span><span class=\\"token punctuation\\">(</span>nums<span class=\\"token punctuation\\">,</span> target<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">:</span>\\n    left<span class=\\"token punctuation\\">,</span> right <span class=\\"token operator\\">=</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">,</span> <span class=\\"token builtin\\">len</span><span class=\\"token punctuation\\">(</span>nums<span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">-</span> <span class=\\"token number\\">1</span>\\n    <span class=\\"token keyword\\">while</span> left <span class=\\"token operator\\">&lt;</span> right<span class=\\"token punctuation\\">:</span>\\n        s <span class=\\"token operator\\">=</span> nums<span class=\\"token punctuation\\">[</span>left<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">+</span> nums<span class=\\"token punctuation\\">[</span>right<span class=\\"token punctuation\\">]</span>\\n        <span class=\\"token keyword\\">if</span> s <span class=\\"token operator\\">==</span> target<span class=\\"token punctuation\\">:</span>\\n            <span class=\\"token keyword\\">return</span> <span class=\\"token punctuation\\">[</span>left<span class=\\"token punctuation\\">,</span> right<span class=\\"token punctuation\\">]</span>\\n        <span class=\\"token keyword\\">elif</span> s <span class=\\"token operator\\">&lt;</span> target<span class=\\"token punctuation\\">:</span>\\n            left <span class=\\"token operator\\">+=</span> <span class=\\"token number\\">1</span>\\n        <span class=\\"token keyword\\">else</span><span class=\\"token punctuation\\">:</span>\\n            right <span class=\\"token operator\\">-=</span> <span class=\\"token number\\">1</span>\\n</code></pre></div>","autoDesc":true}');export{r as comp,k as data};
